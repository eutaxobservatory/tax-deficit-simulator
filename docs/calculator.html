<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>tax_deficit_simulator.calculator API documentation</title>
<meta name="description" content="This module is dedicated to simulations based on macroeconomic data, namely the anonymized and aggregated country-by-
country data published by the …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tax_deficit_simulator.calculator</code></h1>
</header>
<section id="section-intro">
<p>This module is dedicated to simulations based on macroeconomic data, namely the anonymized and aggregated country-by-
country data published by the OECD for the year 2016 and the data compiled by Tørløv, Wier and Zucman (2020).</p>
<p>Defining the TaxDeficitCalculator class, which encapsulates all computations for the multilaral, imperfect coordination
and unilateral scenarios presented in the report, this module pursues two main goals:</p>
<ul>
<li>
<p>providing the computational logic for simulations run on the tax deficit online simulator;</p>
</li>
<li>
<p>allowing any Python user to reproduce the results presented in the report and to better understand the assumptions
that lie behind our estimates.</p>
</li>
</ul>
<p>All explanations regarding the estimation methodology can be found in the body of the report or in its appendices. Com-
plementary information about how computations are run in Python can be found in the following docstrings and comments.</p>
<p>So far, the code presented here has not yet been optimized for performance. Feedback on how to improve computation ti-
mes, the readability of the code or anything else are very much welcome!</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module is dedicated to simulations based on macroeconomic data, namely the anonymized and aggregated country-by-
country data published by the OECD for the year 2016 and the data compiled by Tørløv, Wier and Zucman (2020).

Defining the TaxDeficitCalculator class, which encapsulates all computations for the multilaral, imperfect coordination
and unilateral scenarios presented in the report, this module pursues two main goals:

- providing the computational logic for simulations run on the tax deficit online simulator;

- allowing any Python user to reproduce the results presented in the report and to better understand the assumptions
that lie behind our estimates.

All explanations regarding the estimation methodology can be found in the body of the report or in its appendices. Com-
plementary information about how computations are run in Python can be found in the following docstrings and comments.

So far, the code presented here has not yet been optimized for performance. Feedback on how to improve computation ti-
mes, the readability of the code or anything else are very much welcome!
&#34;&#34;&#34;

# ----------------------------------------------------------------------------------------------------------------------
# --- Imports

import numpy as np
import pandas as pd

import os

from utils import rename_partner_jurisdictions, manage_overlap_with_domestic, COUNTRIES_WITH_MINIMUM_REPORTING, \
    COUNTRIES_WITH_CONTINENTAL_REPORTING, impute_missing_carve_out_values


# ----------------------------------------------------------------------------------------------------------------------
# --- Defining paths to data files and other utils

path_to_dir = os.path.dirname(os.path.abspath(__file__))

# We fetch the list of EU-28 and EU-27 country codes from a .csv file in the data folder
path_to_eu_countries = os.path.join(path_to_dir, &#39;data&#39;, &#39;listofeucountries_csv.csv&#39;)
eu_country_codes = list(pd.read_csv(path_to_eu_countries, delimiter=&#39;;&#39;)[&#39;Alpha-3 code&#39;])

eu_27_country_codes = eu_country_codes.copy()
eu_27_country_codes.remove(&#39;GBR&#39;)

# We fetch the list of tax havens&#39; alpha-3 country codes from a .csv file in the data folder
path_to_tax_haven_list = os.path.join(path_to_dir, &#39;data&#39;, &#39;tax_haven_list.csv&#39;)
tax_haven_country_codes = list(pd.read_csv(path_to_tax_haven_list, delimiter=&#39;;&#39;)[&#39;Alpha-3 code&#39;])

# Absolute paths to data files, especially useful to run the app.py file
path_to_oecd = os.path.join(path_to_dir, &#39;data&#39;, &#39;oecd.csv&#39;)
path_to_twz = os.path.join(path_to_dir, &#39;data&#39;, &#39;twz.csv&#39;)
path_to_twz_domestic = os.path.join(path_to_dir, &#39;data&#39;, &#39;twz_domestic.csv&#39;)
path_to_twz_CIT = os.path.join(path_to_dir, &#39;data&#39;, &#39;twz_CIT.csv&#39;)
path_to_preprocessed_mean_wages = os.path.join(path_to_dir, &#39;data&#39;, &#39;preprocessed_mean_wages.csv&#39;)
path_to_statutory_rates = os.path.join(path_to_dir, &#39;data&#39;, &#39;statutory_rates.csv&#39;)


# ----------------------------------------------------------------------------------------------------------------------
# --- Defining the TaxDeficitCalculator class

class TaxDeficitCalculator:

    def __init__(
        self,
        alternative_imputation=True,
        carve_outs=False,
        carve_out_rate=None,
        depreciation_only=None, exclude_inventories=None, payroll_premium=20
    ):
        &#34;&#34;&#34;
        This is the instantiation method for the TaxDeficitCalculator class.

        All its arguments have a default value. The two main ones are as follows:

        - the boolean &#34;alternative_imputation&#34; (set to True by default), determines whether the imputation of the non-
        haven tax deficit of non-OECD reporting countries at minimum rates of 20% or below is operated. For more details
        on this methodological choice, one can refer to Appendix A of the report;

        - the boolean &#34;carve_outs&#34; (False by default) indicates whether to simulate substance-based carve-outs.

        If the latter argument is set to True, additional arguments are required:

        - the &#34;carve_out_rate&#34; (float between 0 and 1) determines what share of tangible assets and payroll should be
        deduced from the pre-tax profits of multinationals;

        - the boolean &#34;depreciation_only&#34; indicates whether to only account for depreciation expenses (instead of the
        full value of tangible assets) in the tangible assets component of the carve-outs. Following the methodology of
        the OECD Secretariat in its Economic Impact Assessment of Oct. 2020, is this argument is set to True, we appro-
        ximate depreciation expenses as 10% of the book value of tangible assets;

        - the boolean &#34;exclude_inventories&#34; indicates whether to downgrade the tangible assets values provided by the
        OECD&#39;s aggregated and anonymized country-by-country data. As a simplification of the OECD&#39;s methodology (Oct.
        2020), if the argument is set to True, we reduce all tangible assets by 24%;

        - &#34;payroll_premium&#34; (float between 0 and 100 (considered as a %)) determines what upgrade to apply to the pay-
        roll proxy. Indeed, the latter is based on ILO&#39;s data about per-country mean annual earnings. Considering that
        the employees of large multinationals generally earn above-average wages, we propose to apply a premium to our
        payroll proxy.

        The instantiation function is mainly used to define several object attributes that generally correspond to as-
        sumptions taken in the report.
        &#34;&#34;&#34;

        # These attributes will store the data loaded with the &#34;load_clean_data&#34; method
        self.oecd = None
        self.twz = None
        self.twz_domestic = None
        self.twz_CIT = None
        self.mean_wages = None

        # For non-OECD reporting countries, data are taken from TWZ 2019 appendix tables
        # An effective tax rate of 20% is assumed to be applied on profits registered in non-havens
        self.assumed_non_haven_ETR_TWZ = 0.2

        # An effective tax rate of 10% is assumed to be applied on profits registered in tax havens
        self.assumed_haven_ETR_TWZ = 0.1

        # Average exchange rate over the year 2016, extracted from benchmark computations run on Stata
        # Source: European Central Bank
        self.USD_to_EUR_2016 = 1 / 1.1069031

        # self.multiplier_EU = 1.13381004333496
        # self.multiplier_world = 1.1330304145813

        # Gross growth rate of worldwide GDP in current EUR between 2016 and 2021
        # Extracted from benchmark computations run on Stata
        self.multiplier_2021 = 1.1330304145813

        # For rates of 0.2 or lower an alternative imputation is used to estimate the non-haven tax deficit of non-OECD
        # reporting countries; this argument allows to enable or disable this imputation
        self.alternative_imputation = alternative_imputation
        self.reference_rate_for_alternative_imputation = 0.25

        # The list of countries whose tax deficit is partly collected by EU countries in the intermediary scenario
        self.country_list_intermediary_scenario = [
            &#39;USA&#39;,
            &#39;AUS&#39;,
            &#39;CAN&#39;,
            &#39;CHL&#39;,
            &#39;MEX&#39;,
            &#39;NOR&#39;,
            &#39;BMU&#39;,
            &#39;BRA&#39;,
            &#39;CHN&#39;,
            &#39;IND&#39;,
            &#39;SGP&#39;,
            &#39;ZAF&#39;,
            &#39;IDN&#39;,
            &#39;JPN&#39;
        ]

        # This boolean indicates whether or not to apply substance-based carve-outs
        self.carve_outs = carve_outs

        # In case we want to simulate substance-based carve-outs, a few additional steps are required
        if carve_outs:

            # We first check whether all the required parameters were provided
            if carve_out_rate is None or depreciation_only is None or exclude_inventories is None:

                raise Exception(
                    &#39;If you want to simulate substance-based carve-outs, you need to indicate all the parameters.&#39;
                )

            self.carve_out_rate = carve_out_rate
            self.depreciation_only = depreciation_only
            self.exclude_inventories = exclude_inventories
            self.payroll_premium = payroll_premium

            # This corresponds to the OECD Secretariat&#39;s simulations in its Economic Impact Assessment (Oct. 2020):
            # inventories are excluded from tangible assets and only depreciation expenses can be partly deducted
            if depreciation_only and exclude_inventories:
                self.assets_multiplier = 0.1 * (1 - 0.24)

            # Here, we only account for depreciation expenses but do not exclude inventories
            elif depreciation_only and not exclude_inventories:
                self.assets_multiplier = 0.1

            # In this case, we take the full value of tangible assets to form the tangible assets component of substan-
            # ce-based carve-outs, while excluding inventories
            elif not depreciation_only and exclude_inventories:
                self.assets_multiplier = (1 - 0.24)

            # Benchmark case, where we take the full value of tangible assets without adjusting for inventories
            else:
                self.assets_multiplier = 1

        else:
            self.carve_out_rate = None
            self.depreciation_only = None
            self.exclude_inventories = None

    def load_clean_data(
        self,
        path_to_oecd=path_to_oecd,
        path_to_twz=path_to_twz,
        path_to_twz_domestic=path_to_twz_domestic,
        path_to_twz_CIT=path_to_twz_CIT,
        path_to_preprocessed_mean_wages=path_to_preprocessed_mean_wages,
        path_to_statutory_rates=path_to_statutory_rates,
        inplace=True
    ):
        &#34;&#34;&#34;
        This method allows to load and clean data from 6 different sources:

        - the &#34;oecd.csv&#34; file which was extracted from the OECD&#39;s aggregated and anonymized country-by-country repor-
        ting, considering only the positive profit sample. Figures are in 2016 USD;

        - the &#34;twz.csv&#34; file which was extracted from the Table C4 of the TWZ 2019 online appendix. It presents, for
        a number of countries, the amounts of profits shifted to tax havens that are re-allocated to them on an ultima-
        te ownership basis. Figures are in 2016 USD million;

        - the &#34;twz_domestic.csv&#34; file, taken from the outputs of benchmark computations run on Stata. It presents for
        each country the amount of corporate profits registered locally by domestic MNEs and the effective tax rate to
        which they are subject. Figures are in 2016 USD billion;

        - the &#34;twz_CIT.csv&#34; file, extracted from Table U1 of the TWZ 2019 online appendix. It presents the corporate in-
        come tax revenue of each country in 2016 USD billion;

        - the &#34;preprocessed_mean_wages.csv&#34; file, taken from the outputs of substance-based carve-outs run on Stata. For
        each partner jurisdiction in the OECD&#39;s country-by-country data, it provides either a measure or an approxima-
        tion of the local mean annual earnings in 2016 in current USD. It is built upon ILO data, more details being
        provided in the methodological section of the Note n°1 of the Observatory on substance-based carve-outs;

        - the &#34;statutory_rates.csv&#34; file that provides, for a number of partner jurisdictions, their 2016 statutory cor-
        porate income tax rates.

        Default paths are used to let the simulator run via the app.py file. If you wish to use the tax_deficit_calcula-
        tor package in another context, you can save the data locally and give the method paths to the data files. The
        possibility to load the files from an online host instead will soon be implemented.
        &#34;&#34;&#34;
        try:

            # We try to read the files from the provided paths
            oecd = pd.read_csv(path_to_oecd)
            twz = pd.read_csv(path_to_twz, delimiter=&#39;;&#39;)
            twz_domestic = pd.read_csv(path_to_twz_domestic, delimiter=&#39;;&#39;)
            twz_CIT = pd.read_csv(path_to_twz_CIT, delimiter=&#39;;&#39;)
            preprocessed_mean_wages = pd.read_csv(path_to_preprocessed_mean_wages, delimiter=&#39;;&#39;)
            statutory_rates = pd.read_csv(path_to_statutory_rates, delimiter=&#39;;&#39;)

        except FileNotFoundError:

            # If at least one of the files is not found
            raise Exception(&#39;Are you sure these are the right paths for the source files?&#39;)

        # --- Cleaning the OECD data

        # We drop a few irrelevant columns from country-by-country data
        oecd.drop(
            columns=[&#39;PAN&#39;, &#39;Grouping&#39;, &#39;Flag Codes&#39;, &#39;Flags&#39;, &#39;YEA&#39;, &#39;Year&#39;],
            inplace=True
        )

        # We reshape the DataFrame from a long to a wide dataset
        oecd = oecd.pivot(
            index=[&#39;COU&#39;, &#39;Ultimate Parent Jurisdiction&#39;, &#39;JUR&#39;, &#39;Partner Jurisdiction&#39;],
            columns=&#39;Variable&#39;,
            values=&#39;Value&#39;
        ).reset_index()

        # We rename some columns to match the code that has been written before modifying how OECD data are loaded
        oecd.rename(
            columns={
                &#39;COU&#39;: &#39;Parent jurisdiction (alpha-3 code)&#39;,
                &#39;Ultimate Parent Jurisdiction&#39;: &#39;Parent jurisdiction (whitespaces cleaned)&#39;,
                &#39;JUR&#39;: &#39;Partner jurisdiction (alpha-3 code)&#39;,
                &#39;Partner Jurisdiction&#39;: &#39;Partner jurisdiction (whitespaces cleaned)&#39;
            },
            inplace=True
        )

        # Thanks to a function defined in utils.py, we rename the &#34;Foreign Jurisdictions Total&#34; field for all countries
        # that only report a domestic / foreign breakdown in their CbCR
        oecd[&#39;Partner jurisdiction (whitespaces cleaned)&#39;] = oecd.apply(rename_partner_jurisdictions, axis=1)

        # We eliminate stateless entities and the &#34;Foreign Jurisdictions Total&#34; filds
        oecd = oecd[
            ~oecd[&#39;Partner jurisdiction (whitespaces cleaned)&#39;].isin([&#39;Foreign Jurisdictions Total&#39;, &#39;Stateless&#39;])
        ].copy()

        # We replace missing &#34;Income Tax Paid&#34; values by the corresponding &#34;Income Tax Accrued&#34; values
        # (Some missing values remain even after this edit)
        oecd[&#39;Income Tax Paid (on Cash Basis)&#39;] = oecd.apply(
            (
                lambda row: row[&#39;Income Tax Paid (on Cash Basis)&#39;]
                if not np.isnan(row[&#39;Income Tax Paid (on Cash Basis)&#39;])
                else row[&#39;Income Tax Accrued - Current Year&#39;]
            ),
            axis=1
        )

        # We clean the statutory corporate income tax rate dataset
        statutory_rates[&#39;statrate&#39;] = statutory_rates[&#39;statrate&#39;].map(
            lambda x: x.replace(&#39;,&#39;, &#39;.&#39;) if isinstance(x, str) else x
        ).astype(float)

        # And we merge it with country-by-country data, on partner jurisdiction alpha-3 codes
        oecd = oecd.merge(
            statutory_rates,
            how=&#39;left&#39;,
            left_on=&#39;Partner jurisdiction (alpha-3 code)&#39;, right_on=&#39;partner&#39;
        )

        oecd.drop(columns=[&#39;partner&#39;], inplace=True)

        # We impute missing &#34;Income Tax Paid&#34; values assuming that pre-tax profits are taxed at the local statutory rate
        oecd[&#39;Income Tax Paid (on Cash Basis)&#39;] = oecd.apply(
            (
                lambda row: row[&#39;Income Tax Paid (on Cash Basis)&#39;]
                if not np.isnan(row[&#39;Income Tax Paid (on Cash Basis)&#39;])
                else row[&#39;Profit (Loss) before Income Tax&#39;] * row[&#39;statrate&#39;]
            ),
            axis=1
        )

        oecd.drop(columns=[&#39;statrate&#39;], inplace=True)

        # ETR computation (using tax paid as the numerator)
        oecd[&#39;ETR&#39;] = oecd[&#39;Income Tax Paid (on Cash Basis)&#39;] / oecd[&#39;Profit (Loss) before Income Tax&#39;]
        oecd[&#39;ETR&#39;] = oecd[&#39;ETR&#39;].map(lambda x: 0 if x &lt; 0 else x)

        # Adding an indicator variable for domestic profits (rows with the same parent and partner jurisdiction)
        oecd[&#39;Is domestic?&#39;] = oecd.apply(
            lambda row: row[&#39;Parent jurisdiction (alpha-3 code)&#39;] == row[&#39;Partner jurisdiction (alpha-3 code)&#39;],
            axis=1
        ) * 1

        # We add an indicator variable that takes value 1 if and only if the partner is a tax haven
        oecd[&#39;Is partner jurisdiction a tax haven?&#39;] = oecd[&#39;Partner jurisdiction (alpha-3 code)&#39;].isin(
            tax_haven_country_codes
        ) * 1

        # Adding another indicator variable that takes value 1 if and only if the partner is not a tax haven
        oecd[&#39;Is partner jurisdiction a non-haven?&#39;] = 1 - oecd[&#39;Is partner jurisdiction a tax haven?&#39;]

        # This indicator variable is used specifically for the simulation of carve-outs; it takes value 1 if and only if
        # the partner jurisdiction is not the parent jurisdiction, not a tax haven and not a regional aggregate
        oecd[&#39;Is partner jurisdiction a non-haven? - CO&#39;] = oecd.apply(
            (
                lambda row: 0
                if (
                    row[&#39;Parent jurisdiction (alpha-3 code)&#39;] in COUNTRIES_WITH_MINIMUM_REPORTING
                    and row[&#39;Partner jurisdiction (alpha-3 code)&#39;] == &#39;FJT&#39;
                ) or (
                    row[&#39;Parent jurisdiction (alpha-3 code)&#39;] in COUNTRIES_WITH_CONTINENTAL_REPORTING
                    and row[&#39;Partner jurisdiction (alpha-3 code)&#39;] in [&#39;GRPS&#39;, &#39;AFRIC&#39;, &#39;AMER&#39;, &#39;ASIAT&#39;, &#39;EUROP&#39;]
                ) or (
                    row[&#39;Is domestic?&#39;] == 1
                )
                else row[&#39;Is partner jurisdiction a non-haven?&#39;]
            ),
            axis=1
        )

        # This indicator variable, used specifically for the simulation of carve-outs, takes value 1 if and only if the
        # partner is a regional aggregate
        oecd[&#39;Is partner jurisdiction an aggregate partner? - CO&#39;] = np.logical_and(
            oecd[&#39;Is domestic?&#39;] == 0,
            np.logical_and(
                oecd[&#39;Is partner jurisdiction a non-haven? - CO&#39;] == 0,
                oecd[&#39;Is partner jurisdiction a tax haven?&#39;] == 0
            )
        ) * 1

        # Thanks to a small function imported from utils.py, we manage the slightly problematic overlap between the
        # various indicator variables (&#34;Is domestic?&#34; sort of gets the priority over the others)
        oecd[&#39;Is partner jurisdiction a tax haven?&#39;] = oecd.apply(
            lambda row: manage_overlap_with_domestic(row, &#39;haven&#39;),
            axis=1
        )

        oecd[&#39;Is partner jurisdiction a non-haven?&#39;] = oecd.apply(
            lambda row: manage_overlap_with_domestic(row, &#39;non-haven&#39;),
            axis=1
        )

        # We need some more work on the data if we want to simulate substance-based carve-outs
        if self.carve_outs:

            # We merge earnings data with country-by-country data on partner jurisdiction codes
            oecd = oecd.merge(
                preprocessed_mean_wages[[&#39;partner2&#39;, &#39;earn&#39;]],
                how=&#39;left&#39;,
                left_on=&#39;Partner jurisdiction (alpha-3 code)&#39;, right_on=&#39;partner2&#39;
            )

            oecd.drop(columns=[&#39;partner2&#39;], inplace=True)

            oecd.rename(
                columns={
                    &#39;earn&#39;: &#39;ANNUAL_VALUE&#39;
                },
                inplace=True
            )

            # We clean the mean annual earnings column
            oecd[&#39;ANNUAL_VALUE&#39;] = oecd[&#39;ANNUAL_VALUE&#39;].map(
                lambda x: x.replace(&#39;,&#39;, &#39;.&#39;) if isinstance(x, str) else x
            ).astype(float)

            # We deduce the payroll proxy from the number of employees and from mean annual earnings
            oecd[&#39;PAYROLL&#39;] = oecd[&#39;Number of Employees&#39;] * oecd[&#39;ANNUAL_VALUE&#39;] * (1 + self.payroll_premium / 100)

            # We compute substance-based carve-outs from both payroll and tangible assets
            oecd[&#39;CARVE_OUT&#39;] = self.carve_out_rate * (
                oecd[&#39;PAYROLL&#39;] + oecd[&#39;Tangible Assets other than Cash and Cash Equivalents&#39;] * self.assets_multiplier
            )

            # This column will contain slightly modified carve-outs, carve-outs being replaced by pre-tax profits
            # wherever the former exceeds the latter
            oecd[&#39;CARVE_OUT_TEMP&#39;] = oecd.apply(
                (
                    lambda row: row[&#39;CARVE_OUT&#39;] if row[&#39;Profit (Loss) before Income Tax&#39;] &gt; row[&#39;CARVE_OUT&#39;]
                    or np.isnan(row[&#39;CARVE_OUT&#39;])
                    else row[&#39;Profit (Loss) before Income Tax&#39;]
                ),
                axis=1
            )

            # We exclude rows with missing carve-out values in a temporary DataFrame
            oecd_temp = oecd[
                ~np.logical_or(
                    oecd[&#39;PAYROLL&#39;].isnull(),
                    oecd[&#39;Tangible Assets other than Cash and Cash Equivalents&#39;].isnull()
                )
            ].copy()

            # We compute the average reduction in non-haven pre-tax profits due to carve-outs
            self.avg_carve_out_impact_non_haven = (
                oecd_temp[
                    oecd_temp[&#39;Is partner jurisdiction a non-haven? - CO&#39;] == 1
                ][&#39;CARVE_OUT_TEMP&#39;].sum() /
                oecd_temp[
                    oecd_temp[&#39;Is partner jurisdiction a non-haven? - CO&#39;] == 1
                ][&#39;Profit (Loss) before Income Tax&#39;].sum()
            )

            # We do the same for pre-tax profits booked in tax havens, domestically and in aggregate partners
            self.avg_carve_out_impact_tax_haven = (
                oecd_temp[oecd_temp[&#39;Is partner jurisdiction a tax haven?&#39;] == 1][&#39;CARVE_OUT_TEMP&#39;].sum() /
                oecd_temp[
                    oecd_temp[&#39;Is partner jurisdiction a tax haven?&#39;] == 1
                ][&#39;Profit (Loss) before Income Tax&#39;].sum()
            )
            self.avg_carve_out_impact_domestic = (
                oecd_temp[oecd_temp[&#39;Is domestic?&#39;] == 1][&#39;CARVE_OUT_TEMP&#39;].sum() /
                oecd_temp[oecd_temp[&#39;Is domestic?&#39;] == 1][&#39;Profit (Loss) before Income Tax&#39;].sum()
            )
            self.avg_carve_out_impact_aggregate = (
                oecd_temp[
                    oecd_temp[&#39;Is partner jurisdiction an aggregate partner? - CO&#39;] == 1
                ][&#39;CARVE_OUT_TEMP&#39;].sum() /
                oecd_temp[
                    oecd_temp[&#39;Is partner jurisdiction an aggregate partner? - CO&#39;] == 1
                ][&#39;Profit (Loss) before Income Tax&#39;].sum()
            )

            # We impute missing carve-out values based on these average reductions in pre-tax profits
            oecd[&#39;CARVE_OUT&#39;] = oecd.apply(
                lambda row: impute_missing_carve_out_values(
                    row,
                    avg_carve_out_impact_domestic=self.avg_carve_out_impact_domestic,
                    avg_carve_out_impact_tax_haven=self.avg_carve_out_impact_tax_haven,
                    avg_carve_out_impact_non_haven=self.avg_carve_out_impact_non_haven,
                    avg_carve_out_impact_aggregate=self.avg_carve_out_impact_aggregate
                ),
                axis=1
            )

            # Some missing values remain whenever profits before tax are missing
            oecd = oecd[~oecd[&#39;CARVE_OUT&#39;].isnull()].copy()

            # We remove substance-based carve-outs from pre-tax profits
            oecd[&#39;Profit (Loss) before Income Tax&#39;] = oecd.apply(
                (
                    lambda row: row[&#39;Profit (Loss) before Income Tax&#39;] - row[&#39;CARVE_OUT&#39;]
                    if row[&#39;Profit (Loss) before Income Tax&#39;] - row[&#39;CARVE_OUT&#39;] &gt;= 0
                    else 0
                ),
                axis=1
            )

        # --- Cleaning the TWZ tax haven profits data

        # Adding an indicator variable for OECD reporting - We do not consider the Swedish CbCR
        twz[&#39;Is parent in OECD data?&#39;] = twz[&#39;Alpha-3 country code&#39;].map(
            lambda x: x in oecd[&#39;Parent jurisdiction (alpha-3 code)&#39;].unique() if x != &#39;SWE&#39; else False
        ) * 1

        # We reformat numeric columns - Resulting figures are expressed in 2016 USD
        for column_name in [&#39;Profits in all tax havens&#39;, &#39;Profits in all tax havens (positive only)&#39;]:
            twz[column_name] = twz[column_name].map(lambda x: x.replace(&#39;,&#39;, &#39;.&#39;))
            twz[column_name] = twz[column_name].astype(float) * 1000000

            if self.carve_outs:
                # If we want to simulate carve-outs, we need to downgrade TWZ tax haven profits by the average reduction
                # due to carve-outs that is observed for tax haven profits in the OECD data
                twz[column_name] *= (1 - self.avg_carve_out_impact_tax_haven)
            else:
                continue

        # We filter out countries with 0 profits in tax havens
        twz = twz[twz[&#39;Profits in all tax havens (positive only)&#39;] &gt; 0].copy()

        # --- Cleaning the TWZ domestic profits data

        # Reformatting the profits column - Resulting figures are expressed in 2016 USD
        twz_domestic[&#39;Domestic profits&#39;] = twz_domestic[&#39;Domestic profits&#39;]\
            .map(lambda x: x.replace(&#39;,&#39;, &#39;.&#39;))\
            .astype(float) * 1000000000

        # Reformatting the ETR column
        twz_domestic[&#39;Domestic ETR&#39;] = twz_domestic[&#39;Domestic ETR&#39;].map(lambda x: x.replace(&#39;,&#39;, &#39;.&#39;)).astype(float)

        if self.carve_outs:
            # If we want to simulate carve-outs, we need to downgrade TWZ domestic profits by the average reduction due
            # to carve-outs that is observed for domestic profits in the OECD data
            twz_domestic[&#39;Domestic profits&#39;] *= (1 - self.avg_carve_out_impact_domestic)

        # --- Cleaning the TWZ CIT revenue data

        # Reformatting the CIT revenue column - Resulting figures are expressed in 2016 USD
        twz_CIT[&#39;CIT revenue&#39;] = twz_CIT[&#39;CIT revenue&#39;]\
            .map(lambda x: x.replace(&#39;,&#39;, &#39;.&#39;))\
            .astype(float) * 1000000000

        if inplace:
            self.oecd = oecd.copy()
            self.twz = twz.copy()
            self.twz_domestic = twz_domestic.copy()
            self.twz_CIT = twz_CIT.copy()
            self.mean_wages = preprocessed_mean_wages.copy()

        else:

            if self.carve_outs:
                return oecd.copy(), twz.copy(), twz_domestic.copy(), twz_CIT.copy(), preprocessed_mean_wages.copy()

            else:
                return oecd.copy(), twz.copy(), twz_domestic.copy(), twz_CIT.copy()

    def get_non_haven_imputation_ratio(self, minimum_ETR):
        &#34;&#34;&#34;
        For non-OECD reporting countries, we base our estimates on data compiled by Tørsløv, Wier and Zucman (2019).
        These allow to compute domestic and tax-haven-based tax deficit of these countries. We extrapolate the non-haven
        tax deficit of these countries from the tax-haven one.

        We impute the tax deficit in non-haven jurisdictions by estimating the ratio of tax deficits in non-tax havens
        to tax-havens for the EU non-tax haven parent countries in the CbCR data. We assume a 20% ETR in non-tax havens
        and a 10% ETR in tax havens (these rates are defined in two dedicated attributes in the instantiation function).

        This function allows to compute this ratio following the (A2) formula of Appendix A.

        The methodology is described in more details in the Appendix A of the report.
        &#34;&#34;&#34;

        # We need to have previously loaded and cleaned the OECD data
        if self.oecd is None:
            raise Exception(&#39;You first need to load clean data with the dedicated method and inplace=True.&#39;)

        # With a minimum ETR of 10%, the formula cannot be applied (division by 0), hence this case disjunction
        if minimum_ETR &gt; 0.1:
            oecd = self.oecd.copy()

            # In the computation of the imputation ratio, we only focus on:
            # - EU-27 parent countries
            mask_eu = oecd[&#39;Parent jurisdiction (alpha-3 code)&#39;].isin(eu_27_country_codes)
            # - That are not tax havens
            mask_non_haven = ~oecd[&#39;Parent jurisdiction (alpha-3 code)&#39;].isin(tax_haven_country_codes)
            # - And report a detailed country by country breakdown in their CbCR
            mask_minimum_reporting_countries = ~oecd[&#39;Parent jurisdiction (alpha-3 code)&#39;].isin(
                COUNTRIES_WITH_MINIMUM_REPORTING + COUNTRIES_WITH_CONTINENTAL_REPORTING
            )

            # We combine the boolean indexing masks
            mask = np.logical_and(mask_eu, mask_non_haven)
            mask = np.logical_and(mask, mask_minimum_reporting_countries)

            # And convert booleans into 0 / 1 integers
            mask = mask * 1

            # We compute the profits registered by retained countries in non-haven countries
            # (excluding domestic profits, cf. the earlier use of the manage_overlap_with_domestic function)
            foreign_non_haven_profits = (
                (
                    mask * oecd[&#39;Is partner jurisdiction a non-haven?&#39;]
                ) * oecd[&#39;Profit (Loss) before Income Tax&#39;]
            ).sum()

            # We compute the profits registered by retained countries in tax havens
            # (excluding domestic profits, cf. the earlier use of the manage_overlap_with_domestic function)
            foreign_haven_profits = (
                (
                    mask * oecd[&#39;Is partner jurisdiction a tax haven?&#39;]
                ) * oecd[&#39;Profit (Loss) before Income Tax&#39;]
            ).sum()

            # We apply the formula and compute the imputation ratio
            imputation_ratio_non_haven = (
                (
                    # If the minimum ETR is below the rate assumed to be applied on non-haven profits, there is no tax
                    # deficit to collect from these profits, which is why we have this max(..., 0)
                    max(minimum_ETR - self.assumed_non_haven_ETR_TWZ, 0) * foreign_non_haven_profits
                ) /
                ((minimum_ETR - self.assumed_haven_ETR_TWZ) * foreign_haven_profits)
            )

        # We manage the case where the minimum ETR is of 10% and the formula cannot be applied
        elif minimum_ETR == 0.1:

            # As long as tax haven profits are assumed to be taxed at a rate of 10%, the value that we set here has no
            # effect (it will be multiplied to 0 tax-haven-based tax deficits) but to remain consistent with higher
            # values of the minimum ETR, we impute 0

            imputation_ratio_non_haven = 0

        else:
            # We do not yet manage effective tax rates below 10%
            raise Exception(&#39;Unexpected minimum ETR entered (strictly below 0.1).&#39;)

        return imputation_ratio_non_haven

    def get_alternative_non_haven_factor(self, minimum_ETR):
        &#34;&#34;&#34;
        Looking at the formula (A2) of Appendix A and at the previous method, we see that for a 15% tax rate, this impu-
        tation would result in no tax deficit to be collected from non-tax haven jurisdictions. Thus, we correct for
        this underestimation by computing the ratio of the tax deficit that can be collected in non-tax havens at a 15%
        and a 25% rate for OECD-reporting countries.

        This class method allows to compute this alternative imputation ratio.

        The methodology is described in more details in the Appendix A of the report.
        &#34;&#34;&#34;

        # We need to have previously loaded and cleaned the OECD data
        if self.oecd is None:
            raise Exception(&#39;You first need to load clean data with the dedicated method and inplace=True.&#39;)

        # This method is only useful if the previous one yields a ratio of 0, i.e. if the minimum ETR is of 20% or less
        if minimum_ETR &gt; 0.2:
            raise Exception(&#39;These computations are only used when the minimum ETR considered is 0.2 or less.&#39;)

        # We use the get_stratified_oecd_data to compute the non-haven tax deficit of OECD-reporting countries
        oecd_stratified = self.get_stratified_oecd_data(
            minimum_ETR=self.reference_rate_for_alternative_imputation
        )

        # We exclude countries whose CbCR breakdown does not allow to distinguish tax-haven and non-haven profits
        df_restricted = oecd_stratified[
            ~oecd_stratified[&#39;Parent jurisdiction (alpha-3 code)&#39;].isin(
                COUNTRIES_WITH_CONTINENTAL_REPORTING + COUNTRIES_WITH_MINIMUM_REPORTING
            )
        ].copy()

        # The denominator is the total non-haven tax deficit of relevant countries at the reference minimum ETR
        denominator = df_restricted[&#39;tax_deficit_x_non_haven&#39;].sum()

        # We follow the same process, running computations at the minimum ETR this time
        oecd_stratified = self.get_stratified_oecd_data(minimum_ETR=minimum_ETR)

        # We exclude countries whose CbCR breakdown does not allow to distinguish tax-haven and non-haven profits
        df_restricted = oecd_stratified[
            ~oecd_stratified[&#39;Parent jurisdiction (alpha-3 code)&#39;].isin(
                COUNTRIES_WITH_CONTINENTAL_REPORTING + COUNTRIES_WITH_MINIMUM_REPORTING
            )
        ].copy()

        # The numerator is the total non-haven tax deficit of relevant countries at the selected minimum ETR
        numerator = df_restricted[&#39;tax_deficit_x_non_haven&#39;].sum()

        return numerator / denominator

    def get_stratified_oecd_data(self, minimum_ETR=0.25):
        &#34;&#34;&#34;
        This method constitutes a first step in the computation of each country&#39;s collectible tax deficit in the multi-
        lateral agreement scenario.

        Taking the minimum effective tax rate as input and based on OECD data, this function outputs a DataFrame that
        displays, for each OECD-reporting parent country, the tax deficit that could be collected from the domestic,
        tax haven and non-haven profits of multinationals headquartered in this country.

        The output is in 2016 USD, like the raw OECD data.
        &#34;&#34;&#34;

        # We need to have previously loaded and cleaned the OECD data
        if self.oecd is None:
            raise Exception(&#39;You first need to load clean data with the dedicated method and inplace=True.&#39;)

        oecd = self.oecd.copy()

        # We only profits taxed at an effective tax rate above the minimum ETR
        oecd = oecd[oecd[&#39;ETR&#39;] &lt; minimum_ETR].copy()

        # We compute the ETR differential for all low-taxed profits
        oecd[&#39;ETR_differential&#39;] = oecd[&#39;ETR&#39;].map(lambda x: minimum_ETR - x)

        # And deduce the tax deficit generated by each Parent / Partner jurisidiction pair
        oecd[&#39;tax_deficit&#39;] = oecd[&#39;ETR_differential&#39;] * oecd[&#39;Profit (Loss) before Income Tax&#39;]

        # Using the aforementioned indicator variables allows to breakdown this tax deficit
        oecd[&#39;tax_deficit_x_domestic&#39;] = oecd[&#39;tax_deficit&#39;] * oecd[&#39;Is domestic?&#39;]
        oecd[&#39;tax_deficit_x_tax_haven&#39;] = oecd[&#39;tax_deficit&#39;] * oecd[&#39;Is partner jurisdiction a tax haven?&#39;]
        oecd[&#39;tax_deficit_x_non_haven&#39;] = oecd[&#39;tax_deficit&#39;] * oecd[&#39;Is partner jurisdiction a non-haven?&#39;]

        # We group the table by Parent jurisdiction such that for, say, France, the table displays the total domestic,
        # tax-haven and non-haven tax deficit generated by French multinationals
        oecd_stratified = oecd[
            [
                &#39;Parent jurisdiction (whitespaces cleaned)&#39;,
                &#39;Parent jurisdiction (alpha-3 code)&#39;,
                &#39;tax_deficit&#39;,
                &#39;tax_deficit_x_domestic&#39;,
                &#39;tax_deficit_x_tax_haven&#39;,
                &#39;tax_deficit_x_non_haven&#39;
            ]
        ].groupby(
            &#39;Parent jurisdiction (whitespaces cleaned)&#39;
        ).agg(
            {
                &#39;Parent jurisdiction (alpha-3 code)&#39;: &#39;first&#39;,
                &#39;tax_deficit&#39;: &#39;sum&#39;,
                &#39;tax_deficit_x_domestic&#39;: &#39;sum&#39;,
                &#39;tax_deficit_x_tax_haven&#39;: &#39;sum&#39;,
                &#39;tax_deficit_x_non_haven&#39;: &#39;sum&#39;
            }
        ).copy()

        oecd_stratified.reset_index(inplace=True)

        return oecd_stratified.copy()

    def compute_all_tax_deficits(self, minimum_ETR=0.25, CbCR_reporting_countries_only=False):
        &#34;&#34;&#34;
        This method encapsulates most of the computations for the multilateral agreement scenario.

        Taking as input the minimum effective tax rate to apply and based on OECD and TWZ data, it outputs a DataFrame
        which presents, for each country in our sample (countries in OECD and/or TWZ data) the total tax deficit, as
        well as its breakdown into domestic, tax-haven and non-haven tax deficits.

        The output is in 2021 EUR after a currency conversion and the extrapolation from 2016 to 2021 figures.
        &#34;&#34;&#34;
        # We need to have previously loaded and cleaned the OECD and TWZ data
        if self.oecd is None or self.twz is None:
            raise Exception(&#39;You first need to load clean data with the dedicated method and inplace=True.&#39;)

        # We use the method defined above and will use its output as a base for the following computations
        oecd_stratified = self.get_stratified_oecd_data(minimum_ETR=minimum_ETR)

        twz = self.twz.copy()

        # From TWZ data on profits registered in tax havens and assuming that these are taxed at a given minimum ETR
        # (10% in the report, see the instantiation function for the definition of this attribute), we deduce the tax-
        # haven-based tax deficit of TWZ countries
        twz[&#39;tax_deficit_x_tax_haven_TWZ&#39;] = \
            twz[&#39;Profits in all tax havens (positive only)&#39;] * (minimum_ETR - self.assumed_haven_ETR_TWZ)

        # --- Managing countries in both OECD and TWZ data

        # We focus on parent countries which are in both the OECD and TWZ data
        # NB: recall that we do not consider the Swedish CbCR
        twz_in_oecd = twz[twz[&#39;Is parent in OECD data?&#39;].astype(bool)].copy()

        # We merge the two DataFrames on country codes
        merged_df = oecd_stratified.merge(
            twz_in_oecd[[&#39;Country&#39;, &#39;Alpha-3 country code&#39;, &#39;tax_deficit_x_tax_haven_TWZ&#39;]],
            how=&#39;left&#39;,
            left_on=&#39;Parent jurisdiction (alpha-3 code)&#39;,
            right_on=&#39;Alpha-3 country code&#39;
        ).drop(columns=[&#39;Country&#39;, &#39;Alpha-3 country code&#39;])

        # For countries that are in the OECD data but not in TWZ, we impute a tax-haven-based tax deficit from TWZ of 0
        merged_df[&#39;tax_deficit_x_tax_haven_TWZ&#39;] = merged_df[&#39;tax_deficit_x_tax_haven_TWZ&#39;].fillna(0)

        self.countries_replaced = []

        if self.carve_outs:

            calculator = TaxDeficitCalculator()
            calculator.load_clean_data()
            _ = calculator.compute_all_tax_deficits()

            countries_replaced = calculator.countries_replaced.copy()

            merged_df[&#39;tax_deficit_x_tax_haven_merged&#39;] = merged_df.apply(
                lambda row: self.combine_haven_tax_deficits(
                    row,
                    carve_outs=self.carve_outs,
                    countries_replaced=countries_replaced),
                axis=1
            )

        else:
            merged_df[&#39;tax_deficit_x_tax_haven_merged&#39;] = merged_df.apply(
                lambda row: self.combine_haven_tax_deficits(
                    row,
                    carve_outs=self.carve_outs
                ),
                axis=1
            )

        self.countries_replaced = merged_df[
            merged_df[&#39;tax_deficit_x_tax_haven_merged&#39;] == merged_df[&#39;tax_deficit_x_tax_haven_TWZ&#39;]
        ][&#39;Parent jurisdiction (alpha-3 code)&#39;].unique()

        merged_df.drop(columns=[&#39;tax_deficit_x_tax_haven&#39;, &#39;tax_deficit_x_tax_haven_TWZ&#39;], inplace=True)

        merged_df.rename(
            columns={
                &#39;tax_deficit_x_tax_haven_merged&#39;: &#39;tax_deficit_x_tax_haven&#39;
            },
            inplace=True
        )

        # Summing the tax-haven-based, non-haven and domestic tax deficits yields the total tax deficit of each country
        merged_df[&#39;tax_deficit&#39;] = merged_df[&#39;tax_deficit_x_tax_haven&#39;] \
            + merged_df[&#39;tax_deficit_x_domestic&#39;] \
            + merged_df[&#39;tax_deficit_x_non_haven&#39;]

        # --- Countries only in the TWZ data

        # We now focus on countries that are absent from the OECD data
        # NB: recall that we do not consider the Swedish CbCR
        twz_not_in_oecd = twz[~twz[&#39;Is parent in OECD data?&#39;].astype(bool)].copy()

        twz_not_in_oecd.drop(
            columns=[&#39;Profits in all tax havens&#39;, &#39;Profits in all tax havens (positive only)&#39;],
            inplace=True
        )

        # - Extrapolating the foreign non-haven tax deficit

        # We compute the imputation ratio with the method defined above
        imputation_ratio_non_haven = self.get_non_haven_imputation_ratio(minimum_ETR=minimum_ETR)

        # And we deduce the non-haven tax deficit of countries that are only found in TWZ data
        twz_not_in_oecd[&#39;tax_deficit_x_non_haven&#39;] = \
            twz_not_in_oecd[&#39;tax_deficit_x_tax_haven_TWZ&#39;] * imputation_ratio_non_haven

        # - Computing the domestic tax deficit

        # For countries that are only in TWZ data, we still need to compute their domestic tax deficit
        twz_domestic = self.twz_domestic.copy()

        # We only consider countries whose domestic ETR is stricly below the minimum ETR
        # (otherwise, there is no tax deficit to collect from domestic profits)
        twz_domestic = twz_domestic[twz_domestic[&#39;Domestic ETR&#39;] &lt; minimum_ETR].copy()

        # We compute the ETR differential
        twz_domestic[&#39;ETR_differential&#39;] = twz_domestic[&#39;Domestic ETR&#39;].map(lambda x: minimum_ETR - x)

        # And deduce the domestic tax deficit of each country
        twz_domestic[&#39;tax_deficit_x_domestic&#39;] = twz_domestic[&#39;ETR_differential&#39;] * twz_domestic[&#39;Domestic profits&#39;]

        # - Combining the different forms of tax deficit

        # We merge the two DataFrames to complement twz_not_in_oecd with domestic tax deficit results
        twz_not_in_oecd = twz_not_in_oecd.merge(
            twz_domestic[[&#39;Alpha-3 country code&#39;, &#39;tax_deficit_x_domestic&#39;]],
            how=&#39;left&#39;,
            on=&#39;Alpha-3 country code&#39;
        )

        # As we filtered out countries whose domestic ETR is stricly below the minimum ETR, some missing values
        # appear during the merge; we impute 0 for these as they do not have any domestic tax deficit to collect
        twz_not_in_oecd[&#39;tax_deficit_x_domestic&#39;] = twz_not_in_oecd[&#39;tax_deficit_x_domestic&#39;].fillna(0)

        # We deduce the total tax deficit for each country
        twz_not_in_oecd[&#39;tax_deficit&#39;] = twz_not_in_oecd[&#39;tax_deficit_x_tax_haven_TWZ&#39;] \
            + twz_not_in_oecd[&#39;tax_deficit_x_domestic&#39;] \
            + twz_not_in_oecd[&#39;tax_deficit_x_non_haven&#39;]

        # --- Merging the results of the two data sources

        # We need columns to match for the concatenation to operate smoothly
        twz_not_in_oecd.rename(
            columns={
                &#39;Country&#39;: &#39;Parent jurisdiction (whitespaces cleaned)&#39;,
                &#39;Alpha-3 country code&#39;: &#39;Parent jurisdiction (alpha-3 code)&#39;,
                &#39;tax_deficit_x_tax_haven_TWZ&#39;: &#39;tax_deficit_x_tax_haven&#39;
            },
            inplace=True
        )

        twz_not_in_oecd.drop(columns=[&#39;Is parent in OECD data?&#39;], inplace=True)

        # We exclude Sweden from the OECD-drawn results, as we do not consider its CbCR
        merged_df = merged_df[merged_df[&#39;Parent jurisdiction (alpha-3 code)&#39;] != &#39;SWE&#39;].copy()

        # We eventually concatenate the two DataFrames
        merged_df = pd.concat(
            [merged_df, twz_not_in_oecd],
            axis=0
        )

        # --- Extrapolations to 2021 EUR

        # We convert 2016 USD results in 2016 EUR and extraprolate them to 2021 EUR
        for column_name in merged_df.columns[2:]:
            merged_df[column_name] = merged_df[column_name] * self.USD_to_EUR_2016 * self.multiplier_2021

        # --- Managing the case where the minimum ETR is 20% or below for TWZ countries

        # As mentioned above and detailed in Appendix A, the imputation of the non-haven tax deficit of TWZ countries
        # follows a specific process whenever the chosen minimum ETR is of or below 20%
        if minimum_ETR &lt;= 0.2 and self.alternative_imputation:
            # We get the new multiplying factor from the method defined above
            multiplying_factor = self.get_alternative_non_haven_factor(minimum_ETR=minimum_ETR)

            # We compute all tax deficits at the reference rate (25% in the report)
            df = self.compute_all_tax_deficits(
                minimum_ETR=self.reference_rate_for_alternative_imputation
            )

            # We only consider countries that are absent from the OECD data, except Sweden as usual
            oecd_reporting_countries_but_SWE = self.oecd[
                self.oecd[&#39;Parent jurisdiction (alpha-3 code)&#39;] != &#39;SWE&#39;
            ][&#39;Parent jurisdiction (alpha-3 code)&#39;].unique()

            df = df[
                ~df[&#39;Parent jurisdiction (alpha-3 code)&#39;].isin(oecd_reporting_countries_but_SWE)
            ].copy()

            # For these countries, we multiply the non-haven tax deficit at the reference rate by the multiplying factor
            df[&#39;tax_deficit_x_non_haven_imputation&#39;] = df[&#39;tax_deficit_x_non_haven&#39;] * multiplying_factor

            # We save the results in a dictionary that will allow to map the DataFrame that we want to output in the end
            mapping = {}

            for _, row in df.iterrows():
                mapping[row[&#39;Parent jurisdiction (alpha-3 code)&#39;]] = row[&#39;tax_deficit_x_non_haven_imputation&#39;]

            # We create a new column in the to-be-output DataFrame which takes as value:
            # - the non-haven tax deficit estimated just above for TWZ countries
            # - 0 for OECD-reporting countries, which do not require this imputation
            merged_df[&#39;tax_deficit_x_non_haven_imputation&#39;] = merged_df[&#39;Parent jurisdiction (alpha-3 code)&#39;].map(
                lambda country_code: mapping.get(country_code, 0)
            )

            # We deduce the non-haven tax deficit of all countries
            merged_df[&#39;tax_deficit_x_non_haven&#39;] += merged_df[&#39;tax_deficit_x_non_haven_imputation&#39;]

            # And add this imputation also to the column that presents the total tax deficit of each country
            merged_df[&#39;tax_deficit&#39;] += merged_df[&#39;tax_deficit_x_non_haven_imputation&#39;]

            merged_df.drop(
                columns=[&#39;tax_deficit_x_non_haven_imputation&#39;],
                inplace=True
            )

        if CbCR_reporting_countries_only:
            merged_df = merged_df[
                merged_df[&#39;Parent jurisdiction (whitespaces cleaned)&#39;].isin(
                    self.oecd[&#39;Parent jurisdiction (whitespaces cleaned)&#39;].unique()
                )
            ].copy()

        return merged_df.reset_index(drop=True).copy()

    def combine_haven_tax_deficits(
        self,
        row,
        carve_outs=False,
        countries_replaced=None
    ):
        &#34;&#34;&#34;
        This function is used to compute the tax deficit of all in-sample headquarter countries in the multilateral im-
        plementation scenario.

        For parent countries that are in both the OECD and TWZ data, we have two different sources to compute their tax-
        haven-based tax deficit and we retain the highest of these two amounts.

        Besides, for parent countries in the OECD data that do not report a fully detailed country-by-country breakdown
        of the activity of their multinationals, we cannot distinguish their tax-haven and non-haven tax deficits. Quite
        arbitrarily in the Python code, we attribute everything to the non-haven tax deficit. In the Table A1 of the re-
        port, these specific cases are described with the &#34;Only foreign aggregate data&#34; column.
        &#34;&#34;&#34;
        if carve_outs and countries_replaced is None:
            raise Exception(
                &#39;Using this function under carve-outs requires to indicate a list of countries to replace.&#39;
            )

        if row[&#39;Parent jurisdiction (alpha-3 code)&#39;] not in (
            COUNTRIES_WITH_MINIMUM_REPORTING + COUNTRIES_WITH_CONTINENTAL_REPORTING
        ):
            if countries_replaced is None:

                if row[&#39;tax_deficit_x_tax_haven_TWZ&#39;] &gt; row[&#39;tax_deficit_x_tax_haven&#39;]:
                    self.countries_replaced.append(row[&#39;Parent jurisdiction (alpha-3 code)&#39;])
                    return row[&#39;tax_deficit_x_tax_haven_TWZ&#39;]

                else:
                    return row[&#39;tax_deficit_x_tax_haven&#39;]

            else:
                if (
                    row[&#39;tax_deficit_x_tax_haven_TWZ&#39;] &gt; row[&#39;tax_deficit_x_tax_haven&#39;]
                    and row[&#39;Parent jurisdiction (alpha-3 code)&#39;] in countries_replaced
                ):
                    self.countries_replaced.append(row[&#39;Parent jurisdiction (alpha-3 code)&#39;])
                    return row[&#39;tax_deficit_x_tax_haven_TWZ&#39;]

                else:
                    return row[&#39;tax_deficit_x_tax_haven&#39;]

        else:
            return 0

    def check_tax_deficit_computations(self, minimum_ETR=0.25):
        &#34;&#34;&#34;
        Taking the selected minimum ETR as input and relying on the compute_all_tax_deficits method defined above, this
        method outputs a DataFrame that can be compared with Table A1 of the report. For each country in OECD and/or TWZ
        data, it displays its total tax deficit and a breakdown into domestic, tax-haven-based and non-haven tax defi-
        cits. Figures are display in 2021 billion EUR.
        &#34;&#34;&#34;

        # We start from the output of the previously defined method
        df = self.compute_all_tax_deficits(minimum_ETR=minimum_ETR)

        # And convert numeric columns from 2021 EUR to 2021 billion EUR
        for column_name in df.columns[2:]:
            df[column_name] = df[column_name] / 10**9

        return df.copy()

    def get_total_tax_deficits(self, minimum_ETR=0.25):
        &#34;&#34;&#34;
        This method takes the selected minimum ETR as input and relies on the compute_all_tax_deficits, to output a Da-
        taFrame with (i) the total tax defict of each in-sample country in 2021 EUR and (ii) the sum of these tax defi-
        cits at the EU-27 and at the whole sample level. It can be considered as an intermediary step towards the fully
        formatted table displayed on the online simulator (section &#34;Multilateral implementation scenario&#34;).
        &#34;&#34;&#34;

        df = self.compute_all_tax_deficits(minimum_ETR=minimum_ETR)

        df = df[
            [&#39;Parent jurisdiction (whitespaces cleaned)&#39;, &#39;Parent jurisdiction (alpha-3 code)&#39;, &#39;tax_deficit&#39;]
        ]

        df.sort_values(
            by=&#39;Parent jurisdiction (whitespaces cleaned)&#39;,
            inplace=True
        )

        # We compute the sum of total tax deficits at the EU-27 level and for the whole sample
        total_eu = (df[&#39;Parent jurisdiction (alpha-3 code)&#39;].isin(eu_27_country_codes) * 1 * df[&#39;tax_deficit&#39;]).sum()
        total_whole_sample = df[&#39;tax_deficit&#39;].sum()

        # Possibly suboptimal process to add &#34;Total&#34; lines at the end of the DataFrame
        dict_df = df.to_dict()

        dict_df[df.columns[0]][len(df)] = &#39;Total - EU27&#39;
        dict_df[df.columns[1]][len(df)] = &#39;..&#39;
        dict_df[df.columns[2]][len(df)] = total_eu

        dict_df[df.columns[0]][len(df) + 1] = &#39;Total - Whole sample&#39;
        dict_df[df.columns[1]][len(df) + 1] = &#39;..&#39;
        dict_df[df.columns[2]][len(df) + 1] = total_whole_sample

        df = pd.DataFrame.from_dict(dict_df)

        return df.reset_index(drop=True)

    def check_appendix_A2(self):
        &#34;&#34;&#34;
        Relying on the get_total_tax_deficits method and on TWZ data on corporate income tax revenues, this method out-
        puts a DataFrame that can be compared with the first 4 columns of Table A2 in the report. For each in-sample
        country and at four different minimum ETRs (15%, 21%, 25% and 30% which are the four main cases considered in
        the report), the table presents estimated revenue gains as a percentage of currently corporate income taxes.
        &#34;&#34;&#34;

        # We need to have previously loaded and cleaned the TWZ data on corporate income tax revenues
        # (figures in the pre-loaded DataFrame are provided in 2016 USD)
        if self.twz_CIT is None:
            raise Exception(&#39;You first need to load clean data with the dedicated method and inplace=True.&#39;)

        # We compute total tax deficits, first at a 15% minimum ETR and in 2021 EUR
        df = self.get_total_tax_deficits(minimum_ETR=0.15)

        df.rename(columns={&#39;tax_deficit&#39;: &#39;tax_deficit_15&#39;}, inplace=True)

        # We merge the two DataFrames to combine information on collectible tax deficits and current CIT revenues
        merged_df = df.merge(
            self.twz_CIT,
            how=&#39;left&#39;,
            left_on=&#39;Parent jurisdiction (alpha-3 code)&#39;,
            right_on=&#39;Country (alpha-3 code)&#39;
        ).drop(columns=[&#39;Country&#39;, &#39;Country (alpha-3 code)&#39;])

        # We bring back the tax deficit estimated to 2016 USD (from 2021 EUR)
        merged_df[&#39;tax_deficit_15&#39;] /= (merged_df[&#39;CIT revenue&#39;] * self.multiplier_2021 * self.USD_to_EUR_2016 / 100)

        # For the 3 other rates considered in the output table
        for rate in [0.21, 0.25, 0.3]:
            # We compute total tax deficits at this rate
            df = self.get_total_tax_deficits(minimum_ETR=rate)

            # We add these results to the central DataFrame thanks to a merge operation
            merged_df = merged_df.merge(
                df,
                how=&#39;left&#39;,
                on=&#39;Parent jurisdiction (alpha-3 code)&#39;
            )

            # We impute the missing values produced by the merge
            merged_df[&#39;tax_deficit&#39;] = merged_df[&#39;tax_deficit&#39;].fillna(0)

            # We rename the newly-added tax deficit column
            merged_df.rename(
                columns={&#39;tax_deficit&#39;: f&#39;tax_deficit_{int(rate * 100)}&#39;},
                inplace=True
            )

            # And we bring it back to 2016 USD
            merged_df[f&#39;tax_deficit_{int(rate * 100)}&#39;] /= (
                merged_df[&#39;CIT revenue&#39;] * self.multiplier_2021 * self.USD_to_EUR_2016 / 100
            )

        # We want to also verify the EU-27 average and restrict the DataFrame to these countries
        eu_df = merged_df[merged_df[&#39;Parent jurisdiction (alpha-3 code)&#39;].isin(eu_27_country_codes)].copy()

        # This attribute stores the average EU-27 revenue gain estimate in % of current CIT revenues for each of the 4
        # minimum ETRs of interest (respectively 15.1%, 30.5%, 52.3% and 84.1% in the report)
        self.check = [
            (
                eu_df[f&#39;tax_deficit_{rate}&#39;] * eu_df[&#39;CIT revenue&#39;] / 100
            ).sum() / eu_df[&#39;CIT revenue&#39;].sum() for rate in [15, 21, 25, 30]
        ]

        # Coming back to the DataFrame with all in-sample countries, we only keep the relevant columns and output it
        merged_df = merged_df[
            [
                &#39;Parent jurisdiction (whitespaces cleaned)_x&#39;,
                &#39;tax_deficit_15&#39;, &#39;tax_deficit_21&#39;, &#39;tax_deficit_25&#39;, &#39;tax_deficit_30&#39;
            ]
        ].copy()

        # NB: in the current version of this method, the successive merges have a poor effect on the &#34;Total&#34; rows that
        # are included in the output of the get_total_tax_deficits method; this could easily be improved

        return merged_df.copy()

    def output_tax_deficits_formatted(self, minimum_ETR=0.25):
        &#34;&#34;&#34;
        This method is used in the &#34;app.py&#34; file, which underlies the Streamlit simulator. It is used to produce the
        table on the &#34;Multilateral implementation scenario&#34; page. It takes as input the selected minimum ETR and widely
        relies on the get_total_tax_deficits method defined above. It mostly consists in a series of formatting steps.
        &#34;&#34;&#34;

        # We build the unformatted results table thanks to the get_total_tax_deficits method
        df = self.get_total_tax_deficits(minimum_ETR=minimum_ETR)

        # We only want to include certain countries in the output table:
        # - all the EU-27 countries that are included in our sample (4 unfortunately missing for now)
        # - most of the OECD-reporting countries, excluding only Singapore and Bermuda

        # We first build the list of OECD-reporting countries, excluding Singapore and Bermuda
        oecd_reporting_countries = self.oecd[&#39;Parent jurisdiction (alpha-3 code)&#39;].unique()
        oecd_reporting_countries = [
            country_code for country_code in oecd_reporting_countries if country_code not in [&#39;SGP&#39;, &#39;BMU&#39;]
        ]

        # From this list, we build the relevant boolean indexing mask that corresponds to our filtering choice
        mask = np.logical_or(
            df[&#39;Parent jurisdiction (alpha-3 code)&#39;].isin(eu_27_country_codes),
            df[&#39;Parent jurisdiction (alpha-3 code)&#39;].isin(oecd_reporting_countries)
        )

        df = df[mask].copy()

        # We sort values by the name of the parent jurisdiction, in the alphabetical order
        df.sort_values(
            by=&#39;Parent jurisdiction (whitespaces cleaned)&#39;,
            inplace=True
        )

        df.reset_index(drop=True, inplace=True)

        # We convert 2021 EUR figures into 2021 million EUR ones
        df[&#39;tax_deficit&#39;] = df[&#39;tax_deficit&#39;] / 10**6

        # Again, the same possibly sub-optimal process to add the &#34;Total&#34; lines
        dict_df = df.to_dict()

        dict_df[df.columns[0]][len(df)] = &#39;Total - EU27&#39;
        dict_df[df.columns[1]][len(df)] = &#39;..&#39;
        dict_df[df.columns[2]][len(df)] = df[
            df[&#39;Parent jurisdiction (alpha-3 code)&#39;].isin(eu_27_country_codes)
        ][&#39;tax_deficit&#39;].sum()

        dict_df[df.columns[0]][len(df) + 1] = &#39;Total - Whole sample&#39;
        dict_df[df.columns[1]][len(df) + 1] = &#39;..&#39;
        dict_df[df.columns[2]][len(df) + 1] = df[&#39;tax_deficit&#39;].sum()

        df = pd.DataFrame.from_dict(dict_df)

        # We drop country codes
        df.drop(columns=[&#39;Parent jurisdiction (alpha-3 code)&#39;], inplace=True)

        # And we eventually reformat figures with a thousand separator and a 0-decimal rounding
        df[&#39;tax_deficit&#39;] = df[&#39;tax_deficit&#39;].map(&#39;{:,.0f}&#39;.format)

        # We rename columns
        df.rename(
            columns={
                &#39;Parent jurisdiction (whitespaces cleaned)&#39;: &#39;Headquarter country&#39;,
                &#39;tax_deficit&#39;: &#39;Collectible tax deficit (€m)&#39;
            },
            inplace=True
        )

        return df.copy()

    def compute_unilateral_scenario_gain(self, country, minimum_ETR=0.25):
        &#34;&#34;&#34;
        This method encapsulates most of the computations for the unilateral implementation scenario.

        It takes as input:

        - the name of the country assumed to unilaterally implement the tax deficit collection;

        - the minimum effective tax rate that it applies when collecting the full tax deficit of its multinationals and
        a part of the tax deficit of foreign multinationals, based on the location of their sales.

        The output of this method is a DataFrame organized as follows:

        - each row is a headquarter country whose tax deficit would be collected partly or entirely by the taxing coun-
        try (including the taxing country which collects 100% of the tax deficit of its multinationals);

        - there are two columns, with the name of the headquarter country considered and the tax deficit amount that
        could be collected from its multinationals by the taxing country.

        Figures are presented in 2021 EUR.

        Important disclaimer: for now, this method is not robust to variations in the country name, i.e. only country
        names as presented in the OECD CbCR data will generate a result. These are the country names that are proposed
        in the selectbox on the online simulator.

        The methogology behind these computations is described in much more details in Appendix B of the report.
        &#34;&#34;&#34;

        # We start from the total tax deficits of all countries which can be partly re-allocated to the taxing country
        tax_deficits = self.get_total_tax_deficits(minimum_ETR=minimum_ETR)

        # The OECD data provides the information of extra-group sales, needed to allocate foreign tax deficits
        oecd = self.oecd.copy()

        # We simply convert the name of the taxing country to the corresponding alpha-3 code
        taxing_country = country
        try:
            taxing_country_code = self.oecd[
                self.oecd[&#39;Parent jurisdiction (whitespaces cleaned)&#39;] == taxing_country
            ][&#39;Parent jurisdiction (alpha-3 code)&#39;].iloc[0]
        except:
            taxing_country_code = self.twz[
                self.twz[&#39;Country&#39;] == taxing_country
            ][&#39;Alpha-3 country code&#39;].iloc[0]

        # This list will store the allocation ratios (for each headquarter country, the share of its tax deficit that
        # can be collected by the taxing country) computed based on the location of extra-group sales
        attribution_ratios = []

        # We iterate over parent countries in the OECD data
        for country_code in tax_deficits[&#39;Parent jurisdiction (alpha-3 code)&#39;].values:

            # The taxing country collects 100% of the tax deficit of its own multinationals
            if country_code == taxing_country_code:
                attribution_ratios.append(1)

            # If the parent country is not the taxing country
            else:
                # We restrict the DataFrame to the CbCR of the considered parent country
                oecd_restricted = oecd[oecd[&#39;Parent jurisdiction (alpha-3 code)&#39;] == country_code].copy()

                # If the taxing country is not part of its partner jurisdictions, the attribution ratio is of 0
                if taxing_country_code not in oecd_restricted[&#39;Partner jurisdiction (alpha-3 code)&#39;].values:
                    attribution_ratios.append(0)

                else:
                    # We fetch extra-group sales registered in the taxing country
                    mask = (oecd_restricted[&#39;Partner jurisdiction (alpha-3 code)&#39;] == taxing_country_code)
                    sales_in_taxing_country = oecd_restricted[mask][&#39;Unrelated Party Revenues&#39;].iloc[0]

                    # We compute total extra-group sales
                    total_sales = oecd_restricted[&#39;Unrelated Party Revenues&#39;].sum()

                    # We append the resulting ratio to the list of attribution ratios
                    attribution_ratios.append(sales_in_taxing_country / total_sales)

        # We add this list to the DataFrame as a new column
        tax_deficits[&#39;Attribution ratios&#39;] = attribution_ratios

        # We deduce, for each headquarter country, the tax deficit that could be collected by the taxing country
        tax_deficits[f&#39;Collectible tax deficit for {taxing_country}&#39;] = \
            tax_deficits[&#39;tax_deficit&#39;] * tax_deficits[&#39;Attribution ratios&#39;]

        # We eliminate irrelevant columns
        tax_deficits.drop(
            columns=[
                &#39;Attribution ratios&#39;,
                &#39;tax_deficit&#39;,
                &#39;Parent jurisdiction (alpha-3 code)&#39;
            ],
            inplace=True
        )

        # We filter out rows for which the collectible tax deficit is 0
        tax_deficits = tax_deficits[tax_deficits[f&#39;Collectible tax deficit for {taxing_country}&#39;] &gt; 0].copy()

        # We sort values based on the resulting tax deficit, in descending order
        tax_deficits.sort_values(
            by=f&#39;Collectible tax deficit for {taxing_country}&#39;,
            ascending=False,
            inplace=True
        )

        # Because the OECD data only gather 26 headquarter countries, we need to make an assumption on the tax deficit
        # that could be collected from other parent countries, excluded from the 2016 version of the data

        # We therefore double the tax deficit collected from non-US foreign countries
        imputation = tax_deficits[
            ~tax_deficits[&#39;Parent jurisdiction (whitespaces cleaned)&#39;].isin([taxing_country, &#39;United States&#39;])
        ][f&#39;Collectible tax deficit for {taxing_country}&#39;].sum()

        # Except for Germany, for which we add back only half of the tax deficit collected from non-US foreign countries
        if taxing_country_code == &#39;DEU&#39;:
            imputation /= 2

        tax_deficits.reset_index(drop=True, inplace=True)

        # Again the same inelegant way of adding &#34;Total&#34; fields at the end of the DataFrame
        dict_df = tax_deficits.to_dict()

        dict_df[tax_deficits.columns[0]][len(tax_deficits)] = &#39;Others (imputation)&#39;
        dict_df[tax_deficits.columns[1]][len(tax_deficits)] = imputation

        dict_df[tax_deficits.columns[0]][len(tax_deficits) + 1] = &#39;Total&#39;
        dict_df[tax_deficits.columns[1]][len(tax_deficits) + 1] = (
            tax_deficits[tax_deficits.columns[1]].sum() + imputation
        )

        df = pd.DataFrame.from_dict(dict_df)

        return df.copy()

    def check_unilateral_scenario_gain_computations(self, minimum_ETR=0.25):
        &#34;&#34;&#34;
        Taking as input the selected minimum effective tax rate and relying on the compute_unilateral_scenario_gain,
        this method outputs a DataFrame that can be compared with the Table 3 of the report. For each country that is
        part of the EU-27 and/or included in the 2016 aggregated and anonymized CbCR data of the OECD, it shows the to-
        tal corporate tax revenue gain that could be drawn from the unilateral implementation of the tax deficit col-
        lection. It also provides a breakdown of this total between the tax deficit of the country&#39;s own multinationals,
        the amount that could be collected from US multinationals and revenues that could be collected from non-US ones.
        &#34;&#34;&#34;

        # We build the list of countries that we want to include in the output table
        country_list = self.get_total_tax_deficits()

        country_list = country_list[
            ~country_list[&#39;Parent jurisdiction (whitespaces cleaned)&#39;].isin([&#39;Total - EU27&#39;, &#39;Total - Whole sample&#39;])
        ].copy()

        country_list = list(country_list[&#39;Parent jurisdiction (whitespaces cleaned)&#39;].values)

        # We prepare the structure of the output first as a dictionary
        output = {
            &#39;Country&#39;: country_list,
            &#39;Own tax deficit&#39;: [],
            &#39;Collection of US tax deficit&#39;: [],
            &#39;Collection of non-US tax deficit&#39;: [],
            &#39;Imputation&#39;: [],
            &#39;Total&#39;: []
        }

        # We iterate over the list of relevant countries
        for country in country_list:

            # Using the method defined above, we output the table presenting the tax deficit that could be collected
            # from a unilateral implementation of the tax deficit collection by the considered country and its origin
            df = self.compute_unilateral_scenario_gain(
                country=country,
                minimum_ETR=minimum_ETR
            )

            column_name = f&#39;Collectible tax deficit for {country}&#39;

            if country in df[&#39;Parent jurisdiction (whitespaces cleaned)&#39;].unique():
                # We fetch the tax deficit that could be collected from the country&#39;s own multinationals
                output[&#39;Own tax deficit&#39;].append(
                    df[df[&#39;Parent jurisdiction (whitespaces cleaned)&#39;] == country][column_name].iloc[0]
                )

            else:
                output[&#39;Own tax deficit&#39;].append(0)

            # We fetch the tax deficit that could be collected from US multinationals
            if &#39;United States&#39; in df[&#39;Parent jurisdiction (whitespaces cleaned)&#39;].values:
                output[&#39;Collection of US tax deficit&#39;].append(
                    df[df[&#39;Parent jurisdiction (whitespaces cleaned)&#39;] == &#39;United States&#39;][column_name].iloc[0]
                )
            else:
                output[&#39;Collection of US tax deficit&#39;].append(0)

            # We fetch the tax deficit that was imputed following our methodology
            output[&#39;Imputation&#39;].append(
                df[df[&#39;Parent jurisdiction (whitespaces cleaned)&#39;] == &#39;Others (imputation)&#39;][column_name].iloc[0]
            )

            # We fetch the total tax deficit
            output[&#39;Total&#39;].append(
                df[df[&#39;Parent jurisdiction (whitespaces cleaned)&#39;] == &#39;Total&#39;][column_name].iloc[0]
            )

            # And finally, we sum the tax deficits collected from foreign non-US multinationals
            output[&#39;Collection of non-US tax deficit&#39;].append(
                df[
                    ~df[&#39;Parent jurisdiction (whitespaces cleaned)&#39;].isin(
                        [
                            country, &#39;United States&#39;, &#39;Total&#39;, &#39;Others (imputation)&#39;
                        ]
                    )
                ][column_name].sum()
            )

        # We convert the dictionary into a DataFrame
        df = pd.DataFrame.from_dict(output)

        # We sum the imputation and the tax deficit collected from foreign, non-US multinationals to obtain the uprated
        # figures that correspond to the &#34;Other foreign firms&#34; column of Table 3 in the report
        df[&#39;Collection of non-US tax deficit (uprated with imputation)&#39;] = \
            df[&#39;Imputation&#39;] + df[&#39;Collection of non-US tax deficit&#39;]

        # We convert the results from 2021 EUR into 2021 billion EUR
        for column_name in df.columns[1:]:
            df[column_name] /= 10**9

        return df.copy()

    def output_unilateral_scenario_gain_formatted(self, country, minimum_ETR=0.25):
        &#34;&#34;&#34;
        This method is used in the &#34;app.py&#34; file, which lies behind the Streamlit simulator. It allows to produce the
        table presented on the &#34;Unilateral implementation scenario&#34; page. It takes as input the selected minimum ETR and
        the name of the country assumed to unilaterally implement the tax deficit collection. Then, it widely relies on
        the compute_unilateral_scenario_gain method defined above and mostly consists in a series of formatting steps to
        make the table more readable and understandable.
        &#34;&#34;&#34;

        # We compute the gains from the unilateral implementation of the tax deficit collection for the taxing country
        df = self.compute_unilateral_scenario_gain(
            country=country,
            minimum_ETR=minimum_ETR
        )

        # We convert the numeric outputs into 2021 million EUR
        df[f&#39;Collectible tax deficit for {country}&#39;] = df[f&#39;Collectible tax deficit for {country}&#39;] / 10**6

        # We reformat figures with two decimals and a thousand separator
        df[f&#39;Collectible tax deficit for {country}&#39;] = \
            df[f&#39;Collectible tax deficit for {country}&#39;].map(&#39;{:,.2f}&#39;.format)

        # We rename columns in accordance
        df.rename(
            columns={
                f&#39;Collectible tax deficit for {country}&#39;: f&#39;Collectible tax deficit for {country} (€m)&#39;,
                &#39;Parent jurisdiction (whitespaces cleaned)&#39;: &#39;Headquarter country&#39;
            },
            inplace=True
        )

        return df.copy()

    def compute_intermediary_scenario_gain(self, minimum_ETR=0.25):
        &#34;&#34;&#34;
        This method encapsulates the computations used to estimate the corporate tax revenue gains of EU countries,
        should the European Union implement the tax deficit collection as a block. This corresponds therefore to the
        partial cooperation scenario described in the report.

        Taking as input the selected minimum effective tax rate, this method outputs a DataFrame that presents for each
        in-sample EU-27 country:

        - the corporate tax revenue gains that could be collected from its own multinationals (&#34;tax_deficit&#34; column);
        - the tax deficit that could be collected from foreign, non-EU multinationals (&#34;From foreign MNEs&#34; column);
        - and the resulting total corporate tax revenue gain.

        All figures are output in 2021 million EUR.

        The three lines at the end of the DataFrame are a bit specific. Some OECD-reporting contries do not provide a
        perfectly detailed country-by-country report and for these, the &#34;Other Europe&#34; and &#34;Europe&#34; fields are assumed
        to be related to EU countries and are included in the total collectible tax deficit. The final line presents
        this total.

        The methogology behind these computations is described in much more details in Appendix C of the report.
        &#34;&#34;&#34;

        # We start by computing the total tax deficits of all in-sample countries (those of the multilateral scenario)
        tax_deficits = self.get_total_tax_deficits(minimum_ETR=minimum_ETR)

        oecd = self.oecd.copy()

        # We extract the total tax deficit for the EU-27
        eu_27_tax_deficit = tax_deficits[
            tax_deficits[&#39;Parent jurisdiction (whitespaces cleaned)&#39;] == &#39;Total - EU27&#39;
        ][&#39;tax_deficit&#39;].iloc[0]

        # And we store in a separate DataFrame the tax deficits of EU-27 countries
        eu_27_tax_deficits = tax_deficits[
            tax_deficits[&#39;Parent jurisdiction (alpha-3 code)&#39;].isin(
                eu_27_country_codes
            )
        ].copy()

        # We focus only on a few non-EU countries, defined when the TaxDeficitCalculator object is instantiated
        tax_deficits = tax_deficits[
            tax_deficits[&#39;Parent jurisdiction (alpha-3 code)&#39;].isin(
                self.country_list_intermediary_scenario
            )
        ].copy()

        # We store the results in a dictionary, which we will map upon the eu_27_tax_deficits DataFrame
        additional_revenue_gains = {}

        # We iterate over EU-27 countries and compute for eacht he tax deficit collected from non-EU multinationals
        for eu_country in eu_27_country_codes:

            td_df = tax_deficits.copy()

            # This dictionary will store the attribution ratios based on extra-group sales to be mapped upon td_df
            attribution_ratios = {}

            # We iterate over non-EU countries in our list
            for country in self.country_list_intermediary_scenario:

                oecd_restricted = oecd[oecd[&#39;Parent jurisdiction (alpha-3 code)&#39;] == country].copy()

                # We fetch the extra-group sales registered by the non-EU country&#39;s multinationals in the EU-27 country
                # (defaults to 0 if the EU-27 country is not among the partners of the non-EU country)
                sales_in_eu_country = oecd_restricted[
                    oecd_restricted[&#39;Partner jurisdiction (alpha-3 code)&#39;] == eu_country
                ][&#39;Unrelated Party Revenues&#39;].sum()

                # We compute the total extra-group sales registered by the non-EU country&#39;s multinationals worldwide
                total_sales = oecd_restricted[&#39;Unrelated Party Revenues&#39;].sum()

                # We deduce the share of the non-EU country&#39;s tax deficit attributable to the EU-27 country
                attribution_ratios[country] = sales_in_eu_country / total_sales

            # We map the attribution_ratios dictionary upon the td_df DataFrame
            td_df[&#39;Attribution ratios&#39;] = td_df[&#39;Parent jurisdiction (alpha-3 code)&#39;].map(attribution_ratios)

            # We deduce, for each non-EU country, the amount of its tax deficit that is collected by the EU-27 country
            td_df[&#39;Collectible tax deficit&#39;] = td_df[&#39;Attribution ratios&#39;] * td_df[&#39;tax_deficit&#39;]

            # We sum all these and multiply the total by 2 to estimate the total tax deficit that the EU-27 country
            # could collect from non-EU multinationals
            additional_revenue_gains[eu_country] = td_df[&#39;Collectible tax deficit&#39;].sum() * 2

            # NB: the multiplication by 2 corresponds to the imputation strategy defined in Appendix C of the report

        # We map the resulting dictionary upon the eu_27_tax_deficits DataFrame
        eu_27_tax_deficits[&#39;From foreign MNEs&#39;] = eu_27_tax_deficits[&#39;Parent jurisdiction (alpha-3 code)&#39;].map(
            additional_revenue_gains
        )

        # And deduce total corporate tax revenue gains from such a scenario for all EU-27 countries
        eu_27_tax_deficits[&#39;Total&#39;] = (
            eu_27_tax_deficits[&#39;tax_deficit&#39;] + eu_27_tax_deficits[&#39;From foreign MNEs&#39;]
        )

        # We operate a similar process for &#34;Europe&#34; and &#34;Other Europe&#34; field
        additional_revenue_gains = {}

        for aggregate in [&#39;Europe&#39;, &#39;Other Europe&#39;]:

            td_df = tax_deficits.copy()

            attribution_ratios = {}

            for country in self.country_list_intermediary_scenario:

                # We do not consider the &#34;Other Europe&#34; field in the US CbCR as it probably does not correspond to
                # activities operated in EU-27 countries (sufficient country-by-country breakdown to exclude this)
                if country == &#39;USA&#39;:
                    attribution_ratios[country] = 0

                    continue

                oecd_restricted = oecd[oecd[&#39;Parent jurisdiction (alpha-3 code)&#39;] == country].copy()

                sales_in_europe_or_other_europe = oecd_restricted[
                    oecd_restricted[&#39;Partner jurisdiction (whitespaces cleaned)&#39;] == aggregate
                ][&#39;Unrelated Party Revenues&#39;].sum()

                total_sales = oecd_restricted[&#39;Unrelated Party Revenues&#39;].sum()

                attribution_ratios[country] = sales_in_europe_or_other_europe / total_sales

            td_df[&#39;Attribution ratios&#39;] = td_df[&#39;Parent jurisdiction (alpha-3 code)&#39;].map(attribution_ratios)

            td_df[&#39;Collectible tax deficit&#39;] = td_df[&#39;Attribution ratios&#39;] * td_df[&#39;tax_deficit&#39;]

            additional_revenue_gains[aggregate] = td_df[&#39;Collectible tax deficit&#39;].sum()

        # We drop unnecessary columns
        eu_27_tax_deficits.drop(
            columns=[&#39;Parent jurisdiction (alpha-3 code)&#39;],
            inplace=True
        )

        # And we operate very inelegant transformations of the DataFrame to add the &#34;Other Europe&#34;, &#34;Europe&#34; and &#34;Total&#34;
        # fields at the bottom of the DataFrame
        eu_27_tax_deficits.reset_index(drop=True, inplace=True)

        dict_df = eu_27_tax_deficits.to_dict()

        dict_df[eu_27_tax_deficits.columns[0]][len(eu_27_tax_deficits)] = &#39;Other Europe&#39;
        dict_df[eu_27_tax_deficits.columns[1]][len(eu_27_tax_deficits)] = 0
        dict_df[eu_27_tax_deficits.columns[2]][len(eu_27_tax_deficits)] = additional_revenue_gains[&#39;Other Europe&#39;]
        dict_df[eu_27_tax_deficits.columns[3]][len(eu_27_tax_deficits)] = additional_revenue_gains[&#39;Other Europe&#39;]

        dict_df[eu_27_tax_deficits.columns[0]][len(eu_27_tax_deficits) + 1] = &#39;Europe&#39;
        dict_df[eu_27_tax_deficits.columns[1]][len(eu_27_tax_deficits) + 1] = 0
        dict_df[eu_27_tax_deficits.columns[2]][len(eu_27_tax_deficits) + 1] = additional_revenue_gains[&#39;Europe&#39;]
        dict_df[eu_27_tax_deficits.columns[3]][len(eu_27_tax_deficits) + 1] = additional_revenue_gains[&#39;Europe&#39;]

        # Here we compute total corporate tax revenue gains for EU-27 countries
        # NB: We have not multiplied the &#34;Other Europe&#34; and &#34;Europe&#34; fields by 2 (no imputation for these)
        total_additional_revenue_gain = eu_27_tax_deficits[&#39;From foreign MNEs&#39;].sum() \
            + additional_revenue_gains[&#39;Europe&#39;] \
            + additional_revenue_gains[&#39;Other Europe&#39;]

        dict_df[eu_27_tax_deficits.columns[0]][len(eu_27_tax_deficits) + 2] = &#39;Total&#39;
        dict_df[eu_27_tax_deficits.columns[1]][len(eu_27_tax_deficits) + 2] = eu_27_tax_deficit
        dict_df[eu_27_tax_deficits.columns[2]][len(eu_27_tax_deficits) + 2] = total_additional_revenue_gain
        dict_df[eu_27_tax_deficits.columns[3]][len(eu_27_tax_deficits) + 2] = \
            eu_27_tax_deficit + total_additional_revenue_gain

        eu_27_tax_deficits = pd.DataFrame.from_dict(dict_df)

        # We convert 2021 EUR figures into 2021 billion EUR
        for column_name in eu_27_tax_deficits.columns[1:]:
            eu_27_tax_deficits[column_name] /= 10**6

        return eu_27_tax_deficits.copy()

    def output_intermediary_scenario_gain_formatted(self, minimum_ETR=0.25):
        &#34;&#34;&#34;
        This method is used in the &#34;app.py&#34; file, which lies behind the Streamlit simulator. It allows to produce the
        table presented on the &#34;Partial cooperation scenario&#34; page. It takes as input the selected minimum ETR and then,
        widely relies on the compute_intermediary_scenario_gain method defined above. It mostly consists in a series of
        formatting steps to make the table more readable and understandable.
        &#34;&#34;&#34;

        # We compute corporate tax revenue gains from the partial cooperation scenario
        df = self.compute_intermediary_scenario_gain(minimum_ETR=minimum_ETR)

        # We eliminate irrelevant columns
        df.drop(columns=[&#39;tax_deficit&#39;, &#39;From foreign MNEs&#39;], inplace=True)

        # We reformat figures with a thousand separator and a 0-decimal rounding
        df[&#39;Total&#39;] = df[&#39;Total&#39;].map(&#39;{:,.0f}&#39;.format)

        # We rename columns to make them more explicit
        df.rename(
            columns={
                &#39;Parent jurisdiction (whitespaces cleaned)&#39;: &#39;Taxing country&#39;,
                &#39;Total&#39;: &#39;Collectible tax deficit (€m)&#39;
            },
            inplace=True
        )

        # We add quotation marks to the &#34;Europe&#34; and &#34;Other Europe&#34; fields
        df[&#39;Taxing country&#39;] = df[&#39;Taxing country&#39;].map(
            lambda x: x if x not in [&#39;Europe&#39;, &#39;Other Europe&#39;] else f&#39;&#34;{x}&#34;&#39;
        )

        return df.copy()

    def assess_carve_out_impact(self, minimum_ETR=0.25):
        &#34;&#34;&#34;
        This function takes as input a minimum effective tax rate (which defaults to 25%) and outputs a DataFrame
        showing, for each in-sample country (EU and/or CbCR-reporting countries):

        - the tax deficit that it could collect by imposing this minimum ETR on the profits of its multinationals;
        - the split between domestic, tax haven and non-haven tax deficits;
        - and the same amounts with carve-outs being applied.

        Carve-outs are applied with the parameters (carve-out rate, use of the full value of tangible assets or of de-
        preciation expenses only and exclusion of inventories or not) that are defined when instantiating the TaxDefi-
        citCalculator object.
        &#34;&#34;&#34;

        # If carve-out parameters have not been indicated, we cannot run the computations
        if self.carve_out_rate is None or self.depreciation_only is None or self.exclude_inventories is None:
            raise Exception(
                &#39;If you want to simulate substance-based carve-outs, you need to indicate all the parameters.&#39;
            )

        # We instantiate a TaxDeficitCalculator object with carve-outs
        calculator = TaxDeficitCalculator(
            carve_outs=True,
            carve_out_rate=self.carve_out_rate,
            depreciation_only=self.depreciation_only,
            exclude_inventories=self.exclude_inventories
        )

        # We load the data
        calculator.load_clean_data()

        # And deduce total tax deficits and their split, with carve-outs being applied
        carve_outs = calculator.compute_all_tax_deficits(
            CbCR_reporting_countries_only=False,
            minimum_ETR=minimum_ETR
        )

        # We instantiate a TaxDeficitCalculator object without carve-outs
        calculator_no_carve_out = TaxDeficitCalculator()

        # We load the data
        calculator_no_carve_out.load_clean_data()

        # And deduce total tax deficits and their split, without any carve-out being applied
        no_carve_outs = calculator_no_carve_out.compute_all_tax_deficits(
            CbCR_reporting_countries_only=False,
            minimum_ETR=minimum_ETR
        )

        # We merge the two DataFrames
        carve_outs_impact = carve_outs.merge(
            no_carve_outs,
            how=&#39;inner&#39;,
            on=[
                &#39;Parent jurisdiction (whitespaces cleaned)&#39;,
                &#39;Parent jurisdiction (alpha-3 code)&#39;
            ]
        ).rename(
            columns={
                &#39;tax_deficit_x&#39;: &#39;TD_with_carve_outs&#39;,
                &#39;tax_deficit_y&#39;: &#39;TD_no_carve_outs&#39;,
                &#39;tax_deficit_x_domestic_x&#39;: &#39;domestic_TD_with_carve_outs&#39;,
                &#39;tax_deficit_x_domestic_y&#39;: &#39;domestic_TD_no_carve_outs&#39;,
                &#39;tax_deficit_x_non_haven_x&#39;: &#39;non_haven_TD_with_carve_outs&#39;,
                &#39;tax_deficit_x_non_haven_y&#39;: &#39;non_haven_TD_no_carve_outs&#39;,
                &#39;tax_deficit_x_tax_haven_x&#39;: &#39;tax_haven_TD_with_carve_outs&#39;,
                &#39;tax_deficit_x_tax_haven_y&#39;: &#39;tax_haven_TD_no_carve_outs&#39;
            }
        )

        # We only show EU and/or CbCR-reporting countries
        cbcr_reporting_countries = list(self.oecd[&#39;Parent jurisdiction (alpha-3 code)&#39;].unique())

        mask_eu = carve_outs_impact[&#39;Parent jurisdiction (alpha-3 code)&#39;].isin(eu_27_country_codes)
        mask_cbcr = carve_outs_impact[&#39;Parent jurisdiction (alpha-3 code)&#39;].isin(cbcr_reporting_countries)

        # This condition is encapsulated in this boolean indexing mask
        mask = np.logical_or(mask_eu, mask_cbcr)

        # We add two useful indicator variables
        carve_outs_impact[&#39;IS_EU&#39;] = mask_eu * 1
        carve_outs_impact[&#39;REPORTS_CbCR&#39;] = mask_cbcr * 1

        # And restrict the DataFrame to relevant countries
        restricted_df = carve_outs_impact[mask].copy()

        # We finalise the formatting of the table
        restricted_df.sort_values(
            by=[&#39;IS_EU&#39;, &#39;Parent jurisdiction (alpha-3 code)&#39;],
            ascending=[False, True],
            inplace=True
        )

        columns = [
            &#39;Parent jurisdiction (whitespaces cleaned)&#39;, &#39;TD_with_carve_outs&#39;, &#39;TD_no_carve_outs&#39;,
            &#39;domestic_TD_with_carve_outs&#39;, &#39;domestic_TD_no_carve_outs&#39;, &#39;non_haven_TD_with_carve_outs&#39;,
            &#39;non_haven_TD_no_carve_outs&#39;, &#39;tax_haven_TD_with_carve_outs&#39;, &#39;tax_haven_TD_no_carve_outs&#39;,
            &#39;IS_EU&#39;, &#39;REPORTS_CbCR&#39;
        ]

        return restricted_df[columns].copy()

    def get_carve_outs_table(
        self,
        TWZ_countries_methodology,
        depreciation_only, exclude_inventories,
        carve_out_rate=0.05
    ):
        &#34;&#34;&#34;
        This function takes as input:

        - the methodology to use to estimate the post-carve-out revenue gains of TWZ countries;

        - a boolean, &#34;depreciation_only&#34;, indicating whether to restrict the tangible assets component of substance-
        based carve-outs to a share of depreciation expenses;

        - a boolean, &#34;exlude_inventories&#34;, indicating whether to exlude inventories from tangible assets or not;

        - the carve-out rate to use (which defaults to 5%).

        It returns a DataFrame that shows, for the 15% and 25% minimum rates and for each in-sample country, the estima-
        ted revenue gains from a global minimum tax without and with carve-outs being applied.
        &#34;&#34;&#34;

        # We need to have previously loaded and cleaned the OECD data
        if self.oecd is None:
            raise Exception(&#39;You first need to load clean data with the dedicated method and inplace=True.&#39;)

        # The &#34;TWZ_countries_methodology&#34; argument can only take a few string values
        if TWZ_countries_methodology not in [&#39;initial&#39;, &#39;new&#39;]:
            raise Exception(&#39;The &#34;TWZ_countries_methodology&#34; argument only accepts two values: &#34;initial&#34; or &#34;new&#34;.&#39;)

        # Computing tax deficits without substance-based carve-outs
        calculator = TaxDeficitCalculator()

        calculator.load_clean_data()

        td_25 = calculator.get_total_tax_deficits(minimum_ETR=0.25).iloc[:-2, :]
        td_15 = calculator.get_total_tax_deficits(minimum_ETR=0.15).iloc[:-2, :]

        # We merge the resulting DataFrames for the 15% and 25% minimum rates
        merged_df = td_25.merge(
            td_15[[&#39;Parent jurisdiction (alpha-3 code)&#39;, &#39;tax_deficit&#39;]],
            how=&#39;left&#39;,
            on=&#39;Parent jurisdiction (alpha-3 code)&#39;
        )

        merged_df[&#39;tax_deficit_y&#39;] = merged_df[&#39;tax_deficit_y&#39;].fillna(0)

        merged_df.rename(
            columns={
                &#39;tax_deficit_x&#39;: &#39;tax_deficit_25_no_carve_out&#39;,
                &#39;tax_deficit_y&#39;: &#39;tax_deficit_15_no_carve_out&#39;
            },
            inplace=True
        )

        # Computing corresponding tax deficits with substance-based carve-outs
        calculator = TaxDeficitCalculator(
            carve_outs=True, carve_out_rate=carve_out_rate,
            depreciation_only=depreciation_only, exclude_inventories=exclude_inventories
        )

        calculator.load_clean_data()

        td_25 = calculator.get_total_tax_deficits(minimum_ETR=0.25).iloc[:-2]
        td_15 = calculator.get_total_tax_deficits(minimum_ETR=0.15).iloc[:-2]

        # We merge the DataFrame obtained for the 25% minimum rate
        merged_df = merged_df.merge(
            td_25[[&#39;Parent jurisdiction (alpha-3 code)&#39;, &#39;tax_deficit&#39;]],
            how=&#39;left&#39;,
            on=&#39;Parent jurisdiction (alpha-3 code)&#39;
        )

        merged_df.rename(
            columns={
                &#39;tax_deficit&#39;: &#39;tax_deficit_25_with_carve_out&#39;
            },
            inplace=True
        )

        # We merge the DataFrame obtained for the 15% minimum rate
        merged_df = merged_df.merge(
            td_15[[&#39;Parent jurisdiction (alpha-3 code)&#39;, &#39;tax_deficit&#39;]],
            how=&#39;left&#39;,
            on=&#39;Parent jurisdiction (alpha-3 code)&#39;
        )

        merged_df[&#39;tax_deficit&#39;] = merged_df[&#39;tax_deficit&#39;].fillna(0)

        merged_df.rename(
            columns={
                &#39;tax_deficit&#39;: &#39;tax_deficit_15_with_carve_out&#39;
            },
            inplace=True
        )

        # We only show EU and/or CbCR-reporting countries
        cbcr_reporting_countries = list(self.oecd[&#39;Parent jurisdiction (alpha-3 code)&#39;].unique())

        mask_eu = merged_df[&#39;Parent jurisdiction (alpha-3 code)&#39;].isin(eu_27_country_codes)
        mask_cbcr = merged_df[&#39;Parent jurisdiction (alpha-3 code)&#39;].isin(cbcr_reporting_countries)

        # This condition is encapsulated in this boolean indexing mask
        mask = np.logical_or(mask_eu, mask_cbcr)

        # We add two useful indicator variables
        merged_df[&#39;IS_EU&#39;] = mask_eu * 1
        merged_df[&#39;REPORTS_CbCR&#39;] = mask_cbcr * 1

        # And we restrict the DataFrame to relevant countries
        restricted_df = merged_df[mask].copy()

        # We finalise the reformatting of the DataFrame
        restricted_df.sort_values(
            by=[&#39;IS_EU&#39;, &#39;Parent jurisdiction (alpha-3 code)&#39;],
            ascending=[False, True],
            inplace=True
        )

        if TWZ_countries_methodology == &#39;initial&#39;:
            # If we have opted for the &#34;initial&#34; methodology for TWZ countries, we can simply return the DataFrame as is
            return restricted_df.copy()

        else:
            # If we have chosen the &#34;new&#34; methodology, we have a bit more work!

            # We create a temporary copy of the DataFrame, restricted to CbCR-reporting countries (excluding Sweden)
            temp = restricted_df[restricted_df[&#39;REPORTS_CbCR&#39;] == 1].copy()
            temp = temp[temp[&#39;Parent jurisdiction (alpha-3 code)&#39;] != &#39;SWE&#39;].copy()

            # We deduce the average reduction factors to apply to the collectible tax deficits of TWZ countries
            self.imputation_15 = temp[&#39;tax_deficit_15_with_carve_out&#39;].sum() / temp[&#39;tax_deficit_15_no_carve_out&#39;].sum()
            self.imputation_25 = temp[&#39;tax_deficit_25_with_carve_out&#39;].sum() / temp[&#39;tax_deficit_25_no_carve_out&#39;].sum()

            # We apply the two downgrade factors to tax deficits without carve-outs
            restricted_df[&#39;tax_deficit_15_with_carve_out&#39;] = restricted_df.apply(
                (
                    lambda row: row[&#39;tax_deficit_15_no_carve_out&#39;] * self.imputation_15 if row[&#39;REPORTS_CbCR&#39;] == 0 or
                    row[&#39;Parent jurisdiction (alpha-3 code)&#39;] == &#39;SWE&#39; else row[&#39;tax_deficit_15_with_carve_out&#39;]
                ),
                axis=1
            )

            restricted_df[&#39;tax_deficit_25_with_carve_out&#39;] = restricted_df.apply(
                (
                    lambda row: row[&#39;tax_deficit_25_no_carve_out&#39;] * self.imputation_25 if row[&#39;REPORTS_CbCR&#39;] == 0 or
                    row[&#39;Parent jurisdiction (alpha-3 code)&#39;] == &#39;SWE&#39; else row[&#39;tax_deficit_25_with_carve_out&#39;]
                ),
                axis=1
            )

            # And we return the adjusted DataFrame
            return restricted_df.copy()

    def get_carve_outs_table_2(
        self,
        exclude_inventories, depreciation_only,
        carve_out_rate=0.05,
        output_Excel=False
    ):
        &#34;&#34;&#34;
        This function takes as input:

        - a boolean, &#34;depreciation_only&#34;, indicating whether to restrict the tangible assets component of substance-
        based carve-outs to a share of depreciation expenses;

        - a boolean, &#34;exlude_inventories&#34;, indicating whether to exlude inventories from tangible assets or not;

        - the carve-out rate to use (which defaults to 5%).

        It returns a DataFrame that shows, for the different minimum effective tax rates and for each in-sample country,
        the estimated impact of substance-based carve-outs. The change is expressed as a percentage of revenue gain es-
        timates without substance-based carve-outs.
        &#34;&#34;&#34;

        # The &#34;get_carve_outs_table&#34; method provides the required information for two minimum ETRs, 15% and 25%
        # This will serve as a central DataFrame to which we will add the 21% and 30% columns
        df = self.get_carve_outs_table(
            TWZ_countries_methodology=&#39;initial&#39;,
            exclude_inventories=exclude_inventories, depreciation_only=depreciation_only,
            carve_out_rate=carve_out_rate
        )

        # Computing tax deficits without substance-based carve-outs
        calculator = TaxDeficitCalculator()

        calculator.load_clean_data()

        td_21 = calculator.get_total_tax_deficits(minimum_ETR=0.21).iloc[:-2, :]
        td_30 = calculator.get_total_tax_deficits(minimum_ETR=0.3).iloc[:-2, :]

        # We add the 21% tax deficit to the central DataFrame
        merged_df = df.merge(
            td_21[[&#39;Parent jurisdiction (alpha-3 code)&#39;, &#39;tax_deficit&#39;]],
            how=&#39;left&#39;,
            on=&#39;Parent jurisdiction (alpha-3 code)&#39;
        )

        merged_df[&#39;tax_deficit&#39;] = merged_df[&#39;tax_deficit&#39;].fillna(0)

        # We add the 30% tax deficit to the central DataFrame
        merged_df = merged_df.merge(
            td_30[[&#39;Parent jurisdiction (alpha-3 code)&#39;, &#39;tax_deficit&#39;]],
            how=&#39;left&#39;,
            on=&#39;Parent jurisdiction (alpha-3 code)&#39;
        )

        merged_df[&#39;tax_deficit_y&#39;] = merged_df[&#39;tax_deficit_y&#39;].fillna(0)

        merged_df.rename(
            columns={
                &#39;tax_deficit_x&#39;: &#39;tax_deficit_21_no_carve_out&#39;,
                &#39;tax_deficit_y&#39;: &#39;tax_deficit_30_no_carve_out&#39;
            },
            inplace=True
        )

        # Computing corresponding tax deficits with substance-based carve-outs
        calculator = TaxDeficitCalculator(
            carve_outs=True,
            carve_out_rate=carve_out_rate,
            depreciation_only=depreciation_only,
            exclude_inventories=exclude_inventories
        )

        calculator.load_clean_data()

        td_21 = calculator.get_total_tax_deficits(minimum_ETR=0.21).iloc[:-2]
        td_30 = calculator.get_total_tax_deficits(minimum_ETR=0.3).iloc[:-2]

        # We add the 21% tax deficit with carve-outs to the central DataFrame
        merged_df = merged_df.merge(
            td_21[[&#39;Parent jurisdiction (alpha-3 code)&#39;, &#39;tax_deficit&#39;]],
            how=&#39;left&#39;,
            on=&#39;Parent jurisdiction (alpha-3 code)&#39;
        )

        merged_df[&#39;tax_deficit&#39;] = merged_df[&#39;tax_deficit&#39;].fillna(0)

        merged_df.rename(
            columns={
                &#39;tax_deficit&#39;: &#39;tax_deficit_21_with_carve_out&#39;
            },
            inplace=True
        )

        # We add the 30% tax deficit with carve-outs to the central DataFrame
        merged_df = merged_df.merge(
            td_30[[&#39;Parent jurisdiction (alpha-3 code)&#39;, &#39;tax_deficit&#39;]],
            how=&#39;left&#39;,
            on=&#39;Parent jurisdiction (alpha-3 code)&#39;
        )

        merged_df[&#39;tax_deficit&#39;] = merged_df[&#39;tax_deficit&#39;].fillna(0)

        merged_df.rename(
            columns={
                &#39;tax_deficit&#39;: &#39;tax_deficit_30_with_carve_out&#39;
            },
            inplace=True
        )

        # We have the tax deficit absolute amounts with and without carve-outs at 15%, 21%, 25% and 30% minimum rates
        # But we want to display the changes due to carve-outs, as a % of the no-carve-out tax deficit

        # We store the names of the 4 columns that we are going to add to the central DataFrame
        new_columns = []

        # We iterate over the 4 minimum rates
        for minimum_rate in [15, 21, 25, 30]:
            column_name_no_carve_out = f&#39;tax_deficit_{minimum_rate}_no_carve_out&#39;
            column_name_with_carve_out = f&#39;tax_deficit_{minimum_rate}_with_carve_out&#39;

            # We are going to add a new column that provides the % reduction due to carve-outs at the rate considered
            new_column_name = f&#39;reduction_at_{minimum_rate}_minimum_rate&#39;

            # We make the corresponding computation
            merged_df[new_column_name] = (
                (merged_df[column_name_with_carve_out] - merged_df[column_name_no_carve_out]) /
                merged_df[column_name_no_carve_out]
            ) * 100

            new_columns.append(new_column_name)

        if output_Excel:
            with pd.ExcelWriter(&#39;/Users/Paul-Emmanuel/Desktop/carve_outs_table_2.xlsx&#39;, engine=&#39;xlsxwriter&#39;) as writer:
                merged_df.to_excel(writer, sheet_name=&#39;table_2&#39;, index=False)

        # We output the resulting DataFrame with country codes and names, as well as the 4 columns of interest
        merged_df = merged_df[
            [&#39;Parent jurisdiction (alpha-3 code)&#39;, &#39;Parent jurisdiction (whitespaces cleaned)&#39;] + new_columns
        ].copy()

        return merged_df.copy()

    def get_carve_outs_rate_table(
        self,
        minimum_ETR,
        depreciation_only, exclude_inventories,
    ):
        &#34;&#34;&#34;
        This function takes as inputs:

        - the minimum effective tax rate to apply to multinationals&#39; profits;

        - a boolean, &#34;depreciation_only&#34;, indicating whether to restrict the tangible assets component of substance-
        based carve-outs to a share of depreciation expenses;

        - a boolean, &#34;exlude_inventories&#34;, indicating whether to exlude inventories from tangible assets or not.

        It returns a DataFrame that shows, for each in-sample country, the estimated revenues that could be collected
        from a global minimum tax without any carve-outs and with carve-outs of 5%, 7.5% and 10% of tangible assets and
        payroll combined.
        &#34;&#34;&#34;

        # We instantiate a TaxDeficitCalculator object without carve-outs
        calculator = TaxDeficitCalculator()

        calculator.load_clean_data()

        # We use it to compute revenue gains without any carve-out
        td_no_carve_out = calculator.get_total_tax_deficits(minimum_ETR=minimum_ETR).iloc[:-2]

        td_no_carve_out.rename(
            columns={
                &#39;tax_deficit&#39;: &#39;tax_deficit_no_carve_out&#39;
            },
            inplace=True
        )

        # A copy of the resulting DataFrame will be used as a central table to which we add the relevant columns
        merged_df = td_no_carve_out.copy()

        # We iterate over carve-out rates
        for carve_out_rate in [5, 7.5, 10]:
            actual_rate = carve_out_rate / 100

            # We instantiate a TaxDeficitCalculator object with carve-outs at the rate considered
            calculator = TaxDeficitCalculator(
                carve_outs=True, carve_out_rate=actual_rate,
                depreciation_only=False, exclude_inventories=exclude_inventories
            )
            calculator.load_clean_data()

            # We use it to compute revenue gains with substance-based carve-outs being applied
            td_carve_out = calculator.get_total_tax_deficits(minimum_ETR=minimum_ETR).iloc[:-2]

            # We add the tax deficits thereby computed to the central table
            merged_df = merged_df.merge(
                td_carve_out[[&#39;Parent jurisdiction (alpha-3 code)&#39;, &#39;tax_deficit&#39;]],
                how=&#39;left&#39;,
                on=&#39;Parent jurisdiction (alpha-3 code)&#39;
            )

            merged_df[&#39;tax_deficit&#39;] = merged_df[&#39;tax_deficit&#39;].fillna(0)

            merged_df.rename(
                columns={
                    &#39;tax_deficit&#39;: f&#39;tax_deficit_{carve_out_rate}_carve_out&#39;
                },
                inplace=True
            )

        # We only display EU or CbCR-reporting countries
        cbcr_reporting_countries = list(self.oecd[&#39;Parent jurisdiction (alpha-3 code)&#39;].unique())

        mask_eu = merged_df[&#39;Parent jurisdiction (alpha-3 code)&#39;].isin(eu_27_country_codes)
        mask_cbcr = merged_df[&#39;Parent jurisdiction (alpha-3 code)&#39;].isin(cbcr_reporting_countries)

        # This condition is encapsulated in the following boolean indexing mask
        mask = np.logical_or(mask_eu, mask_cbcr)

        # We add two useful indicator variables
        merged_df[&#39;IS_EU&#39;] = mask_eu * 1
        merged_df[&#39;REPORTS_CbCR&#39;] = mask_cbcr * 1

        # And we restrict the DataFrame to relevant countries
        restricted_df = merged_df[mask].copy()

        # We finalise the formatting of the table
        restricted_df.sort_values(
            by=[&#39;IS_EU&#39;, &#39;Parent jurisdiction (alpha-3 code)&#39;],
            ascending=[False, True],
            inplace=True
        )

        # And eventually return the DataFrame
        return restricted_df.copy()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tax_deficit_simulator.calculator.TaxDeficitCalculator"><code class="flex name class">
<span>class <span class="ident">TaxDeficitCalculator</span></span>
<span>(</span><span>alternative_imputation=True, carve_outs=False, carve_out_rate=None, depreciation_only=None, exclude_inventories=None, payroll_premium=20)</span>
</code></dt>
<dd>
<div class="desc"><p>This is the instantiation method for the TaxDeficitCalculator class.</p>
<p>All its arguments have a default value. The two main ones are as follows:</p>
<ul>
<li>
<p>the boolean "alternative_imputation" (set to True by default), determines whether the imputation of the non-
haven tax deficit of non-OECD reporting countries at minimum rates of 20% or below is operated. For more details
on this methodological choice, one can refer to Appendix A of the report;</p>
</li>
<li>
<p>the boolean "carve_outs" (False by default) indicates whether to simulate substance-based carve-outs.</p>
</li>
</ul>
<p>If the latter argument is set to True, additional arguments are required:</p>
<ul>
<li>
<p>the "carve_out_rate" (float between 0 and 1) determines what share of tangible assets and payroll should be
deduced from the pre-tax profits of multinationals;</p>
</li>
<li>
<p>the boolean "depreciation_only" indicates whether to only account for depreciation expenses (instead of the
full value of tangible assets) in the tangible assets component of the carve-outs. Following the methodology of
the OECD Secretariat in its Economic Impact Assessment of Oct. 2020, is this argument is set to True, we appro-
ximate depreciation expenses as 10% of the book value of tangible assets;</p>
</li>
<li>
<p>the boolean "exclude_inventories" indicates whether to downgrade the tangible assets values provided by the
OECD's aggregated and anonymized country-by-country data. As a simplification of the OECD's methodology (Oct.
2020), if the argument is set to True, we reduce all tangible assets by 24%;</p>
</li>
<li>
<p>"payroll_premium" (float between 0 and 100 (considered as a %)) determines what upgrade to apply to the pay-
roll proxy. Indeed, the latter is based on ILO's data about per-country mean annual earnings. Considering that
the employees of large multinationals generally earn above-average wages, we propose to apply a premium to our
payroll proxy.</p>
</li>
</ul>
<p>The instantiation function is mainly used to define several object attributes that generally correspond to as-
sumptions taken in the report.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TaxDeficitCalculator:

    def __init__(
        self,
        alternative_imputation=True,
        carve_outs=False,
        carve_out_rate=None,
        depreciation_only=None, exclude_inventories=None, payroll_premium=20
    ):
        &#34;&#34;&#34;
        This is the instantiation method for the TaxDeficitCalculator class.

        All its arguments have a default value. The two main ones are as follows:

        - the boolean &#34;alternative_imputation&#34; (set to True by default), determines whether the imputation of the non-
        haven tax deficit of non-OECD reporting countries at minimum rates of 20% or below is operated. For more details
        on this methodological choice, one can refer to Appendix A of the report;

        - the boolean &#34;carve_outs&#34; (False by default) indicates whether to simulate substance-based carve-outs.

        If the latter argument is set to True, additional arguments are required:

        - the &#34;carve_out_rate&#34; (float between 0 and 1) determines what share of tangible assets and payroll should be
        deduced from the pre-tax profits of multinationals;

        - the boolean &#34;depreciation_only&#34; indicates whether to only account for depreciation expenses (instead of the
        full value of tangible assets) in the tangible assets component of the carve-outs. Following the methodology of
        the OECD Secretariat in its Economic Impact Assessment of Oct. 2020, is this argument is set to True, we appro-
        ximate depreciation expenses as 10% of the book value of tangible assets;

        - the boolean &#34;exclude_inventories&#34; indicates whether to downgrade the tangible assets values provided by the
        OECD&#39;s aggregated and anonymized country-by-country data. As a simplification of the OECD&#39;s methodology (Oct.
        2020), if the argument is set to True, we reduce all tangible assets by 24%;

        - &#34;payroll_premium&#34; (float between 0 and 100 (considered as a %)) determines what upgrade to apply to the pay-
        roll proxy. Indeed, the latter is based on ILO&#39;s data about per-country mean annual earnings. Considering that
        the employees of large multinationals generally earn above-average wages, we propose to apply a premium to our
        payroll proxy.

        The instantiation function is mainly used to define several object attributes that generally correspond to as-
        sumptions taken in the report.
        &#34;&#34;&#34;

        # These attributes will store the data loaded with the &#34;load_clean_data&#34; method
        self.oecd = None
        self.twz = None
        self.twz_domestic = None
        self.twz_CIT = None
        self.mean_wages = None

        # For non-OECD reporting countries, data are taken from TWZ 2019 appendix tables
        # An effective tax rate of 20% is assumed to be applied on profits registered in non-havens
        self.assumed_non_haven_ETR_TWZ = 0.2

        # An effective tax rate of 10% is assumed to be applied on profits registered in tax havens
        self.assumed_haven_ETR_TWZ = 0.1

        # Average exchange rate over the year 2016, extracted from benchmark computations run on Stata
        # Source: European Central Bank
        self.USD_to_EUR_2016 = 1 / 1.1069031

        # self.multiplier_EU = 1.13381004333496
        # self.multiplier_world = 1.1330304145813

        # Gross growth rate of worldwide GDP in current EUR between 2016 and 2021
        # Extracted from benchmark computations run on Stata
        self.multiplier_2021 = 1.1330304145813

        # For rates of 0.2 or lower an alternative imputation is used to estimate the non-haven tax deficit of non-OECD
        # reporting countries; this argument allows to enable or disable this imputation
        self.alternative_imputation = alternative_imputation
        self.reference_rate_for_alternative_imputation = 0.25

        # The list of countries whose tax deficit is partly collected by EU countries in the intermediary scenario
        self.country_list_intermediary_scenario = [
            &#39;USA&#39;,
            &#39;AUS&#39;,
            &#39;CAN&#39;,
            &#39;CHL&#39;,
            &#39;MEX&#39;,
            &#39;NOR&#39;,
            &#39;BMU&#39;,
            &#39;BRA&#39;,
            &#39;CHN&#39;,
            &#39;IND&#39;,
            &#39;SGP&#39;,
            &#39;ZAF&#39;,
            &#39;IDN&#39;,
            &#39;JPN&#39;
        ]

        # This boolean indicates whether or not to apply substance-based carve-outs
        self.carve_outs = carve_outs

        # In case we want to simulate substance-based carve-outs, a few additional steps are required
        if carve_outs:

            # We first check whether all the required parameters were provided
            if carve_out_rate is None or depreciation_only is None or exclude_inventories is None:

                raise Exception(
                    &#39;If you want to simulate substance-based carve-outs, you need to indicate all the parameters.&#39;
                )

            self.carve_out_rate = carve_out_rate
            self.depreciation_only = depreciation_only
            self.exclude_inventories = exclude_inventories
            self.payroll_premium = payroll_premium

            # This corresponds to the OECD Secretariat&#39;s simulations in its Economic Impact Assessment (Oct. 2020):
            # inventories are excluded from tangible assets and only depreciation expenses can be partly deducted
            if depreciation_only and exclude_inventories:
                self.assets_multiplier = 0.1 * (1 - 0.24)

            # Here, we only account for depreciation expenses but do not exclude inventories
            elif depreciation_only and not exclude_inventories:
                self.assets_multiplier = 0.1

            # In this case, we take the full value of tangible assets to form the tangible assets component of substan-
            # ce-based carve-outs, while excluding inventories
            elif not depreciation_only and exclude_inventories:
                self.assets_multiplier = (1 - 0.24)

            # Benchmark case, where we take the full value of tangible assets without adjusting for inventories
            else:
                self.assets_multiplier = 1

        else:
            self.carve_out_rate = None
            self.depreciation_only = None
            self.exclude_inventories = None

    def load_clean_data(
        self,
        path_to_oecd=path_to_oecd,
        path_to_twz=path_to_twz,
        path_to_twz_domestic=path_to_twz_domestic,
        path_to_twz_CIT=path_to_twz_CIT,
        path_to_preprocessed_mean_wages=path_to_preprocessed_mean_wages,
        path_to_statutory_rates=path_to_statutory_rates,
        inplace=True
    ):
        &#34;&#34;&#34;
        This method allows to load and clean data from 6 different sources:

        - the &#34;oecd.csv&#34; file which was extracted from the OECD&#39;s aggregated and anonymized country-by-country repor-
        ting, considering only the positive profit sample. Figures are in 2016 USD;

        - the &#34;twz.csv&#34; file which was extracted from the Table C4 of the TWZ 2019 online appendix. It presents, for
        a number of countries, the amounts of profits shifted to tax havens that are re-allocated to them on an ultima-
        te ownership basis. Figures are in 2016 USD million;

        - the &#34;twz_domestic.csv&#34; file, taken from the outputs of benchmark computations run on Stata. It presents for
        each country the amount of corporate profits registered locally by domestic MNEs and the effective tax rate to
        which they are subject. Figures are in 2016 USD billion;

        - the &#34;twz_CIT.csv&#34; file, extracted from Table U1 of the TWZ 2019 online appendix. It presents the corporate in-
        come tax revenue of each country in 2016 USD billion;

        - the &#34;preprocessed_mean_wages.csv&#34; file, taken from the outputs of substance-based carve-outs run on Stata. For
        each partner jurisdiction in the OECD&#39;s country-by-country data, it provides either a measure or an approxima-
        tion of the local mean annual earnings in 2016 in current USD. It is built upon ILO data, more details being
        provided in the methodological section of the Note n°1 of the Observatory on substance-based carve-outs;

        - the &#34;statutory_rates.csv&#34; file that provides, for a number of partner jurisdictions, their 2016 statutory cor-
        porate income tax rates.

        Default paths are used to let the simulator run via the app.py file. If you wish to use the tax_deficit_calcula-
        tor package in another context, you can save the data locally and give the method paths to the data files. The
        possibility to load the files from an online host instead will soon be implemented.
        &#34;&#34;&#34;
        try:

            # We try to read the files from the provided paths
            oecd = pd.read_csv(path_to_oecd)
            twz = pd.read_csv(path_to_twz, delimiter=&#39;;&#39;)
            twz_domestic = pd.read_csv(path_to_twz_domestic, delimiter=&#39;;&#39;)
            twz_CIT = pd.read_csv(path_to_twz_CIT, delimiter=&#39;;&#39;)
            preprocessed_mean_wages = pd.read_csv(path_to_preprocessed_mean_wages, delimiter=&#39;;&#39;)
            statutory_rates = pd.read_csv(path_to_statutory_rates, delimiter=&#39;;&#39;)

        except FileNotFoundError:

            # If at least one of the files is not found
            raise Exception(&#39;Are you sure these are the right paths for the source files?&#39;)

        # --- Cleaning the OECD data

        # We drop a few irrelevant columns from country-by-country data
        oecd.drop(
            columns=[&#39;PAN&#39;, &#39;Grouping&#39;, &#39;Flag Codes&#39;, &#39;Flags&#39;, &#39;YEA&#39;, &#39;Year&#39;],
            inplace=True
        )

        # We reshape the DataFrame from a long to a wide dataset
        oecd = oecd.pivot(
            index=[&#39;COU&#39;, &#39;Ultimate Parent Jurisdiction&#39;, &#39;JUR&#39;, &#39;Partner Jurisdiction&#39;],
            columns=&#39;Variable&#39;,
            values=&#39;Value&#39;
        ).reset_index()

        # We rename some columns to match the code that has been written before modifying how OECD data are loaded
        oecd.rename(
            columns={
                &#39;COU&#39;: &#39;Parent jurisdiction (alpha-3 code)&#39;,
                &#39;Ultimate Parent Jurisdiction&#39;: &#39;Parent jurisdiction (whitespaces cleaned)&#39;,
                &#39;JUR&#39;: &#39;Partner jurisdiction (alpha-3 code)&#39;,
                &#39;Partner Jurisdiction&#39;: &#39;Partner jurisdiction (whitespaces cleaned)&#39;
            },
            inplace=True
        )

        # Thanks to a function defined in utils.py, we rename the &#34;Foreign Jurisdictions Total&#34; field for all countries
        # that only report a domestic / foreign breakdown in their CbCR
        oecd[&#39;Partner jurisdiction (whitespaces cleaned)&#39;] = oecd.apply(rename_partner_jurisdictions, axis=1)

        # We eliminate stateless entities and the &#34;Foreign Jurisdictions Total&#34; filds
        oecd = oecd[
            ~oecd[&#39;Partner jurisdiction (whitespaces cleaned)&#39;].isin([&#39;Foreign Jurisdictions Total&#39;, &#39;Stateless&#39;])
        ].copy()

        # We replace missing &#34;Income Tax Paid&#34; values by the corresponding &#34;Income Tax Accrued&#34; values
        # (Some missing values remain even after this edit)
        oecd[&#39;Income Tax Paid (on Cash Basis)&#39;] = oecd.apply(
            (
                lambda row: row[&#39;Income Tax Paid (on Cash Basis)&#39;]
                if not np.isnan(row[&#39;Income Tax Paid (on Cash Basis)&#39;])
                else row[&#39;Income Tax Accrued - Current Year&#39;]
            ),
            axis=1
        )

        # We clean the statutory corporate income tax rate dataset
        statutory_rates[&#39;statrate&#39;] = statutory_rates[&#39;statrate&#39;].map(
            lambda x: x.replace(&#39;,&#39;, &#39;.&#39;) if isinstance(x, str) else x
        ).astype(float)

        # And we merge it with country-by-country data, on partner jurisdiction alpha-3 codes
        oecd = oecd.merge(
            statutory_rates,
            how=&#39;left&#39;,
            left_on=&#39;Partner jurisdiction (alpha-3 code)&#39;, right_on=&#39;partner&#39;
        )

        oecd.drop(columns=[&#39;partner&#39;], inplace=True)

        # We impute missing &#34;Income Tax Paid&#34; values assuming that pre-tax profits are taxed at the local statutory rate
        oecd[&#39;Income Tax Paid (on Cash Basis)&#39;] = oecd.apply(
            (
                lambda row: row[&#39;Income Tax Paid (on Cash Basis)&#39;]
                if not np.isnan(row[&#39;Income Tax Paid (on Cash Basis)&#39;])
                else row[&#39;Profit (Loss) before Income Tax&#39;] * row[&#39;statrate&#39;]
            ),
            axis=1
        )

        oecd.drop(columns=[&#39;statrate&#39;], inplace=True)

        # ETR computation (using tax paid as the numerator)
        oecd[&#39;ETR&#39;] = oecd[&#39;Income Tax Paid (on Cash Basis)&#39;] / oecd[&#39;Profit (Loss) before Income Tax&#39;]
        oecd[&#39;ETR&#39;] = oecd[&#39;ETR&#39;].map(lambda x: 0 if x &lt; 0 else x)

        # Adding an indicator variable for domestic profits (rows with the same parent and partner jurisdiction)
        oecd[&#39;Is domestic?&#39;] = oecd.apply(
            lambda row: row[&#39;Parent jurisdiction (alpha-3 code)&#39;] == row[&#39;Partner jurisdiction (alpha-3 code)&#39;],
            axis=1
        ) * 1

        # We add an indicator variable that takes value 1 if and only if the partner is a tax haven
        oecd[&#39;Is partner jurisdiction a tax haven?&#39;] = oecd[&#39;Partner jurisdiction (alpha-3 code)&#39;].isin(
            tax_haven_country_codes
        ) * 1

        # Adding another indicator variable that takes value 1 if and only if the partner is not a tax haven
        oecd[&#39;Is partner jurisdiction a non-haven?&#39;] = 1 - oecd[&#39;Is partner jurisdiction a tax haven?&#39;]

        # This indicator variable is used specifically for the simulation of carve-outs; it takes value 1 if and only if
        # the partner jurisdiction is not the parent jurisdiction, not a tax haven and not a regional aggregate
        oecd[&#39;Is partner jurisdiction a non-haven? - CO&#39;] = oecd.apply(
            (
                lambda row: 0
                if (
                    row[&#39;Parent jurisdiction (alpha-3 code)&#39;] in COUNTRIES_WITH_MINIMUM_REPORTING
                    and row[&#39;Partner jurisdiction (alpha-3 code)&#39;] == &#39;FJT&#39;
                ) or (
                    row[&#39;Parent jurisdiction (alpha-3 code)&#39;] in COUNTRIES_WITH_CONTINENTAL_REPORTING
                    and row[&#39;Partner jurisdiction (alpha-3 code)&#39;] in [&#39;GRPS&#39;, &#39;AFRIC&#39;, &#39;AMER&#39;, &#39;ASIAT&#39;, &#39;EUROP&#39;]
                ) or (
                    row[&#39;Is domestic?&#39;] == 1
                )
                else row[&#39;Is partner jurisdiction a non-haven?&#39;]
            ),
            axis=1
        )

        # This indicator variable, used specifically for the simulation of carve-outs, takes value 1 if and only if the
        # partner is a regional aggregate
        oecd[&#39;Is partner jurisdiction an aggregate partner? - CO&#39;] = np.logical_and(
            oecd[&#39;Is domestic?&#39;] == 0,
            np.logical_and(
                oecd[&#39;Is partner jurisdiction a non-haven? - CO&#39;] == 0,
                oecd[&#39;Is partner jurisdiction a tax haven?&#39;] == 0
            )
        ) * 1

        # Thanks to a small function imported from utils.py, we manage the slightly problematic overlap between the
        # various indicator variables (&#34;Is domestic?&#34; sort of gets the priority over the others)
        oecd[&#39;Is partner jurisdiction a tax haven?&#39;] = oecd.apply(
            lambda row: manage_overlap_with_domestic(row, &#39;haven&#39;),
            axis=1
        )

        oecd[&#39;Is partner jurisdiction a non-haven?&#39;] = oecd.apply(
            lambda row: manage_overlap_with_domestic(row, &#39;non-haven&#39;),
            axis=1
        )

        # We need some more work on the data if we want to simulate substance-based carve-outs
        if self.carve_outs:

            # We merge earnings data with country-by-country data on partner jurisdiction codes
            oecd = oecd.merge(
                preprocessed_mean_wages[[&#39;partner2&#39;, &#39;earn&#39;]],
                how=&#39;left&#39;,
                left_on=&#39;Partner jurisdiction (alpha-3 code)&#39;, right_on=&#39;partner2&#39;
            )

            oecd.drop(columns=[&#39;partner2&#39;], inplace=True)

            oecd.rename(
                columns={
                    &#39;earn&#39;: &#39;ANNUAL_VALUE&#39;
                },
                inplace=True
            )

            # We clean the mean annual earnings column
            oecd[&#39;ANNUAL_VALUE&#39;] = oecd[&#39;ANNUAL_VALUE&#39;].map(
                lambda x: x.replace(&#39;,&#39;, &#39;.&#39;) if isinstance(x, str) else x
            ).astype(float)

            # We deduce the payroll proxy from the number of employees and from mean annual earnings
            oecd[&#39;PAYROLL&#39;] = oecd[&#39;Number of Employees&#39;] * oecd[&#39;ANNUAL_VALUE&#39;] * (1 + self.payroll_premium / 100)

            # We compute substance-based carve-outs from both payroll and tangible assets
            oecd[&#39;CARVE_OUT&#39;] = self.carve_out_rate * (
                oecd[&#39;PAYROLL&#39;] + oecd[&#39;Tangible Assets other than Cash and Cash Equivalents&#39;] * self.assets_multiplier
            )

            # This column will contain slightly modified carve-outs, carve-outs being replaced by pre-tax profits
            # wherever the former exceeds the latter
            oecd[&#39;CARVE_OUT_TEMP&#39;] = oecd.apply(
                (
                    lambda row: row[&#39;CARVE_OUT&#39;] if row[&#39;Profit (Loss) before Income Tax&#39;] &gt; row[&#39;CARVE_OUT&#39;]
                    or np.isnan(row[&#39;CARVE_OUT&#39;])
                    else row[&#39;Profit (Loss) before Income Tax&#39;]
                ),
                axis=1
            )

            # We exclude rows with missing carve-out values in a temporary DataFrame
            oecd_temp = oecd[
                ~np.logical_or(
                    oecd[&#39;PAYROLL&#39;].isnull(),
                    oecd[&#39;Tangible Assets other than Cash and Cash Equivalents&#39;].isnull()
                )
            ].copy()

            # We compute the average reduction in non-haven pre-tax profits due to carve-outs
            self.avg_carve_out_impact_non_haven = (
                oecd_temp[
                    oecd_temp[&#39;Is partner jurisdiction a non-haven? - CO&#39;] == 1
                ][&#39;CARVE_OUT_TEMP&#39;].sum() /
                oecd_temp[
                    oecd_temp[&#39;Is partner jurisdiction a non-haven? - CO&#39;] == 1
                ][&#39;Profit (Loss) before Income Tax&#39;].sum()
            )

            # We do the same for pre-tax profits booked in tax havens, domestically and in aggregate partners
            self.avg_carve_out_impact_tax_haven = (
                oecd_temp[oecd_temp[&#39;Is partner jurisdiction a tax haven?&#39;] == 1][&#39;CARVE_OUT_TEMP&#39;].sum() /
                oecd_temp[
                    oecd_temp[&#39;Is partner jurisdiction a tax haven?&#39;] == 1
                ][&#39;Profit (Loss) before Income Tax&#39;].sum()
            )
            self.avg_carve_out_impact_domestic = (
                oecd_temp[oecd_temp[&#39;Is domestic?&#39;] == 1][&#39;CARVE_OUT_TEMP&#39;].sum() /
                oecd_temp[oecd_temp[&#39;Is domestic?&#39;] == 1][&#39;Profit (Loss) before Income Tax&#39;].sum()
            )
            self.avg_carve_out_impact_aggregate = (
                oecd_temp[
                    oecd_temp[&#39;Is partner jurisdiction an aggregate partner? - CO&#39;] == 1
                ][&#39;CARVE_OUT_TEMP&#39;].sum() /
                oecd_temp[
                    oecd_temp[&#39;Is partner jurisdiction an aggregate partner? - CO&#39;] == 1
                ][&#39;Profit (Loss) before Income Tax&#39;].sum()
            )

            # We impute missing carve-out values based on these average reductions in pre-tax profits
            oecd[&#39;CARVE_OUT&#39;] = oecd.apply(
                lambda row: impute_missing_carve_out_values(
                    row,
                    avg_carve_out_impact_domestic=self.avg_carve_out_impact_domestic,
                    avg_carve_out_impact_tax_haven=self.avg_carve_out_impact_tax_haven,
                    avg_carve_out_impact_non_haven=self.avg_carve_out_impact_non_haven,
                    avg_carve_out_impact_aggregate=self.avg_carve_out_impact_aggregate
                ),
                axis=1
            )

            # Some missing values remain whenever profits before tax are missing
            oecd = oecd[~oecd[&#39;CARVE_OUT&#39;].isnull()].copy()

            # We remove substance-based carve-outs from pre-tax profits
            oecd[&#39;Profit (Loss) before Income Tax&#39;] = oecd.apply(
                (
                    lambda row: row[&#39;Profit (Loss) before Income Tax&#39;] - row[&#39;CARVE_OUT&#39;]
                    if row[&#39;Profit (Loss) before Income Tax&#39;] - row[&#39;CARVE_OUT&#39;] &gt;= 0
                    else 0
                ),
                axis=1
            )

        # --- Cleaning the TWZ tax haven profits data

        # Adding an indicator variable for OECD reporting - We do not consider the Swedish CbCR
        twz[&#39;Is parent in OECD data?&#39;] = twz[&#39;Alpha-3 country code&#39;].map(
            lambda x: x in oecd[&#39;Parent jurisdiction (alpha-3 code)&#39;].unique() if x != &#39;SWE&#39; else False
        ) * 1

        # We reformat numeric columns - Resulting figures are expressed in 2016 USD
        for column_name in [&#39;Profits in all tax havens&#39;, &#39;Profits in all tax havens (positive only)&#39;]:
            twz[column_name] = twz[column_name].map(lambda x: x.replace(&#39;,&#39;, &#39;.&#39;))
            twz[column_name] = twz[column_name].astype(float) * 1000000

            if self.carve_outs:
                # If we want to simulate carve-outs, we need to downgrade TWZ tax haven profits by the average reduction
                # due to carve-outs that is observed for tax haven profits in the OECD data
                twz[column_name] *= (1 - self.avg_carve_out_impact_tax_haven)
            else:
                continue

        # We filter out countries with 0 profits in tax havens
        twz = twz[twz[&#39;Profits in all tax havens (positive only)&#39;] &gt; 0].copy()

        # --- Cleaning the TWZ domestic profits data

        # Reformatting the profits column - Resulting figures are expressed in 2016 USD
        twz_domestic[&#39;Domestic profits&#39;] = twz_domestic[&#39;Domestic profits&#39;]\
            .map(lambda x: x.replace(&#39;,&#39;, &#39;.&#39;))\
            .astype(float) * 1000000000

        # Reformatting the ETR column
        twz_domestic[&#39;Domestic ETR&#39;] = twz_domestic[&#39;Domestic ETR&#39;].map(lambda x: x.replace(&#39;,&#39;, &#39;.&#39;)).astype(float)

        if self.carve_outs:
            # If we want to simulate carve-outs, we need to downgrade TWZ domestic profits by the average reduction due
            # to carve-outs that is observed for domestic profits in the OECD data
            twz_domestic[&#39;Domestic profits&#39;] *= (1 - self.avg_carve_out_impact_domestic)

        # --- Cleaning the TWZ CIT revenue data

        # Reformatting the CIT revenue column - Resulting figures are expressed in 2016 USD
        twz_CIT[&#39;CIT revenue&#39;] = twz_CIT[&#39;CIT revenue&#39;]\
            .map(lambda x: x.replace(&#39;,&#39;, &#39;.&#39;))\
            .astype(float) * 1000000000

        if inplace:
            self.oecd = oecd.copy()
            self.twz = twz.copy()
            self.twz_domestic = twz_domestic.copy()
            self.twz_CIT = twz_CIT.copy()
            self.mean_wages = preprocessed_mean_wages.copy()

        else:

            if self.carve_outs:
                return oecd.copy(), twz.copy(), twz_domestic.copy(), twz_CIT.copy(), preprocessed_mean_wages.copy()

            else:
                return oecd.copy(), twz.copy(), twz_domestic.copy(), twz_CIT.copy()

    def get_non_haven_imputation_ratio(self, minimum_ETR):
        &#34;&#34;&#34;
        For non-OECD reporting countries, we base our estimates on data compiled by Tørsløv, Wier and Zucman (2019).
        These allow to compute domestic and tax-haven-based tax deficit of these countries. We extrapolate the non-haven
        tax deficit of these countries from the tax-haven one.

        We impute the tax deficit in non-haven jurisdictions by estimating the ratio of tax deficits in non-tax havens
        to tax-havens for the EU non-tax haven parent countries in the CbCR data. We assume a 20% ETR in non-tax havens
        and a 10% ETR in tax havens (these rates are defined in two dedicated attributes in the instantiation function).

        This function allows to compute this ratio following the (A2) formula of Appendix A.

        The methodology is described in more details in the Appendix A of the report.
        &#34;&#34;&#34;

        # We need to have previously loaded and cleaned the OECD data
        if self.oecd is None:
            raise Exception(&#39;You first need to load clean data with the dedicated method and inplace=True.&#39;)

        # With a minimum ETR of 10%, the formula cannot be applied (division by 0), hence this case disjunction
        if minimum_ETR &gt; 0.1:
            oecd = self.oecd.copy()

            # In the computation of the imputation ratio, we only focus on:
            # - EU-27 parent countries
            mask_eu = oecd[&#39;Parent jurisdiction (alpha-3 code)&#39;].isin(eu_27_country_codes)
            # - That are not tax havens
            mask_non_haven = ~oecd[&#39;Parent jurisdiction (alpha-3 code)&#39;].isin(tax_haven_country_codes)
            # - And report a detailed country by country breakdown in their CbCR
            mask_minimum_reporting_countries = ~oecd[&#39;Parent jurisdiction (alpha-3 code)&#39;].isin(
                COUNTRIES_WITH_MINIMUM_REPORTING + COUNTRIES_WITH_CONTINENTAL_REPORTING
            )

            # We combine the boolean indexing masks
            mask = np.logical_and(mask_eu, mask_non_haven)
            mask = np.logical_and(mask, mask_minimum_reporting_countries)

            # And convert booleans into 0 / 1 integers
            mask = mask * 1

            # We compute the profits registered by retained countries in non-haven countries
            # (excluding domestic profits, cf. the earlier use of the manage_overlap_with_domestic function)
            foreign_non_haven_profits = (
                (
                    mask * oecd[&#39;Is partner jurisdiction a non-haven?&#39;]
                ) * oecd[&#39;Profit (Loss) before Income Tax&#39;]
            ).sum()

            # We compute the profits registered by retained countries in tax havens
            # (excluding domestic profits, cf. the earlier use of the manage_overlap_with_domestic function)
            foreign_haven_profits = (
                (
                    mask * oecd[&#39;Is partner jurisdiction a tax haven?&#39;]
                ) * oecd[&#39;Profit (Loss) before Income Tax&#39;]
            ).sum()

            # We apply the formula and compute the imputation ratio
            imputation_ratio_non_haven = (
                (
                    # If the minimum ETR is below the rate assumed to be applied on non-haven profits, there is no tax
                    # deficit to collect from these profits, which is why we have this max(..., 0)
                    max(minimum_ETR - self.assumed_non_haven_ETR_TWZ, 0) * foreign_non_haven_profits
                ) /
                ((minimum_ETR - self.assumed_haven_ETR_TWZ) * foreign_haven_profits)
            )

        # We manage the case where the minimum ETR is of 10% and the formula cannot be applied
        elif minimum_ETR == 0.1:

            # As long as tax haven profits are assumed to be taxed at a rate of 10%, the value that we set here has no
            # effect (it will be multiplied to 0 tax-haven-based tax deficits) but to remain consistent with higher
            # values of the minimum ETR, we impute 0

            imputation_ratio_non_haven = 0

        else:
            # We do not yet manage effective tax rates below 10%
            raise Exception(&#39;Unexpected minimum ETR entered (strictly below 0.1).&#39;)

        return imputation_ratio_non_haven

    def get_alternative_non_haven_factor(self, minimum_ETR):
        &#34;&#34;&#34;
        Looking at the formula (A2) of Appendix A and at the previous method, we see that for a 15% tax rate, this impu-
        tation would result in no tax deficit to be collected from non-tax haven jurisdictions. Thus, we correct for
        this underestimation by computing the ratio of the tax deficit that can be collected in non-tax havens at a 15%
        and a 25% rate for OECD-reporting countries.

        This class method allows to compute this alternative imputation ratio.

        The methodology is described in more details in the Appendix A of the report.
        &#34;&#34;&#34;

        # We need to have previously loaded and cleaned the OECD data
        if self.oecd is None:
            raise Exception(&#39;You first need to load clean data with the dedicated method and inplace=True.&#39;)

        # This method is only useful if the previous one yields a ratio of 0, i.e. if the minimum ETR is of 20% or less
        if minimum_ETR &gt; 0.2:
            raise Exception(&#39;These computations are only used when the minimum ETR considered is 0.2 or less.&#39;)

        # We use the get_stratified_oecd_data to compute the non-haven tax deficit of OECD-reporting countries
        oecd_stratified = self.get_stratified_oecd_data(
            minimum_ETR=self.reference_rate_for_alternative_imputation
        )

        # We exclude countries whose CbCR breakdown does not allow to distinguish tax-haven and non-haven profits
        df_restricted = oecd_stratified[
            ~oecd_stratified[&#39;Parent jurisdiction (alpha-3 code)&#39;].isin(
                COUNTRIES_WITH_CONTINENTAL_REPORTING + COUNTRIES_WITH_MINIMUM_REPORTING
            )
        ].copy()

        # The denominator is the total non-haven tax deficit of relevant countries at the reference minimum ETR
        denominator = df_restricted[&#39;tax_deficit_x_non_haven&#39;].sum()

        # We follow the same process, running computations at the minimum ETR this time
        oecd_stratified = self.get_stratified_oecd_data(minimum_ETR=minimum_ETR)

        # We exclude countries whose CbCR breakdown does not allow to distinguish tax-haven and non-haven profits
        df_restricted = oecd_stratified[
            ~oecd_stratified[&#39;Parent jurisdiction (alpha-3 code)&#39;].isin(
                COUNTRIES_WITH_CONTINENTAL_REPORTING + COUNTRIES_WITH_MINIMUM_REPORTING
            )
        ].copy()

        # The numerator is the total non-haven tax deficit of relevant countries at the selected minimum ETR
        numerator = df_restricted[&#39;tax_deficit_x_non_haven&#39;].sum()

        return numerator / denominator

    def get_stratified_oecd_data(self, minimum_ETR=0.25):
        &#34;&#34;&#34;
        This method constitutes a first step in the computation of each country&#39;s collectible tax deficit in the multi-
        lateral agreement scenario.

        Taking the minimum effective tax rate as input and based on OECD data, this function outputs a DataFrame that
        displays, for each OECD-reporting parent country, the tax deficit that could be collected from the domestic,
        tax haven and non-haven profits of multinationals headquartered in this country.

        The output is in 2016 USD, like the raw OECD data.
        &#34;&#34;&#34;

        # We need to have previously loaded and cleaned the OECD data
        if self.oecd is None:
            raise Exception(&#39;You first need to load clean data with the dedicated method and inplace=True.&#39;)

        oecd = self.oecd.copy()

        # We only profits taxed at an effective tax rate above the minimum ETR
        oecd = oecd[oecd[&#39;ETR&#39;] &lt; minimum_ETR].copy()

        # We compute the ETR differential for all low-taxed profits
        oecd[&#39;ETR_differential&#39;] = oecd[&#39;ETR&#39;].map(lambda x: minimum_ETR - x)

        # And deduce the tax deficit generated by each Parent / Partner jurisidiction pair
        oecd[&#39;tax_deficit&#39;] = oecd[&#39;ETR_differential&#39;] * oecd[&#39;Profit (Loss) before Income Tax&#39;]

        # Using the aforementioned indicator variables allows to breakdown this tax deficit
        oecd[&#39;tax_deficit_x_domestic&#39;] = oecd[&#39;tax_deficit&#39;] * oecd[&#39;Is domestic?&#39;]
        oecd[&#39;tax_deficit_x_tax_haven&#39;] = oecd[&#39;tax_deficit&#39;] * oecd[&#39;Is partner jurisdiction a tax haven?&#39;]
        oecd[&#39;tax_deficit_x_non_haven&#39;] = oecd[&#39;tax_deficit&#39;] * oecd[&#39;Is partner jurisdiction a non-haven?&#39;]

        # We group the table by Parent jurisdiction such that for, say, France, the table displays the total domestic,
        # tax-haven and non-haven tax deficit generated by French multinationals
        oecd_stratified = oecd[
            [
                &#39;Parent jurisdiction (whitespaces cleaned)&#39;,
                &#39;Parent jurisdiction (alpha-3 code)&#39;,
                &#39;tax_deficit&#39;,
                &#39;tax_deficit_x_domestic&#39;,
                &#39;tax_deficit_x_tax_haven&#39;,
                &#39;tax_deficit_x_non_haven&#39;
            ]
        ].groupby(
            &#39;Parent jurisdiction (whitespaces cleaned)&#39;
        ).agg(
            {
                &#39;Parent jurisdiction (alpha-3 code)&#39;: &#39;first&#39;,
                &#39;tax_deficit&#39;: &#39;sum&#39;,
                &#39;tax_deficit_x_domestic&#39;: &#39;sum&#39;,
                &#39;tax_deficit_x_tax_haven&#39;: &#39;sum&#39;,
                &#39;tax_deficit_x_non_haven&#39;: &#39;sum&#39;
            }
        ).copy()

        oecd_stratified.reset_index(inplace=True)

        return oecd_stratified.copy()

    def compute_all_tax_deficits(self, minimum_ETR=0.25, CbCR_reporting_countries_only=False):
        &#34;&#34;&#34;
        This method encapsulates most of the computations for the multilateral agreement scenario.

        Taking as input the minimum effective tax rate to apply and based on OECD and TWZ data, it outputs a DataFrame
        which presents, for each country in our sample (countries in OECD and/or TWZ data) the total tax deficit, as
        well as its breakdown into domestic, tax-haven and non-haven tax deficits.

        The output is in 2021 EUR after a currency conversion and the extrapolation from 2016 to 2021 figures.
        &#34;&#34;&#34;
        # We need to have previously loaded and cleaned the OECD and TWZ data
        if self.oecd is None or self.twz is None:
            raise Exception(&#39;You first need to load clean data with the dedicated method and inplace=True.&#39;)

        # We use the method defined above and will use its output as a base for the following computations
        oecd_stratified = self.get_stratified_oecd_data(minimum_ETR=minimum_ETR)

        twz = self.twz.copy()

        # From TWZ data on profits registered in tax havens and assuming that these are taxed at a given minimum ETR
        # (10% in the report, see the instantiation function for the definition of this attribute), we deduce the tax-
        # haven-based tax deficit of TWZ countries
        twz[&#39;tax_deficit_x_tax_haven_TWZ&#39;] = \
            twz[&#39;Profits in all tax havens (positive only)&#39;] * (minimum_ETR - self.assumed_haven_ETR_TWZ)

        # --- Managing countries in both OECD and TWZ data

        # We focus on parent countries which are in both the OECD and TWZ data
        # NB: recall that we do not consider the Swedish CbCR
        twz_in_oecd = twz[twz[&#39;Is parent in OECD data?&#39;].astype(bool)].copy()

        # We merge the two DataFrames on country codes
        merged_df = oecd_stratified.merge(
            twz_in_oecd[[&#39;Country&#39;, &#39;Alpha-3 country code&#39;, &#39;tax_deficit_x_tax_haven_TWZ&#39;]],
            how=&#39;left&#39;,
            left_on=&#39;Parent jurisdiction (alpha-3 code)&#39;,
            right_on=&#39;Alpha-3 country code&#39;
        ).drop(columns=[&#39;Country&#39;, &#39;Alpha-3 country code&#39;])

        # For countries that are in the OECD data but not in TWZ, we impute a tax-haven-based tax deficit from TWZ of 0
        merged_df[&#39;tax_deficit_x_tax_haven_TWZ&#39;] = merged_df[&#39;tax_deficit_x_tax_haven_TWZ&#39;].fillna(0)

        self.countries_replaced = []

        if self.carve_outs:

            calculator = TaxDeficitCalculator()
            calculator.load_clean_data()
            _ = calculator.compute_all_tax_deficits()

            countries_replaced = calculator.countries_replaced.copy()

            merged_df[&#39;tax_deficit_x_tax_haven_merged&#39;] = merged_df.apply(
                lambda row: self.combine_haven_tax_deficits(
                    row,
                    carve_outs=self.carve_outs,
                    countries_replaced=countries_replaced),
                axis=1
            )

        else:
            merged_df[&#39;tax_deficit_x_tax_haven_merged&#39;] = merged_df.apply(
                lambda row: self.combine_haven_tax_deficits(
                    row,
                    carve_outs=self.carve_outs
                ),
                axis=1
            )

        self.countries_replaced = merged_df[
            merged_df[&#39;tax_deficit_x_tax_haven_merged&#39;] == merged_df[&#39;tax_deficit_x_tax_haven_TWZ&#39;]
        ][&#39;Parent jurisdiction (alpha-3 code)&#39;].unique()

        merged_df.drop(columns=[&#39;tax_deficit_x_tax_haven&#39;, &#39;tax_deficit_x_tax_haven_TWZ&#39;], inplace=True)

        merged_df.rename(
            columns={
                &#39;tax_deficit_x_tax_haven_merged&#39;: &#39;tax_deficit_x_tax_haven&#39;
            },
            inplace=True
        )

        # Summing the tax-haven-based, non-haven and domestic tax deficits yields the total tax deficit of each country
        merged_df[&#39;tax_deficit&#39;] = merged_df[&#39;tax_deficit_x_tax_haven&#39;] \
            + merged_df[&#39;tax_deficit_x_domestic&#39;] \
            + merged_df[&#39;tax_deficit_x_non_haven&#39;]

        # --- Countries only in the TWZ data

        # We now focus on countries that are absent from the OECD data
        # NB: recall that we do not consider the Swedish CbCR
        twz_not_in_oecd = twz[~twz[&#39;Is parent in OECD data?&#39;].astype(bool)].copy()

        twz_not_in_oecd.drop(
            columns=[&#39;Profits in all tax havens&#39;, &#39;Profits in all tax havens (positive only)&#39;],
            inplace=True
        )

        # - Extrapolating the foreign non-haven tax deficit

        # We compute the imputation ratio with the method defined above
        imputation_ratio_non_haven = self.get_non_haven_imputation_ratio(minimum_ETR=minimum_ETR)

        # And we deduce the non-haven tax deficit of countries that are only found in TWZ data
        twz_not_in_oecd[&#39;tax_deficit_x_non_haven&#39;] = \
            twz_not_in_oecd[&#39;tax_deficit_x_tax_haven_TWZ&#39;] * imputation_ratio_non_haven

        # - Computing the domestic tax deficit

        # For countries that are only in TWZ data, we still need to compute their domestic tax deficit
        twz_domestic = self.twz_domestic.copy()

        # We only consider countries whose domestic ETR is stricly below the minimum ETR
        # (otherwise, there is no tax deficit to collect from domestic profits)
        twz_domestic = twz_domestic[twz_domestic[&#39;Domestic ETR&#39;] &lt; minimum_ETR].copy()

        # We compute the ETR differential
        twz_domestic[&#39;ETR_differential&#39;] = twz_domestic[&#39;Domestic ETR&#39;].map(lambda x: minimum_ETR - x)

        # And deduce the domestic tax deficit of each country
        twz_domestic[&#39;tax_deficit_x_domestic&#39;] = twz_domestic[&#39;ETR_differential&#39;] * twz_domestic[&#39;Domestic profits&#39;]

        # - Combining the different forms of tax deficit

        # We merge the two DataFrames to complement twz_not_in_oecd with domestic tax deficit results
        twz_not_in_oecd = twz_not_in_oecd.merge(
            twz_domestic[[&#39;Alpha-3 country code&#39;, &#39;tax_deficit_x_domestic&#39;]],
            how=&#39;left&#39;,
            on=&#39;Alpha-3 country code&#39;
        )

        # As we filtered out countries whose domestic ETR is stricly below the minimum ETR, some missing values
        # appear during the merge; we impute 0 for these as they do not have any domestic tax deficit to collect
        twz_not_in_oecd[&#39;tax_deficit_x_domestic&#39;] = twz_not_in_oecd[&#39;tax_deficit_x_domestic&#39;].fillna(0)

        # We deduce the total tax deficit for each country
        twz_not_in_oecd[&#39;tax_deficit&#39;] = twz_not_in_oecd[&#39;tax_deficit_x_tax_haven_TWZ&#39;] \
            + twz_not_in_oecd[&#39;tax_deficit_x_domestic&#39;] \
            + twz_not_in_oecd[&#39;tax_deficit_x_non_haven&#39;]

        # --- Merging the results of the two data sources

        # We need columns to match for the concatenation to operate smoothly
        twz_not_in_oecd.rename(
            columns={
                &#39;Country&#39;: &#39;Parent jurisdiction (whitespaces cleaned)&#39;,
                &#39;Alpha-3 country code&#39;: &#39;Parent jurisdiction (alpha-3 code)&#39;,
                &#39;tax_deficit_x_tax_haven_TWZ&#39;: &#39;tax_deficit_x_tax_haven&#39;
            },
            inplace=True
        )

        twz_not_in_oecd.drop(columns=[&#39;Is parent in OECD data?&#39;], inplace=True)

        # We exclude Sweden from the OECD-drawn results, as we do not consider its CbCR
        merged_df = merged_df[merged_df[&#39;Parent jurisdiction (alpha-3 code)&#39;] != &#39;SWE&#39;].copy()

        # We eventually concatenate the two DataFrames
        merged_df = pd.concat(
            [merged_df, twz_not_in_oecd],
            axis=0
        )

        # --- Extrapolations to 2021 EUR

        # We convert 2016 USD results in 2016 EUR and extraprolate them to 2021 EUR
        for column_name in merged_df.columns[2:]:
            merged_df[column_name] = merged_df[column_name] * self.USD_to_EUR_2016 * self.multiplier_2021

        # --- Managing the case where the minimum ETR is 20% or below for TWZ countries

        # As mentioned above and detailed in Appendix A, the imputation of the non-haven tax deficit of TWZ countries
        # follows a specific process whenever the chosen minimum ETR is of or below 20%
        if minimum_ETR &lt;= 0.2 and self.alternative_imputation:
            # We get the new multiplying factor from the method defined above
            multiplying_factor = self.get_alternative_non_haven_factor(minimum_ETR=minimum_ETR)

            # We compute all tax deficits at the reference rate (25% in the report)
            df = self.compute_all_tax_deficits(
                minimum_ETR=self.reference_rate_for_alternative_imputation
            )

            # We only consider countries that are absent from the OECD data, except Sweden as usual
            oecd_reporting_countries_but_SWE = self.oecd[
                self.oecd[&#39;Parent jurisdiction (alpha-3 code)&#39;] != &#39;SWE&#39;
            ][&#39;Parent jurisdiction (alpha-3 code)&#39;].unique()

            df = df[
                ~df[&#39;Parent jurisdiction (alpha-3 code)&#39;].isin(oecd_reporting_countries_but_SWE)
            ].copy()

            # For these countries, we multiply the non-haven tax deficit at the reference rate by the multiplying factor
            df[&#39;tax_deficit_x_non_haven_imputation&#39;] = df[&#39;tax_deficit_x_non_haven&#39;] * multiplying_factor

            # We save the results in a dictionary that will allow to map the DataFrame that we want to output in the end
            mapping = {}

            for _, row in df.iterrows():
                mapping[row[&#39;Parent jurisdiction (alpha-3 code)&#39;]] = row[&#39;tax_deficit_x_non_haven_imputation&#39;]

            # We create a new column in the to-be-output DataFrame which takes as value:
            # - the non-haven tax deficit estimated just above for TWZ countries
            # - 0 for OECD-reporting countries, which do not require this imputation
            merged_df[&#39;tax_deficit_x_non_haven_imputation&#39;] = merged_df[&#39;Parent jurisdiction (alpha-3 code)&#39;].map(
                lambda country_code: mapping.get(country_code, 0)
            )

            # We deduce the non-haven tax deficit of all countries
            merged_df[&#39;tax_deficit_x_non_haven&#39;] += merged_df[&#39;tax_deficit_x_non_haven_imputation&#39;]

            # And add this imputation also to the column that presents the total tax deficit of each country
            merged_df[&#39;tax_deficit&#39;] += merged_df[&#39;tax_deficit_x_non_haven_imputation&#39;]

            merged_df.drop(
                columns=[&#39;tax_deficit_x_non_haven_imputation&#39;],
                inplace=True
            )

        if CbCR_reporting_countries_only:
            merged_df = merged_df[
                merged_df[&#39;Parent jurisdiction (whitespaces cleaned)&#39;].isin(
                    self.oecd[&#39;Parent jurisdiction (whitespaces cleaned)&#39;].unique()
                )
            ].copy()

        return merged_df.reset_index(drop=True).copy()

    def combine_haven_tax_deficits(
        self,
        row,
        carve_outs=False,
        countries_replaced=None
    ):
        &#34;&#34;&#34;
        This function is used to compute the tax deficit of all in-sample headquarter countries in the multilateral im-
        plementation scenario.

        For parent countries that are in both the OECD and TWZ data, we have two different sources to compute their tax-
        haven-based tax deficit and we retain the highest of these two amounts.

        Besides, for parent countries in the OECD data that do not report a fully detailed country-by-country breakdown
        of the activity of their multinationals, we cannot distinguish their tax-haven and non-haven tax deficits. Quite
        arbitrarily in the Python code, we attribute everything to the non-haven tax deficit. In the Table A1 of the re-
        port, these specific cases are described with the &#34;Only foreign aggregate data&#34; column.
        &#34;&#34;&#34;
        if carve_outs and countries_replaced is None:
            raise Exception(
                &#39;Using this function under carve-outs requires to indicate a list of countries to replace.&#39;
            )

        if row[&#39;Parent jurisdiction (alpha-3 code)&#39;] not in (
            COUNTRIES_WITH_MINIMUM_REPORTING + COUNTRIES_WITH_CONTINENTAL_REPORTING
        ):
            if countries_replaced is None:

                if row[&#39;tax_deficit_x_tax_haven_TWZ&#39;] &gt; row[&#39;tax_deficit_x_tax_haven&#39;]:
                    self.countries_replaced.append(row[&#39;Parent jurisdiction (alpha-3 code)&#39;])
                    return row[&#39;tax_deficit_x_tax_haven_TWZ&#39;]

                else:
                    return row[&#39;tax_deficit_x_tax_haven&#39;]

            else:
                if (
                    row[&#39;tax_deficit_x_tax_haven_TWZ&#39;] &gt; row[&#39;tax_deficit_x_tax_haven&#39;]
                    and row[&#39;Parent jurisdiction (alpha-3 code)&#39;] in countries_replaced
                ):
                    self.countries_replaced.append(row[&#39;Parent jurisdiction (alpha-3 code)&#39;])
                    return row[&#39;tax_deficit_x_tax_haven_TWZ&#39;]

                else:
                    return row[&#39;tax_deficit_x_tax_haven&#39;]

        else:
            return 0

    def check_tax_deficit_computations(self, minimum_ETR=0.25):
        &#34;&#34;&#34;
        Taking the selected minimum ETR as input and relying on the compute_all_tax_deficits method defined above, this
        method outputs a DataFrame that can be compared with Table A1 of the report. For each country in OECD and/or TWZ
        data, it displays its total tax deficit and a breakdown into domestic, tax-haven-based and non-haven tax defi-
        cits. Figures are display in 2021 billion EUR.
        &#34;&#34;&#34;

        # We start from the output of the previously defined method
        df = self.compute_all_tax_deficits(minimum_ETR=minimum_ETR)

        # And convert numeric columns from 2021 EUR to 2021 billion EUR
        for column_name in df.columns[2:]:
            df[column_name] = df[column_name] / 10**9

        return df.copy()

    def get_total_tax_deficits(self, minimum_ETR=0.25):
        &#34;&#34;&#34;
        This method takes the selected minimum ETR as input and relies on the compute_all_tax_deficits, to output a Da-
        taFrame with (i) the total tax defict of each in-sample country in 2021 EUR and (ii) the sum of these tax defi-
        cits at the EU-27 and at the whole sample level. It can be considered as an intermediary step towards the fully
        formatted table displayed on the online simulator (section &#34;Multilateral implementation scenario&#34;).
        &#34;&#34;&#34;

        df = self.compute_all_tax_deficits(minimum_ETR=minimum_ETR)

        df = df[
            [&#39;Parent jurisdiction (whitespaces cleaned)&#39;, &#39;Parent jurisdiction (alpha-3 code)&#39;, &#39;tax_deficit&#39;]
        ]

        df.sort_values(
            by=&#39;Parent jurisdiction (whitespaces cleaned)&#39;,
            inplace=True
        )

        # We compute the sum of total tax deficits at the EU-27 level and for the whole sample
        total_eu = (df[&#39;Parent jurisdiction (alpha-3 code)&#39;].isin(eu_27_country_codes) * 1 * df[&#39;tax_deficit&#39;]).sum()
        total_whole_sample = df[&#39;tax_deficit&#39;].sum()

        # Possibly suboptimal process to add &#34;Total&#34; lines at the end of the DataFrame
        dict_df = df.to_dict()

        dict_df[df.columns[0]][len(df)] = &#39;Total - EU27&#39;
        dict_df[df.columns[1]][len(df)] = &#39;..&#39;
        dict_df[df.columns[2]][len(df)] = total_eu

        dict_df[df.columns[0]][len(df) + 1] = &#39;Total - Whole sample&#39;
        dict_df[df.columns[1]][len(df) + 1] = &#39;..&#39;
        dict_df[df.columns[2]][len(df) + 1] = total_whole_sample

        df = pd.DataFrame.from_dict(dict_df)

        return df.reset_index(drop=True)

    def check_appendix_A2(self):
        &#34;&#34;&#34;
        Relying on the get_total_tax_deficits method and on TWZ data on corporate income tax revenues, this method out-
        puts a DataFrame that can be compared with the first 4 columns of Table A2 in the report. For each in-sample
        country and at four different minimum ETRs (15%, 21%, 25% and 30% which are the four main cases considered in
        the report), the table presents estimated revenue gains as a percentage of currently corporate income taxes.
        &#34;&#34;&#34;

        # We need to have previously loaded and cleaned the TWZ data on corporate income tax revenues
        # (figures in the pre-loaded DataFrame are provided in 2016 USD)
        if self.twz_CIT is None:
            raise Exception(&#39;You first need to load clean data with the dedicated method and inplace=True.&#39;)

        # We compute total tax deficits, first at a 15% minimum ETR and in 2021 EUR
        df = self.get_total_tax_deficits(minimum_ETR=0.15)

        df.rename(columns={&#39;tax_deficit&#39;: &#39;tax_deficit_15&#39;}, inplace=True)

        # We merge the two DataFrames to combine information on collectible tax deficits and current CIT revenues
        merged_df = df.merge(
            self.twz_CIT,
            how=&#39;left&#39;,
            left_on=&#39;Parent jurisdiction (alpha-3 code)&#39;,
            right_on=&#39;Country (alpha-3 code)&#39;
        ).drop(columns=[&#39;Country&#39;, &#39;Country (alpha-3 code)&#39;])

        # We bring back the tax deficit estimated to 2016 USD (from 2021 EUR)
        merged_df[&#39;tax_deficit_15&#39;] /= (merged_df[&#39;CIT revenue&#39;] * self.multiplier_2021 * self.USD_to_EUR_2016 / 100)

        # For the 3 other rates considered in the output table
        for rate in [0.21, 0.25, 0.3]:
            # We compute total tax deficits at this rate
            df = self.get_total_tax_deficits(minimum_ETR=rate)

            # We add these results to the central DataFrame thanks to a merge operation
            merged_df = merged_df.merge(
                df,
                how=&#39;left&#39;,
                on=&#39;Parent jurisdiction (alpha-3 code)&#39;
            )

            # We impute the missing values produced by the merge
            merged_df[&#39;tax_deficit&#39;] = merged_df[&#39;tax_deficit&#39;].fillna(0)

            # We rename the newly-added tax deficit column
            merged_df.rename(
                columns={&#39;tax_deficit&#39;: f&#39;tax_deficit_{int(rate * 100)}&#39;},
                inplace=True
            )

            # And we bring it back to 2016 USD
            merged_df[f&#39;tax_deficit_{int(rate * 100)}&#39;] /= (
                merged_df[&#39;CIT revenue&#39;] * self.multiplier_2021 * self.USD_to_EUR_2016 / 100
            )

        # We want to also verify the EU-27 average and restrict the DataFrame to these countries
        eu_df = merged_df[merged_df[&#39;Parent jurisdiction (alpha-3 code)&#39;].isin(eu_27_country_codes)].copy()

        # This attribute stores the average EU-27 revenue gain estimate in % of current CIT revenues for each of the 4
        # minimum ETRs of interest (respectively 15.1%, 30.5%, 52.3% and 84.1% in the report)
        self.check = [
            (
                eu_df[f&#39;tax_deficit_{rate}&#39;] * eu_df[&#39;CIT revenue&#39;] / 100
            ).sum() / eu_df[&#39;CIT revenue&#39;].sum() for rate in [15, 21, 25, 30]
        ]

        # Coming back to the DataFrame with all in-sample countries, we only keep the relevant columns and output it
        merged_df = merged_df[
            [
                &#39;Parent jurisdiction (whitespaces cleaned)_x&#39;,
                &#39;tax_deficit_15&#39;, &#39;tax_deficit_21&#39;, &#39;tax_deficit_25&#39;, &#39;tax_deficit_30&#39;
            ]
        ].copy()

        # NB: in the current version of this method, the successive merges have a poor effect on the &#34;Total&#34; rows that
        # are included in the output of the get_total_tax_deficits method; this could easily be improved

        return merged_df.copy()

    def output_tax_deficits_formatted(self, minimum_ETR=0.25):
        &#34;&#34;&#34;
        This method is used in the &#34;app.py&#34; file, which underlies the Streamlit simulator. It is used to produce the
        table on the &#34;Multilateral implementation scenario&#34; page. It takes as input the selected minimum ETR and widely
        relies on the get_total_tax_deficits method defined above. It mostly consists in a series of formatting steps.
        &#34;&#34;&#34;

        # We build the unformatted results table thanks to the get_total_tax_deficits method
        df = self.get_total_tax_deficits(minimum_ETR=minimum_ETR)

        # We only want to include certain countries in the output table:
        # - all the EU-27 countries that are included in our sample (4 unfortunately missing for now)
        # - most of the OECD-reporting countries, excluding only Singapore and Bermuda

        # We first build the list of OECD-reporting countries, excluding Singapore and Bermuda
        oecd_reporting_countries = self.oecd[&#39;Parent jurisdiction (alpha-3 code)&#39;].unique()
        oecd_reporting_countries = [
            country_code for country_code in oecd_reporting_countries if country_code not in [&#39;SGP&#39;, &#39;BMU&#39;]
        ]

        # From this list, we build the relevant boolean indexing mask that corresponds to our filtering choice
        mask = np.logical_or(
            df[&#39;Parent jurisdiction (alpha-3 code)&#39;].isin(eu_27_country_codes),
            df[&#39;Parent jurisdiction (alpha-3 code)&#39;].isin(oecd_reporting_countries)
        )

        df = df[mask].copy()

        # We sort values by the name of the parent jurisdiction, in the alphabetical order
        df.sort_values(
            by=&#39;Parent jurisdiction (whitespaces cleaned)&#39;,
            inplace=True
        )

        df.reset_index(drop=True, inplace=True)

        # We convert 2021 EUR figures into 2021 million EUR ones
        df[&#39;tax_deficit&#39;] = df[&#39;tax_deficit&#39;] / 10**6

        # Again, the same possibly sub-optimal process to add the &#34;Total&#34; lines
        dict_df = df.to_dict()

        dict_df[df.columns[0]][len(df)] = &#39;Total - EU27&#39;
        dict_df[df.columns[1]][len(df)] = &#39;..&#39;
        dict_df[df.columns[2]][len(df)] = df[
            df[&#39;Parent jurisdiction (alpha-3 code)&#39;].isin(eu_27_country_codes)
        ][&#39;tax_deficit&#39;].sum()

        dict_df[df.columns[0]][len(df) + 1] = &#39;Total - Whole sample&#39;
        dict_df[df.columns[1]][len(df) + 1] = &#39;..&#39;
        dict_df[df.columns[2]][len(df) + 1] = df[&#39;tax_deficit&#39;].sum()

        df = pd.DataFrame.from_dict(dict_df)

        # We drop country codes
        df.drop(columns=[&#39;Parent jurisdiction (alpha-3 code)&#39;], inplace=True)

        # And we eventually reformat figures with a thousand separator and a 0-decimal rounding
        df[&#39;tax_deficit&#39;] = df[&#39;tax_deficit&#39;].map(&#39;{:,.0f}&#39;.format)

        # We rename columns
        df.rename(
            columns={
                &#39;Parent jurisdiction (whitespaces cleaned)&#39;: &#39;Headquarter country&#39;,
                &#39;tax_deficit&#39;: &#39;Collectible tax deficit (€m)&#39;
            },
            inplace=True
        )

        return df.copy()

    def compute_unilateral_scenario_gain(self, country, minimum_ETR=0.25):
        &#34;&#34;&#34;
        This method encapsulates most of the computations for the unilateral implementation scenario.

        It takes as input:

        - the name of the country assumed to unilaterally implement the tax deficit collection;

        - the minimum effective tax rate that it applies when collecting the full tax deficit of its multinationals and
        a part of the tax deficit of foreign multinationals, based on the location of their sales.

        The output of this method is a DataFrame organized as follows:

        - each row is a headquarter country whose tax deficit would be collected partly or entirely by the taxing coun-
        try (including the taxing country which collects 100% of the tax deficit of its multinationals);

        - there are two columns, with the name of the headquarter country considered and the tax deficit amount that
        could be collected from its multinationals by the taxing country.

        Figures are presented in 2021 EUR.

        Important disclaimer: for now, this method is not robust to variations in the country name, i.e. only country
        names as presented in the OECD CbCR data will generate a result. These are the country names that are proposed
        in the selectbox on the online simulator.

        The methogology behind these computations is described in much more details in Appendix B of the report.
        &#34;&#34;&#34;

        # We start from the total tax deficits of all countries which can be partly re-allocated to the taxing country
        tax_deficits = self.get_total_tax_deficits(minimum_ETR=minimum_ETR)

        # The OECD data provides the information of extra-group sales, needed to allocate foreign tax deficits
        oecd = self.oecd.copy()

        # We simply convert the name of the taxing country to the corresponding alpha-3 code
        taxing_country = country
        try:
            taxing_country_code = self.oecd[
                self.oecd[&#39;Parent jurisdiction (whitespaces cleaned)&#39;] == taxing_country
            ][&#39;Parent jurisdiction (alpha-3 code)&#39;].iloc[0]
        except:
            taxing_country_code = self.twz[
                self.twz[&#39;Country&#39;] == taxing_country
            ][&#39;Alpha-3 country code&#39;].iloc[0]

        # This list will store the allocation ratios (for each headquarter country, the share of its tax deficit that
        # can be collected by the taxing country) computed based on the location of extra-group sales
        attribution_ratios = []

        # We iterate over parent countries in the OECD data
        for country_code in tax_deficits[&#39;Parent jurisdiction (alpha-3 code)&#39;].values:

            # The taxing country collects 100% of the tax deficit of its own multinationals
            if country_code == taxing_country_code:
                attribution_ratios.append(1)

            # If the parent country is not the taxing country
            else:
                # We restrict the DataFrame to the CbCR of the considered parent country
                oecd_restricted = oecd[oecd[&#39;Parent jurisdiction (alpha-3 code)&#39;] == country_code].copy()

                # If the taxing country is not part of its partner jurisdictions, the attribution ratio is of 0
                if taxing_country_code not in oecd_restricted[&#39;Partner jurisdiction (alpha-3 code)&#39;].values:
                    attribution_ratios.append(0)

                else:
                    # We fetch extra-group sales registered in the taxing country
                    mask = (oecd_restricted[&#39;Partner jurisdiction (alpha-3 code)&#39;] == taxing_country_code)
                    sales_in_taxing_country = oecd_restricted[mask][&#39;Unrelated Party Revenues&#39;].iloc[0]

                    # We compute total extra-group sales
                    total_sales = oecd_restricted[&#39;Unrelated Party Revenues&#39;].sum()

                    # We append the resulting ratio to the list of attribution ratios
                    attribution_ratios.append(sales_in_taxing_country / total_sales)

        # We add this list to the DataFrame as a new column
        tax_deficits[&#39;Attribution ratios&#39;] = attribution_ratios

        # We deduce, for each headquarter country, the tax deficit that could be collected by the taxing country
        tax_deficits[f&#39;Collectible tax deficit for {taxing_country}&#39;] = \
            tax_deficits[&#39;tax_deficit&#39;] * tax_deficits[&#39;Attribution ratios&#39;]

        # We eliminate irrelevant columns
        tax_deficits.drop(
            columns=[
                &#39;Attribution ratios&#39;,
                &#39;tax_deficit&#39;,
                &#39;Parent jurisdiction (alpha-3 code)&#39;
            ],
            inplace=True
        )

        # We filter out rows for which the collectible tax deficit is 0
        tax_deficits = tax_deficits[tax_deficits[f&#39;Collectible tax deficit for {taxing_country}&#39;] &gt; 0].copy()

        # We sort values based on the resulting tax deficit, in descending order
        tax_deficits.sort_values(
            by=f&#39;Collectible tax deficit for {taxing_country}&#39;,
            ascending=False,
            inplace=True
        )

        # Because the OECD data only gather 26 headquarter countries, we need to make an assumption on the tax deficit
        # that could be collected from other parent countries, excluded from the 2016 version of the data

        # We therefore double the tax deficit collected from non-US foreign countries
        imputation = tax_deficits[
            ~tax_deficits[&#39;Parent jurisdiction (whitespaces cleaned)&#39;].isin([taxing_country, &#39;United States&#39;])
        ][f&#39;Collectible tax deficit for {taxing_country}&#39;].sum()

        # Except for Germany, for which we add back only half of the tax deficit collected from non-US foreign countries
        if taxing_country_code == &#39;DEU&#39;:
            imputation /= 2

        tax_deficits.reset_index(drop=True, inplace=True)

        # Again the same inelegant way of adding &#34;Total&#34; fields at the end of the DataFrame
        dict_df = tax_deficits.to_dict()

        dict_df[tax_deficits.columns[0]][len(tax_deficits)] = &#39;Others (imputation)&#39;
        dict_df[tax_deficits.columns[1]][len(tax_deficits)] = imputation

        dict_df[tax_deficits.columns[0]][len(tax_deficits) + 1] = &#39;Total&#39;
        dict_df[tax_deficits.columns[1]][len(tax_deficits) + 1] = (
            tax_deficits[tax_deficits.columns[1]].sum() + imputation
        )

        df = pd.DataFrame.from_dict(dict_df)

        return df.copy()

    def check_unilateral_scenario_gain_computations(self, minimum_ETR=0.25):
        &#34;&#34;&#34;
        Taking as input the selected minimum effective tax rate and relying on the compute_unilateral_scenario_gain,
        this method outputs a DataFrame that can be compared with the Table 3 of the report. For each country that is
        part of the EU-27 and/or included in the 2016 aggregated and anonymized CbCR data of the OECD, it shows the to-
        tal corporate tax revenue gain that could be drawn from the unilateral implementation of the tax deficit col-
        lection. It also provides a breakdown of this total between the tax deficit of the country&#39;s own multinationals,
        the amount that could be collected from US multinationals and revenues that could be collected from non-US ones.
        &#34;&#34;&#34;

        # We build the list of countries that we want to include in the output table
        country_list = self.get_total_tax_deficits()

        country_list = country_list[
            ~country_list[&#39;Parent jurisdiction (whitespaces cleaned)&#39;].isin([&#39;Total - EU27&#39;, &#39;Total - Whole sample&#39;])
        ].copy()

        country_list = list(country_list[&#39;Parent jurisdiction (whitespaces cleaned)&#39;].values)

        # We prepare the structure of the output first as a dictionary
        output = {
            &#39;Country&#39;: country_list,
            &#39;Own tax deficit&#39;: [],
            &#39;Collection of US tax deficit&#39;: [],
            &#39;Collection of non-US tax deficit&#39;: [],
            &#39;Imputation&#39;: [],
            &#39;Total&#39;: []
        }

        # We iterate over the list of relevant countries
        for country in country_list:

            # Using the method defined above, we output the table presenting the tax deficit that could be collected
            # from a unilateral implementation of the tax deficit collection by the considered country and its origin
            df = self.compute_unilateral_scenario_gain(
                country=country,
                minimum_ETR=minimum_ETR
            )

            column_name = f&#39;Collectible tax deficit for {country}&#39;

            if country in df[&#39;Parent jurisdiction (whitespaces cleaned)&#39;].unique():
                # We fetch the tax deficit that could be collected from the country&#39;s own multinationals
                output[&#39;Own tax deficit&#39;].append(
                    df[df[&#39;Parent jurisdiction (whitespaces cleaned)&#39;] == country][column_name].iloc[0]
                )

            else:
                output[&#39;Own tax deficit&#39;].append(0)

            # We fetch the tax deficit that could be collected from US multinationals
            if &#39;United States&#39; in df[&#39;Parent jurisdiction (whitespaces cleaned)&#39;].values:
                output[&#39;Collection of US tax deficit&#39;].append(
                    df[df[&#39;Parent jurisdiction (whitespaces cleaned)&#39;] == &#39;United States&#39;][column_name].iloc[0]
                )
            else:
                output[&#39;Collection of US tax deficit&#39;].append(0)

            # We fetch the tax deficit that was imputed following our methodology
            output[&#39;Imputation&#39;].append(
                df[df[&#39;Parent jurisdiction (whitespaces cleaned)&#39;] == &#39;Others (imputation)&#39;][column_name].iloc[0]
            )

            # We fetch the total tax deficit
            output[&#39;Total&#39;].append(
                df[df[&#39;Parent jurisdiction (whitespaces cleaned)&#39;] == &#39;Total&#39;][column_name].iloc[0]
            )

            # And finally, we sum the tax deficits collected from foreign non-US multinationals
            output[&#39;Collection of non-US tax deficit&#39;].append(
                df[
                    ~df[&#39;Parent jurisdiction (whitespaces cleaned)&#39;].isin(
                        [
                            country, &#39;United States&#39;, &#39;Total&#39;, &#39;Others (imputation)&#39;
                        ]
                    )
                ][column_name].sum()
            )

        # We convert the dictionary into a DataFrame
        df = pd.DataFrame.from_dict(output)

        # We sum the imputation and the tax deficit collected from foreign, non-US multinationals to obtain the uprated
        # figures that correspond to the &#34;Other foreign firms&#34; column of Table 3 in the report
        df[&#39;Collection of non-US tax deficit (uprated with imputation)&#39;] = \
            df[&#39;Imputation&#39;] + df[&#39;Collection of non-US tax deficit&#39;]

        # We convert the results from 2021 EUR into 2021 billion EUR
        for column_name in df.columns[1:]:
            df[column_name] /= 10**9

        return df.copy()

    def output_unilateral_scenario_gain_formatted(self, country, minimum_ETR=0.25):
        &#34;&#34;&#34;
        This method is used in the &#34;app.py&#34; file, which lies behind the Streamlit simulator. It allows to produce the
        table presented on the &#34;Unilateral implementation scenario&#34; page. It takes as input the selected minimum ETR and
        the name of the country assumed to unilaterally implement the tax deficit collection. Then, it widely relies on
        the compute_unilateral_scenario_gain method defined above and mostly consists in a series of formatting steps to
        make the table more readable and understandable.
        &#34;&#34;&#34;

        # We compute the gains from the unilateral implementation of the tax deficit collection for the taxing country
        df = self.compute_unilateral_scenario_gain(
            country=country,
            minimum_ETR=minimum_ETR
        )

        # We convert the numeric outputs into 2021 million EUR
        df[f&#39;Collectible tax deficit for {country}&#39;] = df[f&#39;Collectible tax deficit for {country}&#39;] / 10**6

        # We reformat figures with two decimals and a thousand separator
        df[f&#39;Collectible tax deficit for {country}&#39;] = \
            df[f&#39;Collectible tax deficit for {country}&#39;].map(&#39;{:,.2f}&#39;.format)

        # We rename columns in accordance
        df.rename(
            columns={
                f&#39;Collectible tax deficit for {country}&#39;: f&#39;Collectible tax deficit for {country} (€m)&#39;,
                &#39;Parent jurisdiction (whitespaces cleaned)&#39;: &#39;Headquarter country&#39;
            },
            inplace=True
        )

        return df.copy()

    def compute_intermediary_scenario_gain(self, minimum_ETR=0.25):
        &#34;&#34;&#34;
        This method encapsulates the computations used to estimate the corporate tax revenue gains of EU countries,
        should the European Union implement the tax deficit collection as a block. This corresponds therefore to the
        partial cooperation scenario described in the report.

        Taking as input the selected minimum effective tax rate, this method outputs a DataFrame that presents for each
        in-sample EU-27 country:

        - the corporate tax revenue gains that could be collected from its own multinationals (&#34;tax_deficit&#34; column);
        - the tax deficit that could be collected from foreign, non-EU multinationals (&#34;From foreign MNEs&#34; column);
        - and the resulting total corporate tax revenue gain.

        All figures are output in 2021 million EUR.

        The three lines at the end of the DataFrame are a bit specific. Some OECD-reporting contries do not provide a
        perfectly detailed country-by-country report and for these, the &#34;Other Europe&#34; and &#34;Europe&#34; fields are assumed
        to be related to EU countries and are included in the total collectible tax deficit. The final line presents
        this total.

        The methogology behind these computations is described in much more details in Appendix C of the report.
        &#34;&#34;&#34;

        # We start by computing the total tax deficits of all in-sample countries (those of the multilateral scenario)
        tax_deficits = self.get_total_tax_deficits(minimum_ETR=minimum_ETR)

        oecd = self.oecd.copy()

        # We extract the total tax deficit for the EU-27
        eu_27_tax_deficit = tax_deficits[
            tax_deficits[&#39;Parent jurisdiction (whitespaces cleaned)&#39;] == &#39;Total - EU27&#39;
        ][&#39;tax_deficit&#39;].iloc[0]

        # And we store in a separate DataFrame the tax deficits of EU-27 countries
        eu_27_tax_deficits = tax_deficits[
            tax_deficits[&#39;Parent jurisdiction (alpha-3 code)&#39;].isin(
                eu_27_country_codes
            )
        ].copy()

        # We focus only on a few non-EU countries, defined when the TaxDeficitCalculator object is instantiated
        tax_deficits = tax_deficits[
            tax_deficits[&#39;Parent jurisdiction (alpha-3 code)&#39;].isin(
                self.country_list_intermediary_scenario
            )
        ].copy()

        # We store the results in a dictionary, which we will map upon the eu_27_tax_deficits DataFrame
        additional_revenue_gains = {}

        # We iterate over EU-27 countries and compute for eacht he tax deficit collected from non-EU multinationals
        for eu_country in eu_27_country_codes:

            td_df = tax_deficits.copy()

            # This dictionary will store the attribution ratios based on extra-group sales to be mapped upon td_df
            attribution_ratios = {}

            # We iterate over non-EU countries in our list
            for country in self.country_list_intermediary_scenario:

                oecd_restricted = oecd[oecd[&#39;Parent jurisdiction (alpha-3 code)&#39;] == country].copy()

                # We fetch the extra-group sales registered by the non-EU country&#39;s multinationals in the EU-27 country
                # (defaults to 0 if the EU-27 country is not among the partners of the non-EU country)
                sales_in_eu_country = oecd_restricted[
                    oecd_restricted[&#39;Partner jurisdiction (alpha-3 code)&#39;] == eu_country
                ][&#39;Unrelated Party Revenues&#39;].sum()

                # We compute the total extra-group sales registered by the non-EU country&#39;s multinationals worldwide
                total_sales = oecd_restricted[&#39;Unrelated Party Revenues&#39;].sum()

                # We deduce the share of the non-EU country&#39;s tax deficit attributable to the EU-27 country
                attribution_ratios[country] = sales_in_eu_country / total_sales

            # We map the attribution_ratios dictionary upon the td_df DataFrame
            td_df[&#39;Attribution ratios&#39;] = td_df[&#39;Parent jurisdiction (alpha-3 code)&#39;].map(attribution_ratios)

            # We deduce, for each non-EU country, the amount of its tax deficit that is collected by the EU-27 country
            td_df[&#39;Collectible tax deficit&#39;] = td_df[&#39;Attribution ratios&#39;] * td_df[&#39;tax_deficit&#39;]

            # We sum all these and multiply the total by 2 to estimate the total tax deficit that the EU-27 country
            # could collect from non-EU multinationals
            additional_revenue_gains[eu_country] = td_df[&#39;Collectible tax deficit&#39;].sum() * 2

            # NB: the multiplication by 2 corresponds to the imputation strategy defined in Appendix C of the report

        # We map the resulting dictionary upon the eu_27_tax_deficits DataFrame
        eu_27_tax_deficits[&#39;From foreign MNEs&#39;] = eu_27_tax_deficits[&#39;Parent jurisdiction (alpha-3 code)&#39;].map(
            additional_revenue_gains
        )

        # And deduce total corporate tax revenue gains from such a scenario for all EU-27 countries
        eu_27_tax_deficits[&#39;Total&#39;] = (
            eu_27_tax_deficits[&#39;tax_deficit&#39;] + eu_27_tax_deficits[&#39;From foreign MNEs&#39;]
        )

        # We operate a similar process for &#34;Europe&#34; and &#34;Other Europe&#34; field
        additional_revenue_gains = {}

        for aggregate in [&#39;Europe&#39;, &#39;Other Europe&#39;]:

            td_df = tax_deficits.copy()

            attribution_ratios = {}

            for country in self.country_list_intermediary_scenario:

                # We do not consider the &#34;Other Europe&#34; field in the US CbCR as it probably does not correspond to
                # activities operated in EU-27 countries (sufficient country-by-country breakdown to exclude this)
                if country == &#39;USA&#39;:
                    attribution_ratios[country] = 0

                    continue

                oecd_restricted = oecd[oecd[&#39;Parent jurisdiction (alpha-3 code)&#39;] == country].copy()

                sales_in_europe_or_other_europe = oecd_restricted[
                    oecd_restricted[&#39;Partner jurisdiction (whitespaces cleaned)&#39;] == aggregate
                ][&#39;Unrelated Party Revenues&#39;].sum()

                total_sales = oecd_restricted[&#39;Unrelated Party Revenues&#39;].sum()

                attribution_ratios[country] = sales_in_europe_or_other_europe / total_sales

            td_df[&#39;Attribution ratios&#39;] = td_df[&#39;Parent jurisdiction (alpha-3 code)&#39;].map(attribution_ratios)

            td_df[&#39;Collectible tax deficit&#39;] = td_df[&#39;Attribution ratios&#39;] * td_df[&#39;tax_deficit&#39;]

            additional_revenue_gains[aggregate] = td_df[&#39;Collectible tax deficit&#39;].sum()

        # We drop unnecessary columns
        eu_27_tax_deficits.drop(
            columns=[&#39;Parent jurisdiction (alpha-3 code)&#39;],
            inplace=True
        )

        # And we operate very inelegant transformations of the DataFrame to add the &#34;Other Europe&#34;, &#34;Europe&#34; and &#34;Total&#34;
        # fields at the bottom of the DataFrame
        eu_27_tax_deficits.reset_index(drop=True, inplace=True)

        dict_df = eu_27_tax_deficits.to_dict()

        dict_df[eu_27_tax_deficits.columns[0]][len(eu_27_tax_deficits)] = &#39;Other Europe&#39;
        dict_df[eu_27_tax_deficits.columns[1]][len(eu_27_tax_deficits)] = 0
        dict_df[eu_27_tax_deficits.columns[2]][len(eu_27_tax_deficits)] = additional_revenue_gains[&#39;Other Europe&#39;]
        dict_df[eu_27_tax_deficits.columns[3]][len(eu_27_tax_deficits)] = additional_revenue_gains[&#39;Other Europe&#39;]

        dict_df[eu_27_tax_deficits.columns[0]][len(eu_27_tax_deficits) + 1] = &#39;Europe&#39;
        dict_df[eu_27_tax_deficits.columns[1]][len(eu_27_tax_deficits) + 1] = 0
        dict_df[eu_27_tax_deficits.columns[2]][len(eu_27_tax_deficits) + 1] = additional_revenue_gains[&#39;Europe&#39;]
        dict_df[eu_27_tax_deficits.columns[3]][len(eu_27_tax_deficits) + 1] = additional_revenue_gains[&#39;Europe&#39;]

        # Here we compute total corporate tax revenue gains for EU-27 countries
        # NB: We have not multiplied the &#34;Other Europe&#34; and &#34;Europe&#34; fields by 2 (no imputation for these)
        total_additional_revenue_gain = eu_27_tax_deficits[&#39;From foreign MNEs&#39;].sum() \
            + additional_revenue_gains[&#39;Europe&#39;] \
            + additional_revenue_gains[&#39;Other Europe&#39;]

        dict_df[eu_27_tax_deficits.columns[0]][len(eu_27_tax_deficits) + 2] = &#39;Total&#39;
        dict_df[eu_27_tax_deficits.columns[1]][len(eu_27_tax_deficits) + 2] = eu_27_tax_deficit
        dict_df[eu_27_tax_deficits.columns[2]][len(eu_27_tax_deficits) + 2] = total_additional_revenue_gain
        dict_df[eu_27_tax_deficits.columns[3]][len(eu_27_tax_deficits) + 2] = \
            eu_27_tax_deficit + total_additional_revenue_gain

        eu_27_tax_deficits = pd.DataFrame.from_dict(dict_df)

        # We convert 2021 EUR figures into 2021 billion EUR
        for column_name in eu_27_tax_deficits.columns[1:]:
            eu_27_tax_deficits[column_name] /= 10**6

        return eu_27_tax_deficits.copy()

    def output_intermediary_scenario_gain_formatted(self, minimum_ETR=0.25):
        &#34;&#34;&#34;
        This method is used in the &#34;app.py&#34; file, which lies behind the Streamlit simulator. It allows to produce the
        table presented on the &#34;Partial cooperation scenario&#34; page. It takes as input the selected minimum ETR and then,
        widely relies on the compute_intermediary_scenario_gain method defined above. It mostly consists in a series of
        formatting steps to make the table more readable and understandable.
        &#34;&#34;&#34;

        # We compute corporate tax revenue gains from the partial cooperation scenario
        df = self.compute_intermediary_scenario_gain(minimum_ETR=minimum_ETR)

        # We eliminate irrelevant columns
        df.drop(columns=[&#39;tax_deficit&#39;, &#39;From foreign MNEs&#39;], inplace=True)

        # We reformat figures with a thousand separator and a 0-decimal rounding
        df[&#39;Total&#39;] = df[&#39;Total&#39;].map(&#39;{:,.0f}&#39;.format)

        # We rename columns to make them more explicit
        df.rename(
            columns={
                &#39;Parent jurisdiction (whitespaces cleaned)&#39;: &#39;Taxing country&#39;,
                &#39;Total&#39;: &#39;Collectible tax deficit (€m)&#39;
            },
            inplace=True
        )

        # We add quotation marks to the &#34;Europe&#34; and &#34;Other Europe&#34; fields
        df[&#39;Taxing country&#39;] = df[&#39;Taxing country&#39;].map(
            lambda x: x if x not in [&#39;Europe&#39;, &#39;Other Europe&#39;] else f&#39;&#34;{x}&#34;&#39;
        )

        return df.copy()

    def assess_carve_out_impact(self, minimum_ETR=0.25):
        &#34;&#34;&#34;
        This function takes as input a minimum effective tax rate (which defaults to 25%) and outputs a DataFrame
        showing, for each in-sample country (EU and/or CbCR-reporting countries):

        - the tax deficit that it could collect by imposing this minimum ETR on the profits of its multinationals;
        - the split between domestic, tax haven and non-haven tax deficits;
        - and the same amounts with carve-outs being applied.

        Carve-outs are applied with the parameters (carve-out rate, use of the full value of tangible assets or of de-
        preciation expenses only and exclusion of inventories or not) that are defined when instantiating the TaxDefi-
        citCalculator object.
        &#34;&#34;&#34;

        # If carve-out parameters have not been indicated, we cannot run the computations
        if self.carve_out_rate is None or self.depreciation_only is None or self.exclude_inventories is None:
            raise Exception(
                &#39;If you want to simulate substance-based carve-outs, you need to indicate all the parameters.&#39;
            )

        # We instantiate a TaxDeficitCalculator object with carve-outs
        calculator = TaxDeficitCalculator(
            carve_outs=True,
            carve_out_rate=self.carve_out_rate,
            depreciation_only=self.depreciation_only,
            exclude_inventories=self.exclude_inventories
        )

        # We load the data
        calculator.load_clean_data()

        # And deduce total tax deficits and their split, with carve-outs being applied
        carve_outs = calculator.compute_all_tax_deficits(
            CbCR_reporting_countries_only=False,
            minimum_ETR=minimum_ETR
        )

        # We instantiate a TaxDeficitCalculator object without carve-outs
        calculator_no_carve_out = TaxDeficitCalculator()

        # We load the data
        calculator_no_carve_out.load_clean_data()

        # And deduce total tax deficits and their split, without any carve-out being applied
        no_carve_outs = calculator_no_carve_out.compute_all_tax_deficits(
            CbCR_reporting_countries_only=False,
            minimum_ETR=minimum_ETR
        )

        # We merge the two DataFrames
        carve_outs_impact = carve_outs.merge(
            no_carve_outs,
            how=&#39;inner&#39;,
            on=[
                &#39;Parent jurisdiction (whitespaces cleaned)&#39;,
                &#39;Parent jurisdiction (alpha-3 code)&#39;
            ]
        ).rename(
            columns={
                &#39;tax_deficit_x&#39;: &#39;TD_with_carve_outs&#39;,
                &#39;tax_deficit_y&#39;: &#39;TD_no_carve_outs&#39;,
                &#39;tax_deficit_x_domestic_x&#39;: &#39;domestic_TD_with_carve_outs&#39;,
                &#39;tax_deficit_x_domestic_y&#39;: &#39;domestic_TD_no_carve_outs&#39;,
                &#39;tax_deficit_x_non_haven_x&#39;: &#39;non_haven_TD_with_carve_outs&#39;,
                &#39;tax_deficit_x_non_haven_y&#39;: &#39;non_haven_TD_no_carve_outs&#39;,
                &#39;tax_deficit_x_tax_haven_x&#39;: &#39;tax_haven_TD_with_carve_outs&#39;,
                &#39;tax_deficit_x_tax_haven_y&#39;: &#39;tax_haven_TD_no_carve_outs&#39;
            }
        )

        # We only show EU and/or CbCR-reporting countries
        cbcr_reporting_countries = list(self.oecd[&#39;Parent jurisdiction (alpha-3 code)&#39;].unique())

        mask_eu = carve_outs_impact[&#39;Parent jurisdiction (alpha-3 code)&#39;].isin(eu_27_country_codes)
        mask_cbcr = carve_outs_impact[&#39;Parent jurisdiction (alpha-3 code)&#39;].isin(cbcr_reporting_countries)

        # This condition is encapsulated in this boolean indexing mask
        mask = np.logical_or(mask_eu, mask_cbcr)

        # We add two useful indicator variables
        carve_outs_impact[&#39;IS_EU&#39;] = mask_eu * 1
        carve_outs_impact[&#39;REPORTS_CbCR&#39;] = mask_cbcr * 1

        # And restrict the DataFrame to relevant countries
        restricted_df = carve_outs_impact[mask].copy()

        # We finalise the formatting of the table
        restricted_df.sort_values(
            by=[&#39;IS_EU&#39;, &#39;Parent jurisdiction (alpha-3 code)&#39;],
            ascending=[False, True],
            inplace=True
        )

        columns = [
            &#39;Parent jurisdiction (whitespaces cleaned)&#39;, &#39;TD_with_carve_outs&#39;, &#39;TD_no_carve_outs&#39;,
            &#39;domestic_TD_with_carve_outs&#39;, &#39;domestic_TD_no_carve_outs&#39;, &#39;non_haven_TD_with_carve_outs&#39;,
            &#39;non_haven_TD_no_carve_outs&#39;, &#39;tax_haven_TD_with_carve_outs&#39;, &#39;tax_haven_TD_no_carve_outs&#39;,
            &#39;IS_EU&#39;, &#39;REPORTS_CbCR&#39;
        ]

        return restricted_df[columns].copy()

    def get_carve_outs_table(
        self,
        TWZ_countries_methodology,
        depreciation_only, exclude_inventories,
        carve_out_rate=0.05
    ):
        &#34;&#34;&#34;
        This function takes as input:

        - the methodology to use to estimate the post-carve-out revenue gains of TWZ countries;

        - a boolean, &#34;depreciation_only&#34;, indicating whether to restrict the tangible assets component of substance-
        based carve-outs to a share of depreciation expenses;

        - a boolean, &#34;exlude_inventories&#34;, indicating whether to exlude inventories from tangible assets or not;

        - the carve-out rate to use (which defaults to 5%).

        It returns a DataFrame that shows, for the 15% and 25% minimum rates and for each in-sample country, the estima-
        ted revenue gains from a global minimum tax without and with carve-outs being applied.
        &#34;&#34;&#34;

        # We need to have previously loaded and cleaned the OECD data
        if self.oecd is None:
            raise Exception(&#39;You first need to load clean data with the dedicated method and inplace=True.&#39;)

        # The &#34;TWZ_countries_methodology&#34; argument can only take a few string values
        if TWZ_countries_methodology not in [&#39;initial&#39;, &#39;new&#39;]:
            raise Exception(&#39;The &#34;TWZ_countries_methodology&#34; argument only accepts two values: &#34;initial&#34; or &#34;new&#34;.&#39;)

        # Computing tax deficits without substance-based carve-outs
        calculator = TaxDeficitCalculator()

        calculator.load_clean_data()

        td_25 = calculator.get_total_tax_deficits(minimum_ETR=0.25).iloc[:-2, :]
        td_15 = calculator.get_total_tax_deficits(minimum_ETR=0.15).iloc[:-2, :]

        # We merge the resulting DataFrames for the 15% and 25% minimum rates
        merged_df = td_25.merge(
            td_15[[&#39;Parent jurisdiction (alpha-3 code)&#39;, &#39;tax_deficit&#39;]],
            how=&#39;left&#39;,
            on=&#39;Parent jurisdiction (alpha-3 code)&#39;
        )

        merged_df[&#39;tax_deficit_y&#39;] = merged_df[&#39;tax_deficit_y&#39;].fillna(0)

        merged_df.rename(
            columns={
                &#39;tax_deficit_x&#39;: &#39;tax_deficit_25_no_carve_out&#39;,
                &#39;tax_deficit_y&#39;: &#39;tax_deficit_15_no_carve_out&#39;
            },
            inplace=True
        )

        # Computing corresponding tax deficits with substance-based carve-outs
        calculator = TaxDeficitCalculator(
            carve_outs=True, carve_out_rate=carve_out_rate,
            depreciation_only=depreciation_only, exclude_inventories=exclude_inventories
        )

        calculator.load_clean_data()

        td_25 = calculator.get_total_tax_deficits(minimum_ETR=0.25).iloc[:-2]
        td_15 = calculator.get_total_tax_deficits(minimum_ETR=0.15).iloc[:-2]

        # We merge the DataFrame obtained for the 25% minimum rate
        merged_df = merged_df.merge(
            td_25[[&#39;Parent jurisdiction (alpha-3 code)&#39;, &#39;tax_deficit&#39;]],
            how=&#39;left&#39;,
            on=&#39;Parent jurisdiction (alpha-3 code)&#39;
        )

        merged_df.rename(
            columns={
                &#39;tax_deficit&#39;: &#39;tax_deficit_25_with_carve_out&#39;
            },
            inplace=True
        )

        # We merge the DataFrame obtained for the 15% minimum rate
        merged_df = merged_df.merge(
            td_15[[&#39;Parent jurisdiction (alpha-3 code)&#39;, &#39;tax_deficit&#39;]],
            how=&#39;left&#39;,
            on=&#39;Parent jurisdiction (alpha-3 code)&#39;
        )

        merged_df[&#39;tax_deficit&#39;] = merged_df[&#39;tax_deficit&#39;].fillna(0)

        merged_df.rename(
            columns={
                &#39;tax_deficit&#39;: &#39;tax_deficit_15_with_carve_out&#39;
            },
            inplace=True
        )

        # We only show EU and/or CbCR-reporting countries
        cbcr_reporting_countries = list(self.oecd[&#39;Parent jurisdiction (alpha-3 code)&#39;].unique())

        mask_eu = merged_df[&#39;Parent jurisdiction (alpha-3 code)&#39;].isin(eu_27_country_codes)
        mask_cbcr = merged_df[&#39;Parent jurisdiction (alpha-3 code)&#39;].isin(cbcr_reporting_countries)

        # This condition is encapsulated in this boolean indexing mask
        mask = np.logical_or(mask_eu, mask_cbcr)

        # We add two useful indicator variables
        merged_df[&#39;IS_EU&#39;] = mask_eu * 1
        merged_df[&#39;REPORTS_CbCR&#39;] = mask_cbcr * 1

        # And we restrict the DataFrame to relevant countries
        restricted_df = merged_df[mask].copy()

        # We finalise the reformatting of the DataFrame
        restricted_df.sort_values(
            by=[&#39;IS_EU&#39;, &#39;Parent jurisdiction (alpha-3 code)&#39;],
            ascending=[False, True],
            inplace=True
        )

        if TWZ_countries_methodology == &#39;initial&#39;:
            # If we have opted for the &#34;initial&#34; methodology for TWZ countries, we can simply return the DataFrame as is
            return restricted_df.copy()

        else:
            # If we have chosen the &#34;new&#34; methodology, we have a bit more work!

            # We create a temporary copy of the DataFrame, restricted to CbCR-reporting countries (excluding Sweden)
            temp = restricted_df[restricted_df[&#39;REPORTS_CbCR&#39;] == 1].copy()
            temp = temp[temp[&#39;Parent jurisdiction (alpha-3 code)&#39;] != &#39;SWE&#39;].copy()

            # We deduce the average reduction factors to apply to the collectible tax deficits of TWZ countries
            self.imputation_15 = temp[&#39;tax_deficit_15_with_carve_out&#39;].sum() / temp[&#39;tax_deficit_15_no_carve_out&#39;].sum()
            self.imputation_25 = temp[&#39;tax_deficit_25_with_carve_out&#39;].sum() / temp[&#39;tax_deficit_25_no_carve_out&#39;].sum()

            # We apply the two downgrade factors to tax deficits without carve-outs
            restricted_df[&#39;tax_deficit_15_with_carve_out&#39;] = restricted_df.apply(
                (
                    lambda row: row[&#39;tax_deficit_15_no_carve_out&#39;] * self.imputation_15 if row[&#39;REPORTS_CbCR&#39;] == 0 or
                    row[&#39;Parent jurisdiction (alpha-3 code)&#39;] == &#39;SWE&#39; else row[&#39;tax_deficit_15_with_carve_out&#39;]
                ),
                axis=1
            )

            restricted_df[&#39;tax_deficit_25_with_carve_out&#39;] = restricted_df.apply(
                (
                    lambda row: row[&#39;tax_deficit_25_no_carve_out&#39;] * self.imputation_25 if row[&#39;REPORTS_CbCR&#39;] == 0 or
                    row[&#39;Parent jurisdiction (alpha-3 code)&#39;] == &#39;SWE&#39; else row[&#39;tax_deficit_25_with_carve_out&#39;]
                ),
                axis=1
            )

            # And we return the adjusted DataFrame
            return restricted_df.copy()

    def get_carve_outs_table_2(
        self,
        exclude_inventories, depreciation_only,
        carve_out_rate=0.05,
        output_Excel=False
    ):
        &#34;&#34;&#34;
        This function takes as input:

        - a boolean, &#34;depreciation_only&#34;, indicating whether to restrict the tangible assets component of substance-
        based carve-outs to a share of depreciation expenses;

        - a boolean, &#34;exlude_inventories&#34;, indicating whether to exlude inventories from tangible assets or not;

        - the carve-out rate to use (which defaults to 5%).

        It returns a DataFrame that shows, for the different minimum effective tax rates and for each in-sample country,
        the estimated impact of substance-based carve-outs. The change is expressed as a percentage of revenue gain es-
        timates without substance-based carve-outs.
        &#34;&#34;&#34;

        # The &#34;get_carve_outs_table&#34; method provides the required information for two minimum ETRs, 15% and 25%
        # This will serve as a central DataFrame to which we will add the 21% and 30% columns
        df = self.get_carve_outs_table(
            TWZ_countries_methodology=&#39;initial&#39;,
            exclude_inventories=exclude_inventories, depreciation_only=depreciation_only,
            carve_out_rate=carve_out_rate
        )

        # Computing tax deficits without substance-based carve-outs
        calculator = TaxDeficitCalculator()

        calculator.load_clean_data()

        td_21 = calculator.get_total_tax_deficits(minimum_ETR=0.21).iloc[:-2, :]
        td_30 = calculator.get_total_tax_deficits(minimum_ETR=0.3).iloc[:-2, :]

        # We add the 21% tax deficit to the central DataFrame
        merged_df = df.merge(
            td_21[[&#39;Parent jurisdiction (alpha-3 code)&#39;, &#39;tax_deficit&#39;]],
            how=&#39;left&#39;,
            on=&#39;Parent jurisdiction (alpha-3 code)&#39;
        )

        merged_df[&#39;tax_deficit&#39;] = merged_df[&#39;tax_deficit&#39;].fillna(0)

        # We add the 30% tax deficit to the central DataFrame
        merged_df = merged_df.merge(
            td_30[[&#39;Parent jurisdiction (alpha-3 code)&#39;, &#39;tax_deficit&#39;]],
            how=&#39;left&#39;,
            on=&#39;Parent jurisdiction (alpha-3 code)&#39;
        )

        merged_df[&#39;tax_deficit_y&#39;] = merged_df[&#39;tax_deficit_y&#39;].fillna(0)

        merged_df.rename(
            columns={
                &#39;tax_deficit_x&#39;: &#39;tax_deficit_21_no_carve_out&#39;,
                &#39;tax_deficit_y&#39;: &#39;tax_deficit_30_no_carve_out&#39;
            },
            inplace=True
        )

        # Computing corresponding tax deficits with substance-based carve-outs
        calculator = TaxDeficitCalculator(
            carve_outs=True,
            carve_out_rate=carve_out_rate,
            depreciation_only=depreciation_only,
            exclude_inventories=exclude_inventories
        )

        calculator.load_clean_data()

        td_21 = calculator.get_total_tax_deficits(minimum_ETR=0.21).iloc[:-2]
        td_30 = calculator.get_total_tax_deficits(minimum_ETR=0.3).iloc[:-2]

        # We add the 21% tax deficit with carve-outs to the central DataFrame
        merged_df = merged_df.merge(
            td_21[[&#39;Parent jurisdiction (alpha-3 code)&#39;, &#39;tax_deficit&#39;]],
            how=&#39;left&#39;,
            on=&#39;Parent jurisdiction (alpha-3 code)&#39;
        )

        merged_df[&#39;tax_deficit&#39;] = merged_df[&#39;tax_deficit&#39;].fillna(0)

        merged_df.rename(
            columns={
                &#39;tax_deficit&#39;: &#39;tax_deficit_21_with_carve_out&#39;
            },
            inplace=True
        )

        # We add the 30% tax deficit with carve-outs to the central DataFrame
        merged_df = merged_df.merge(
            td_30[[&#39;Parent jurisdiction (alpha-3 code)&#39;, &#39;tax_deficit&#39;]],
            how=&#39;left&#39;,
            on=&#39;Parent jurisdiction (alpha-3 code)&#39;
        )

        merged_df[&#39;tax_deficit&#39;] = merged_df[&#39;tax_deficit&#39;].fillna(0)

        merged_df.rename(
            columns={
                &#39;tax_deficit&#39;: &#39;tax_deficit_30_with_carve_out&#39;
            },
            inplace=True
        )

        # We have the tax deficit absolute amounts with and without carve-outs at 15%, 21%, 25% and 30% minimum rates
        # But we want to display the changes due to carve-outs, as a % of the no-carve-out tax deficit

        # We store the names of the 4 columns that we are going to add to the central DataFrame
        new_columns = []

        # We iterate over the 4 minimum rates
        for minimum_rate in [15, 21, 25, 30]:
            column_name_no_carve_out = f&#39;tax_deficit_{minimum_rate}_no_carve_out&#39;
            column_name_with_carve_out = f&#39;tax_deficit_{minimum_rate}_with_carve_out&#39;

            # We are going to add a new column that provides the % reduction due to carve-outs at the rate considered
            new_column_name = f&#39;reduction_at_{minimum_rate}_minimum_rate&#39;

            # We make the corresponding computation
            merged_df[new_column_name] = (
                (merged_df[column_name_with_carve_out] - merged_df[column_name_no_carve_out]) /
                merged_df[column_name_no_carve_out]
            ) * 100

            new_columns.append(new_column_name)

        if output_Excel:
            with pd.ExcelWriter(&#39;/Users/Paul-Emmanuel/Desktop/carve_outs_table_2.xlsx&#39;, engine=&#39;xlsxwriter&#39;) as writer:
                merged_df.to_excel(writer, sheet_name=&#39;table_2&#39;, index=False)

        # We output the resulting DataFrame with country codes and names, as well as the 4 columns of interest
        merged_df = merged_df[
            [&#39;Parent jurisdiction (alpha-3 code)&#39;, &#39;Parent jurisdiction (whitespaces cleaned)&#39;] + new_columns
        ].copy()

        return merged_df.copy()

    def get_carve_outs_rate_table(
        self,
        minimum_ETR,
        depreciation_only, exclude_inventories,
    ):
        &#34;&#34;&#34;
        This function takes as inputs:

        - the minimum effective tax rate to apply to multinationals&#39; profits;

        - a boolean, &#34;depreciation_only&#34;, indicating whether to restrict the tangible assets component of substance-
        based carve-outs to a share of depreciation expenses;

        - a boolean, &#34;exlude_inventories&#34;, indicating whether to exlude inventories from tangible assets or not.

        It returns a DataFrame that shows, for each in-sample country, the estimated revenues that could be collected
        from a global minimum tax without any carve-outs and with carve-outs of 5%, 7.5% and 10% of tangible assets and
        payroll combined.
        &#34;&#34;&#34;

        # We instantiate a TaxDeficitCalculator object without carve-outs
        calculator = TaxDeficitCalculator()

        calculator.load_clean_data()

        # We use it to compute revenue gains without any carve-out
        td_no_carve_out = calculator.get_total_tax_deficits(minimum_ETR=minimum_ETR).iloc[:-2]

        td_no_carve_out.rename(
            columns={
                &#39;tax_deficit&#39;: &#39;tax_deficit_no_carve_out&#39;
            },
            inplace=True
        )

        # A copy of the resulting DataFrame will be used as a central table to which we add the relevant columns
        merged_df = td_no_carve_out.copy()

        # We iterate over carve-out rates
        for carve_out_rate in [5, 7.5, 10]:
            actual_rate = carve_out_rate / 100

            # We instantiate a TaxDeficitCalculator object with carve-outs at the rate considered
            calculator = TaxDeficitCalculator(
                carve_outs=True, carve_out_rate=actual_rate,
                depreciation_only=False, exclude_inventories=exclude_inventories
            )
            calculator.load_clean_data()

            # We use it to compute revenue gains with substance-based carve-outs being applied
            td_carve_out = calculator.get_total_tax_deficits(minimum_ETR=minimum_ETR).iloc[:-2]

            # We add the tax deficits thereby computed to the central table
            merged_df = merged_df.merge(
                td_carve_out[[&#39;Parent jurisdiction (alpha-3 code)&#39;, &#39;tax_deficit&#39;]],
                how=&#39;left&#39;,
                on=&#39;Parent jurisdiction (alpha-3 code)&#39;
            )

            merged_df[&#39;tax_deficit&#39;] = merged_df[&#39;tax_deficit&#39;].fillna(0)

            merged_df.rename(
                columns={
                    &#39;tax_deficit&#39;: f&#39;tax_deficit_{carve_out_rate}_carve_out&#39;
                },
                inplace=True
            )

        # We only display EU or CbCR-reporting countries
        cbcr_reporting_countries = list(self.oecd[&#39;Parent jurisdiction (alpha-3 code)&#39;].unique())

        mask_eu = merged_df[&#39;Parent jurisdiction (alpha-3 code)&#39;].isin(eu_27_country_codes)
        mask_cbcr = merged_df[&#39;Parent jurisdiction (alpha-3 code)&#39;].isin(cbcr_reporting_countries)

        # This condition is encapsulated in the following boolean indexing mask
        mask = np.logical_or(mask_eu, mask_cbcr)

        # We add two useful indicator variables
        merged_df[&#39;IS_EU&#39;] = mask_eu * 1
        merged_df[&#39;REPORTS_CbCR&#39;] = mask_cbcr * 1

        # And we restrict the DataFrame to relevant countries
        restricted_df = merged_df[mask].copy()

        # We finalise the formatting of the table
        restricted_df.sort_values(
            by=[&#39;IS_EU&#39;, &#39;Parent jurisdiction (alpha-3 code)&#39;],
            ascending=[False, True],
            inplace=True
        )

        # And eventually return the DataFrame
        return restricted_df.copy()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="tax_deficit_simulator.calculator.TaxDeficitCalculator.assess_carve_out_impact"><code class="name flex">
<span>def <span class="ident">assess_carve_out_impact</span></span>(<span>self, minimum_ETR=0.25)</span>
</code></dt>
<dd>
<div class="desc"><p>This function takes as input a minimum effective tax rate (which defaults to 25%) and outputs a DataFrame
showing, for each in-sample country (EU and/or CbCR-reporting countries):</p>
<ul>
<li>the tax deficit that it could collect by imposing this minimum ETR on the profits of its multinationals;</li>
<li>the split between domestic, tax haven and non-haven tax deficits;</li>
<li>and the same amounts with carve-outs being applied.</li>
</ul>
<p>Carve-outs are applied with the parameters (carve-out rate, use of the full value of tangible assets or of de-
preciation expenses only and exclusion of inventories or not) that are defined when instantiating the TaxDefi-
citCalculator object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assess_carve_out_impact(self, minimum_ETR=0.25):
    &#34;&#34;&#34;
    This function takes as input a minimum effective tax rate (which defaults to 25%) and outputs a DataFrame
    showing, for each in-sample country (EU and/or CbCR-reporting countries):

    - the tax deficit that it could collect by imposing this minimum ETR on the profits of its multinationals;
    - the split between domestic, tax haven and non-haven tax deficits;
    - and the same amounts with carve-outs being applied.

    Carve-outs are applied with the parameters (carve-out rate, use of the full value of tangible assets or of de-
    preciation expenses only and exclusion of inventories or not) that are defined when instantiating the TaxDefi-
    citCalculator object.
    &#34;&#34;&#34;

    # If carve-out parameters have not been indicated, we cannot run the computations
    if self.carve_out_rate is None or self.depreciation_only is None or self.exclude_inventories is None:
        raise Exception(
            &#39;If you want to simulate substance-based carve-outs, you need to indicate all the parameters.&#39;
        )

    # We instantiate a TaxDeficitCalculator object with carve-outs
    calculator = TaxDeficitCalculator(
        carve_outs=True,
        carve_out_rate=self.carve_out_rate,
        depreciation_only=self.depreciation_only,
        exclude_inventories=self.exclude_inventories
    )

    # We load the data
    calculator.load_clean_data()

    # And deduce total tax deficits and their split, with carve-outs being applied
    carve_outs = calculator.compute_all_tax_deficits(
        CbCR_reporting_countries_only=False,
        minimum_ETR=minimum_ETR
    )

    # We instantiate a TaxDeficitCalculator object without carve-outs
    calculator_no_carve_out = TaxDeficitCalculator()

    # We load the data
    calculator_no_carve_out.load_clean_data()

    # And deduce total tax deficits and their split, without any carve-out being applied
    no_carve_outs = calculator_no_carve_out.compute_all_tax_deficits(
        CbCR_reporting_countries_only=False,
        minimum_ETR=minimum_ETR
    )

    # We merge the two DataFrames
    carve_outs_impact = carve_outs.merge(
        no_carve_outs,
        how=&#39;inner&#39;,
        on=[
            &#39;Parent jurisdiction (whitespaces cleaned)&#39;,
            &#39;Parent jurisdiction (alpha-3 code)&#39;
        ]
    ).rename(
        columns={
            &#39;tax_deficit_x&#39;: &#39;TD_with_carve_outs&#39;,
            &#39;tax_deficit_y&#39;: &#39;TD_no_carve_outs&#39;,
            &#39;tax_deficit_x_domestic_x&#39;: &#39;domestic_TD_with_carve_outs&#39;,
            &#39;tax_deficit_x_domestic_y&#39;: &#39;domestic_TD_no_carve_outs&#39;,
            &#39;tax_deficit_x_non_haven_x&#39;: &#39;non_haven_TD_with_carve_outs&#39;,
            &#39;tax_deficit_x_non_haven_y&#39;: &#39;non_haven_TD_no_carve_outs&#39;,
            &#39;tax_deficit_x_tax_haven_x&#39;: &#39;tax_haven_TD_with_carve_outs&#39;,
            &#39;tax_deficit_x_tax_haven_y&#39;: &#39;tax_haven_TD_no_carve_outs&#39;
        }
    )

    # We only show EU and/or CbCR-reporting countries
    cbcr_reporting_countries = list(self.oecd[&#39;Parent jurisdiction (alpha-3 code)&#39;].unique())

    mask_eu = carve_outs_impact[&#39;Parent jurisdiction (alpha-3 code)&#39;].isin(eu_27_country_codes)
    mask_cbcr = carve_outs_impact[&#39;Parent jurisdiction (alpha-3 code)&#39;].isin(cbcr_reporting_countries)

    # This condition is encapsulated in this boolean indexing mask
    mask = np.logical_or(mask_eu, mask_cbcr)

    # We add two useful indicator variables
    carve_outs_impact[&#39;IS_EU&#39;] = mask_eu * 1
    carve_outs_impact[&#39;REPORTS_CbCR&#39;] = mask_cbcr * 1

    # And restrict the DataFrame to relevant countries
    restricted_df = carve_outs_impact[mask].copy()

    # We finalise the formatting of the table
    restricted_df.sort_values(
        by=[&#39;IS_EU&#39;, &#39;Parent jurisdiction (alpha-3 code)&#39;],
        ascending=[False, True],
        inplace=True
    )

    columns = [
        &#39;Parent jurisdiction (whitespaces cleaned)&#39;, &#39;TD_with_carve_outs&#39;, &#39;TD_no_carve_outs&#39;,
        &#39;domestic_TD_with_carve_outs&#39;, &#39;domestic_TD_no_carve_outs&#39;, &#39;non_haven_TD_with_carve_outs&#39;,
        &#39;non_haven_TD_no_carve_outs&#39;, &#39;tax_haven_TD_with_carve_outs&#39;, &#39;tax_haven_TD_no_carve_outs&#39;,
        &#39;IS_EU&#39;, &#39;REPORTS_CbCR&#39;
    ]

    return restricted_df[columns].copy()</code></pre>
</details>
</dd>
<dt id="tax_deficit_simulator.calculator.TaxDeficitCalculator.check_appendix_A2"><code class="name flex">
<span>def <span class="ident">check_appendix_A2</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Relying on the get_total_tax_deficits method and on TWZ data on corporate income tax revenues, this method out-
puts a DataFrame that can be compared with the first 4 columns of Table A2 in the report. For each in-sample
country and at four different minimum ETRs (15%, 21%, 25% and 30% which are the four main cases considered in
the report), the table presents estimated revenue gains as a percentage of currently corporate income taxes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_appendix_A2(self):
    &#34;&#34;&#34;
    Relying on the get_total_tax_deficits method and on TWZ data on corporate income tax revenues, this method out-
    puts a DataFrame that can be compared with the first 4 columns of Table A2 in the report. For each in-sample
    country and at four different minimum ETRs (15%, 21%, 25% and 30% which are the four main cases considered in
    the report), the table presents estimated revenue gains as a percentage of currently corporate income taxes.
    &#34;&#34;&#34;

    # We need to have previously loaded and cleaned the TWZ data on corporate income tax revenues
    # (figures in the pre-loaded DataFrame are provided in 2016 USD)
    if self.twz_CIT is None:
        raise Exception(&#39;You first need to load clean data with the dedicated method and inplace=True.&#39;)

    # We compute total tax deficits, first at a 15% minimum ETR and in 2021 EUR
    df = self.get_total_tax_deficits(minimum_ETR=0.15)

    df.rename(columns={&#39;tax_deficit&#39;: &#39;tax_deficit_15&#39;}, inplace=True)

    # We merge the two DataFrames to combine information on collectible tax deficits and current CIT revenues
    merged_df = df.merge(
        self.twz_CIT,
        how=&#39;left&#39;,
        left_on=&#39;Parent jurisdiction (alpha-3 code)&#39;,
        right_on=&#39;Country (alpha-3 code)&#39;
    ).drop(columns=[&#39;Country&#39;, &#39;Country (alpha-3 code)&#39;])

    # We bring back the tax deficit estimated to 2016 USD (from 2021 EUR)
    merged_df[&#39;tax_deficit_15&#39;] /= (merged_df[&#39;CIT revenue&#39;] * self.multiplier_2021 * self.USD_to_EUR_2016 / 100)

    # For the 3 other rates considered in the output table
    for rate in [0.21, 0.25, 0.3]:
        # We compute total tax deficits at this rate
        df = self.get_total_tax_deficits(minimum_ETR=rate)

        # We add these results to the central DataFrame thanks to a merge operation
        merged_df = merged_df.merge(
            df,
            how=&#39;left&#39;,
            on=&#39;Parent jurisdiction (alpha-3 code)&#39;
        )

        # We impute the missing values produced by the merge
        merged_df[&#39;tax_deficit&#39;] = merged_df[&#39;tax_deficit&#39;].fillna(0)

        # We rename the newly-added tax deficit column
        merged_df.rename(
            columns={&#39;tax_deficit&#39;: f&#39;tax_deficit_{int(rate * 100)}&#39;},
            inplace=True
        )

        # And we bring it back to 2016 USD
        merged_df[f&#39;tax_deficit_{int(rate * 100)}&#39;] /= (
            merged_df[&#39;CIT revenue&#39;] * self.multiplier_2021 * self.USD_to_EUR_2016 / 100
        )

    # We want to also verify the EU-27 average and restrict the DataFrame to these countries
    eu_df = merged_df[merged_df[&#39;Parent jurisdiction (alpha-3 code)&#39;].isin(eu_27_country_codes)].copy()

    # This attribute stores the average EU-27 revenue gain estimate in % of current CIT revenues for each of the 4
    # minimum ETRs of interest (respectively 15.1%, 30.5%, 52.3% and 84.1% in the report)
    self.check = [
        (
            eu_df[f&#39;tax_deficit_{rate}&#39;] * eu_df[&#39;CIT revenue&#39;] / 100
        ).sum() / eu_df[&#39;CIT revenue&#39;].sum() for rate in [15, 21, 25, 30]
    ]

    # Coming back to the DataFrame with all in-sample countries, we only keep the relevant columns and output it
    merged_df = merged_df[
        [
            &#39;Parent jurisdiction (whitespaces cleaned)_x&#39;,
            &#39;tax_deficit_15&#39;, &#39;tax_deficit_21&#39;, &#39;tax_deficit_25&#39;, &#39;tax_deficit_30&#39;
        ]
    ].copy()

    # NB: in the current version of this method, the successive merges have a poor effect on the &#34;Total&#34; rows that
    # are included in the output of the get_total_tax_deficits method; this could easily be improved

    return merged_df.copy()</code></pre>
</details>
</dd>
<dt id="tax_deficit_simulator.calculator.TaxDeficitCalculator.check_tax_deficit_computations"><code class="name flex">
<span>def <span class="ident">check_tax_deficit_computations</span></span>(<span>self, minimum_ETR=0.25)</span>
</code></dt>
<dd>
<div class="desc"><p>Taking the selected minimum ETR as input and relying on the compute_all_tax_deficits method defined above, this
method outputs a DataFrame that can be compared with Table A1 of the report. For each country in OECD and/or TWZ
data, it displays its total tax deficit and a breakdown into domestic, tax-haven-based and non-haven tax defi-
cits. Figures are display in 2021 billion EUR.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_tax_deficit_computations(self, minimum_ETR=0.25):
    &#34;&#34;&#34;
    Taking the selected minimum ETR as input and relying on the compute_all_tax_deficits method defined above, this
    method outputs a DataFrame that can be compared with Table A1 of the report. For each country in OECD and/or TWZ
    data, it displays its total tax deficit and a breakdown into domestic, tax-haven-based and non-haven tax defi-
    cits. Figures are display in 2021 billion EUR.
    &#34;&#34;&#34;

    # We start from the output of the previously defined method
    df = self.compute_all_tax_deficits(minimum_ETR=minimum_ETR)

    # And convert numeric columns from 2021 EUR to 2021 billion EUR
    for column_name in df.columns[2:]:
        df[column_name] = df[column_name] / 10**9

    return df.copy()</code></pre>
</details>
</dd>
<dt id="tax_deficit_simulator.calculator.TaxDeficitCalculator.check_unilateral_scenario_gain_computations"><code class="name flex">
<span>def <span class="ident">check_unilateral_scenario_gain_computations</span></span>(<span>self, minimum_ETR=0.25)</span>
</code></dt>
<dd>
<div class="desc"><p>Taking as input the selected minimum effective tax rate and relying on the compute_unilateral_scenario_gain,
this method outputs a DataFrame that can be compared with the Table 3 of the report. For each country that is
part of the EU-27 and/or included in the 2016 aggregated and anonymized CbCR data of the OECD, it shows the to-
tal corporate tax revenue gain that could be drawn from the unilateral implementation of the tax deficit col-
lection. It also provides a breakdown of this total between the tax deficit of the country's own multinationals,
the amount that could be collected from US multinationals and revenues that could be collected from non-US ones.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_unilateral_scenario_gain_computations(self, minimum_ETR=0.25):
    &#34;&#34;&#34;
    Taking as input the selected minimum effective tax rate and relying on the compute_unilateral_scenario_gain,
    this method outputs a DataFrame that can be compared with the Table 3 of the report. For each country that is
    part of the EU-27 and/or included in the 2016 aggregated and anonymized CbCR data of the OECD, it shows the to-
    tal corporate tax revenue gain that could be drawn from the unilateral implementation of the tax deficit col-
    lection. It also provides a breakdown of this total between the tax deficit of the country&#39;s own multinationals,
    the amount that could be collected from US multinationals and revenues that could be collected from non-US ones.
    &#34;&#34;&#34;

    # We build the list of countries that we want to include in the output table
    country_list = self.get_total_tax_deficits()

    country_list = country_list[
        ~country_list[&#39;Parent jurisdiction (whitespaces cleaned)&#39;].isin([&#39;Total - EU27&#39;, &#39;Total - Whole sample&#39;])
    ].copy()

    country_list = list(country_list[&#39;Parent jurisdiction (whitespaces cleaned)&#39;].values)

    # We prepare the structure of the output first as a dictionary
    output = {
        &#39;Country&#39;: country_list,
        &#39;Own tax deficit&#39;: [],
        &#39;Collection of US tax deficit&#39;: [],
        &#39;Collection of non-US tax deficit&#39;: [],
        &#39;Imputation&#39;: [],
        &#39;Total&#39;: []
    }

    # We iterate over the list of relevant countries
    for country in country_list:

        # Using the method defined above, we output the table presenting the tax deficit that could be collected
        # from a unilateral implementation of the tax deficit collection by the considered country and its origin
        df = self.compute_unilateral_scenario_gain(
            country=country,
            minimum_ETR=minimum_ETR
        )

        column_name = f&#39;Collectible tax deficit for {country}&#39;

        if country in df[&#39;Parent jurisdiction (whitespaces cleaned)&#39;].unique():
            # We fetch the tax deficit that could be collected from the country&#39;s own multinationals
            output[&#39;Own tax deficit&#39;].append(
                df[df[&#39;Parent jurisdiction (whitespaces cleaned)&#39;] == country][column_name].iloc[0]
            )

        else:
            output[&#39;Own tax deficit&#39;].append(0)

        # We fetch the tax deficit that could be collected from US multinationals
        if &#39;United States&#39; in df[&#39;Parent jurisdiction (whitespaces cleaned)&#39;].values:
            output[&#39;Collection of US tax deficit&#39;].append(
                df[df[&#39;Parent jurisdiction (whitespaces cleaned)&#39;] == &#39;United States&#39;][column_name].iloc[0]
            )
        else:
            output[&#39;Collection of US tax deficit&#39;].append(0)

        # We fetch the tax deficit that was imputed following our methodology
        output[&#39;Imputation&#39;].append(
            df[df[&#39;Parent jurisdiction (whitespaces cleaned)&#39;] == &#39;Others (imputation)&#39;][column_name].iloc[0]
        )

        # We fetch the total tax deficit
        output[&#39;Total&#39;].append(
            df[df[&#39;Parent jurisdiction (whitespaces cleaned)&#39;] == &#39;Total&#39;][column_name].iloc[0]
        )

        # And finally, we sum the tax deficits collected from foreign non-US multinationals
        output[&#39;Collection of non-US tax deficit&#39;].append(
            df[
                ~df[&#39;Parent jurisdiction (whitespaces cleaned)&#39;].isin(
                    [
                        country, &#39;United States&#39;, &#39;Total&#39;, &#39;Others (imputation)&#39;
                    ]
                )
            ][column_name].sum()
        )

    # We convert the dictionary into a DataFrame
    df = pd.DataFrame.from_dict(output)

    # We sum the imputation and the tax deficit collected from foreign, non-US multinationals to obtain the uprated
    # figures that correspond to the &#34;Other foreign firms&#34; column of Table 3 in the report
    df[&#39;Collection of non-US tax deficit (uprated with imputation)&#39;] = \
        df[&#39;Imputation&#39;] + df[&#39;Collection of non-US tax deficit&#39;]

    # We convert the results from 2021 EUR into 2021 billion EUR
    for column_name in df.columns[1:]:
        df[column_name] /= 10**9

    return df.copy()</code></pre>
</details>
</dd>
<dt id="tax_deficit_simulator.calculator.TaxDeficitCalculator.combine_haven_tax_deficits"><code class="name flex">
<span>def <span class="ident">combine_haven_tax_deficits</span></span>(<span>self, row, carve_outs=False, countries_replaced=None)</span>
</code></dt>
<dd>
<div class="desc"><p>This function is used to compute the tax deficit of all in-sample headquarter countries in the multilateral im-
plementation scenario.</p>
<p>For parent countries that are in both the OECD and TWZ data, we have two different sources to compute their tax-
haven-based tax deficit and we retain the highest of these two amounts.</p>
<p>Besides, for parent countries in the OECD data that do not report a fully detailed country-by-country breakdown
of the activity of their multinationals, we cannot distinguish their tax-haven and non-haven tax deficits. Quite
arbitrarily in the Python code, we attribute everything to the non-haven tax deficit. In the Table A1 of the re-
port, these specific cases are described with the "Only foreign aggregate data" column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_haven_tax_deficits(
    self,
    row,
    carve_outs=False,
    countries_replaced=None
):
    &#34;&#34;&#34;
    This function is used to compute the tax deficit of all in-sample headquarter countries in the multilateral im-
    plementation scenario.

    For parent countries that are in both the OECD and TWZ data, we have two different sources to compute their tax-
    haven-based tax deficit and we retain the highest of these two amounts.

    Besides, for parent countries in the OECD data that do not report a fully detailed country-by-country breakdown
    of the activity of their multinationals, we cannot distinguish their tax-haven and non-haven tax deficits. Quite
    arbitrarily in the Python code, we attribute everything to the non-haven tax deficit. In the Table A1 of the re-
    port, these specific cases are described with the &#34;Only foreign aggregate data&#34; column.
    &#34;&#34;&#34;
    if carve_outs and countries_replaced is None:
        raise Exception(
            &#39;Using this function under carve-outs requires to indicate a list of countries to replace.&#39;
        )

    if row[&#39;Parent jurisdiction (alpha-3 code)&#39;] not in (
        COUNTRIES_WITH_MINIMUM_REPORTING + COUNTRIES_WITH_CONTINENTAL_REPORTING
    ):
        if countries_replaced is None:

            if row[&#39;tax_deficit_x_tax_haven_TWZ&#39;] &gt; row[&#39;tax_deficit_x_tax_haven&#39;]:
                self.countries_replaced.append(row[&#39;Parent jurisdiction (alpha-3 code)&#39;])
                return row[&#39;tax_deficit_x_tax_haven_TWZ&#39;]

            else:
                return row[&#39;tax_deficit_x_tax_haven&#39;]

        else:
            if (
                row[&#39;tax_deficit_x_tax_haven_TWZ&#39;] &gt; row[&#39;tax_deficit_x_tax_haven&#39;]
                and row[&#39;Parent jurisdiction (alpha-3 code)&#39;] in countries_replaced
            ):
                self.countries_replaced.append(row[&#39;Parent jurisdiction (alpha-3 code)&#39;])
                return row[&#39;tax_deficit_x_tax_haven_TWZ&#39;]

            else:
                return row[&#39;tax_deficit_x_tax_haven&#39;]

    else:
        return 0</code></pre>
</details>
</dd>
<dt id="tax_deficit_simulator.calculator.TaxDeficitCalculator.compute_all_tax_deficits"><code class="name flex">
<span>def <span class="ident">compute_all_tax_deficits</span></span>(<span>self, minimum_ETR=0.25, CbCR_reporting_countries_only=False)</span>
</code></dt>
<dd>
<div class="desc"><p>This method encapsulates most of the computations for the multilateral agreement scenario.</p>
<p>Taking as input the minimum effective tax rate to apply and based on OECD and TWZ data, it outputs a DataFrame
which presents, for each country in our sample (countries in OECD and/or TWZ data) the total tax deficit, as
well as its breakdown into domestic, tax-haven and non-haven tax deficits.</p>
<p>The output is in 2021 EUR after a currency conversion and the extrapolation from 2016 to 2021 figures.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_all_tax_deficits(self, minimum_ETR=0.25, CbCR_reporting_countries_only=False):
    &#34;&#34;&#34;
    This method encapsulates most of the computations for the multilateral agreement scenario.

    Taking as input the minimum effective tax rate to apply and based on OECD and TWZ data, it outputs a DataFrame
    which presents, for each country in our sample (countries in OECD and/or TWZ data) the total tax deficit, as
    well as its breakdown into domestic, tax-haven and non-haven tax deficits.

    The output is in 2021 EUR after a currency conversion and the extrapolation from 2016 to 2021 figures.
    &#34;&#34;&#34;
    # We need to have previously loaded and cleaned the OECD and TWZ data
    if self.oecd is None or self.twz is None:
        raise Exception(&#39;You first need to load clean data with the dedicated method and inplace=True.&#39;)

    # We use the method defined above and will use its output as a base for the following computations
    oecd_stratified = self.get_stratified_oecd_data(minimum_ETR=minimum_ETR)

    twz = self.twz.copy()

    # From TWZ data on profits registered in tax havens and assuming that these are taxed at a given minimum ETR
    # (10% in the report, see the instantiation function for the definition of this attribute), we deduce the tax-
    # haven-based tax deficit of TWZ countries
    twz[&#39;tax_deficit_x_tax_haven_TWZ&#39;] = \
        twz[&#39;Profits in all tax havens (positive only)&#39;] * (minimum_ETR - self.assumed_haven_ETR_TWZ)

    # --- Managing countries in both OECD and TWZ data

    # We focus on parent countries which are in both the OECD and TWZ data
    # NB: recall that we do not consider the Swedish CbCR
    twz_in_oecd = twz[twz[&#39;Is parent in OECD data?&#39;].astype(bool)].copy()

    # We merge the two DataFrames on country codes
    merged_df = oecd_stratified.merge(
        twz_in_oecd[[&#39;Country&#39;, &#39;Alpha-3 country code&#39;, &#39;tax_deficit_x_tax_haven_TWZ&#39;]],
        how=&#39;left&#39;,
        left_on=&#39;Parent jurisdiction (alpha-3 code)&#39;,
        right_on=&#39;Alpha-3 country code&#39;
    ).drop(columns=[&#39;Country&#39;, &#39;Alpha-3 country code&#39;])

    # For countries that are in the OECD data but not in TWZ, we impute a tax-haven-based tax deficit from TWZ of 0
    merged_df[&#39;tax_deficit_x_tax_haven_TWZ&#39;] = merged_df[&#39;tax_deficit_x_tax_haven_TWZ&#39;].fillna(0)

    self.countries_replaced = []

    if self.carve_outs:

        calculator = TaxDeficitCalculator()
        calculator.load_clean_data()
        _ = calculator.compute_all_tax_deficits()

        countries_replaced = calculator.countries_replaced.copy()

        merged_df[&#39;tax_deficit_x_tax_haven_merged&#39;] = merged_df.apply(
            lambda row: self.combine_haven_tax_deficits(
                row,
                carve_outs=self.carve_outs,
                countries_replaced=countries_replaced),
            axis=1
        )

    else:
        merged_df[&#39;tax_deficit_x_tax_haven_merged&#39;] = merged_df.apply(
            lambda row: self.combine_haven_tax_deficits(
                row,
                carve_outs=self.carve_outs
            ),
            axis=1
        )

    self.countries_replaced = merged_df[
        merged_df[&#39;tax_deficit_x_tax_haven_merged&#39;] == merged_df[&#39;tax_deficit_x_tax_haven_TWZ&#39;]
    ][&#39;Parent jurisdiction (alpha-3 code)&#39;].unique()

    merged_df.drop(columns=[&#39;tax_deficit_x_tax_haven&#39;, &#39;tax_deficit_x_tax_haven_TWZ&#39;], inplace=True)

    merged_df.rename(
        columns={
            &#39;tax_deficit_x_tax_haven_merged&#39;: &#39;tax_deficit_x_tax_haven&#39;
        },
        inplace=True
    )

    # Summing the tax-haven-based, non-haven and domestic tax deficits yields the total tax deficit of each country
    merged_df[&#39;tax_deficit&#39;] = merged_df[&#39;tax_deficit_x_tax_haven&#39;] \
        + merged_df[&#39;tax_deficit_x_domestic&#39;] \
        + merged_df[&#39;tax_deficit_x_non_haven&#39;]

    # --- Countries only in the TWZ data

    # We now focus on countries that are absent from the OECD data
    # NB: recall that we do not consider the Swedish CbCR
    twz_not_in_oecd = twz[~twz[&#39;Is parent in OECD data?&#39;].astype(bool)].copy()

    twz_not_in_oecd.drop(
        columns=[&#39;Profits in all tax havens&#39;, &#39;Profits in all tax havens (positive only)&#39;],
        inplace=True
    )

    # - Extrapolating the foreign non-haven tax deficit

    # We compute the imputation ratio with the method defined above
    imputation_ratio_non_haven = self.get_non_haven_imputation_ratio(minimum_ETR=minimum_ETR)

    # And we deduce the non-haven tax deficit of countries that are only found in TWZ data
    twz_not_in_oecd[&#39;tax_deficit_x_non_haven&#39;] = \
        twz_not_in_oecd[&#39;tax_deficit_x_tax_haven_TWZ&#39;] * imputation_ratio_non_haven

    # - Computing the domestic tax deficit

    # For countries that are only in TWZ data, we still need to compute their domestic tax deficit
    twz_domestic = self.twz_domestic.copy()

    # We only consider countries whose domestic ETR is stricly below the minimum ETR
    # (otherwise, there is no tax deficit to collect from domestic profits)
    twz_domestic = twz_domestic[twz_domestic[&#39;Domestic ETR&#39;] &lt; minimum_ETR].copy()

    # We compute the ETR differential
    twz_domestic[&#39;ETR_differential&#39;] = twz_domestic[&#39;Domestic ETR&#39;].map(lambda x: minimum_ETR - x)

    # And deduce the domestic tax deficit of each country
    twz_domestic[&#39;tax_deficit_x_domestic&#39;] = twz_domestic[&#39;ETR_differential&#39;] * twz_domestic[&#39;Domestic profits&#39;]

    # - Combining the different forms of tax deficit

    # We merge the two DataFrames to complement twz_not_in_oecd with domestic tax deficit results
    twz_not_in_oecd = twz_not_in_oecd.merge(
        twz_domestic[[&#39;Alpha-3 country code&#39;, &#39;tax_deficit_x_domestic&#39;]],
        how=&#39;left&#39;,
        on=&#39;Alpha-3 country code&#39;
    )

    # As we filtered out countries whose domestic ETR is stricly below the minimum ETR, some missing values
    # appear during the merge; we impute 0 for these as they do not have any domestic tax deficit to collect
    twz_not_in_oecd[&#39;tax_deficit_x_domestic&#39;] = twz_not_in_oecd[&#39;tax_deficit_x_domestic&#39;].fillna(0)

    # We deduce the total tax deficit for each country
    twz_not_in_oecd[&#39;tax_deficit&#39;] = twz_not_in_oecd[&#39;tax_deficit_x_tax_haven_TWZ&#39;] \
        + twz_not_in_oecd[&#39;tax_deficit_x_domestic&#39;] \
        + twz_not_in_oecd[&#39;tax_deficit_x_non_haven&#39;]

    # --- Merging the results of the two data sources

    # We need columns to match for the concatenation to operate smoothly
    twz_not_in_oecd.rename(
        columns={
            &#39;Country&#39;: &#39;Parent jurisdiction (whitespaces cleaned)&#39;,
            &#39;Alpha-3 country code&#39;: &#39;Parent jurisdiction (alpha-3 code)&#39;,
            &#39;tax_deficit_x_tax_haven_TWZ&#39;: &#39;tax_deficit_x_tax_haven&#39;
        },
        inplace=True
    )

    twz_not_in_oecd.drop(columns=[&#39;Is parent in OECD data?&#39;], inplace=True)

    # We exclude Sweden from the OECD-drawn results, as we do not consider its CbCR
    merged_df = merged_df[merged_df[&#39;Parent jurisdiction (alpha-3 code)&#39;] != &#39;SWE&#39;].copy()

    # We eventually concatenate the two DataFrames
    merged_df = pd.concat(
        [merged_df, twz_not_in_oecd],
        axis=0
    )

    # --- Extrapolations to 2021 EUR

    # We convert 2016 USD results in 2016 EUR and extraprolate them to 2021 EUR
    for column_name in merged_df.columns[2:]:
        merged_df[column_name] = merged_df[column_name] * self.USD_to_EUR_2016 * self.multiplier_2021

    # --- Managing the case where the minimum ETR is 20% or below for TWZ countries

    # As mentioned above and detailed in Appendix A, the imputation of the non-haven tax deficit of TWZ countries
    # follows a specific process whenever the chosen minimum ETR is of or below 20%
    if minimum_ETR &lt;= 0.2 and self.alternative_imputation:
        # We get the new multiplying factor from the method defined above
        multiplying_factor = self.get_alternative_non_haven_factor(minimum_ETR=minimum_ETR)

        # We compute all tax deficits at the reference rate (25% in the report)
        df = self.compute_all_tax_deficits(
            minimum_ETR=self.reference_rate_for_alternative_imputation
        )

        # We only consider countries that are absent from the OECD data, except Sweden as usual
        oecd_reporting_countries_but_SWE = self.oecd[
            self.oecd[&#39;Parent jurisdiction (alpha-3 code)&#39;] != &#39;SWE&#39;
        ][&#39;Parent jurisdiction (alpha-3 code)&#39;].unique()

        df = df[
            ~df[&#39;Parent jurisdiction (alpha-3 code)&#39;].isin(oecd_reporting_countries_but_SWE)
        ].copy()

        # For these countries, we multiply the non-haven tax deficit at the reference rate by the multiplying factor
        df[&#39;tax_deficit_x_non_haven_imputation&#39;] = df[&#39;tax_deficit_x_non_haven&#39;] * multiplying_factor

        # We save the results in a dictionary that will allow to map the DataFrame that we want to output in the end
        mapping = {}

        for _, row in df.iterrows():
            mapping[row[&#39;Parent jurisdiction (alpha-3 code)&#39;]] = row[&#39;tax_deficit_x_non_haven_imputation&#39;]

        # We create a new column in the to-be-output DataFrame which takes as value:
        # - the non-haven tax deficit estimated just above for TWZ countries
        # - 0 for OECD-reporting countries, which do not require this imputation
        merged_df[&#39;tax_deficit_x_non_haven_imputation&#39;] = merged_df[&#39;Parent jurisdiction (alpha-3 code)&#39;].map(
            lambda country_code: mapping.get(country_code, 0)
        )

        # We deduce the non-haven tax deficit of all countries
        merged_df[&#39;tax_deficit_x_non_haven&#39;] += merged_df[&#39;tax_deficit_x_non_haven_imputation&#39;]

        # And add this imputation also to the column that presents the total tax deficit of each country
        merged_df[&#39;tax_deficit&#39;] += merged_df[&#39;tax_deficit_x_non_haven_imputation&#39;]

        merged_df.drop(
            columns=[&#39;tax_deficit_x_non_haven_imputation&#39;],
            inplace=True
        )

    if CbCR_reporting_countries_only:
        merged_df = merged_df[
            merged_df[&#39;Parent jurisdiction (whitespaces cleaned)&#39;].isin(
                self.oecd[&#39;Parent jurisdiction (whitespaces cleaned)&#39;].unique()
            )
        ].copy()

    return merged_df.reset_index(drop=True).copy()</code></pre>
</details>
</dd>
<dt id="tax_deficit_simulator.calculator.TaxDeficitCalculator.compute_intermediary_scenario_gain"><code class="name flex">
<span>def <span class="ident">compute_intermediary_scenario_gain</span></span>(<span>self, minimum_ETR=0.25)</span>
</code></dt>
<dd>
<div class="desc"><p>This method encapsulates the computations used to estimate the corporate tax revenue gains of EU countries,
should the European Union implement the tax deficit collection as a block. This corresponds therefore to the
partial cooperation scenario described in the report.</p>
<p>Taking as input the selected minimum effective tax rate, this method outputs a DataFrame that presents for each
in-sample EU-27 country:</p>
<ul>
<li>the corporate tax revenue gains that could be collected from its own multinationals ("tax_deficit" column);</li>
<li>the tax deficit that could be collected from foreign, non-EU multinationals ("From foreign MNEs" column);</li>
<li>and the resulting total corporate tax revenue gain.</li>
</ul>
<p>All figures are output in 2021 million EUR.</p>
<p>The three lines at the end of the DataFrame are a bit specific. Some OECD-reporting contries do not provide a
perfectly detailed country-by-country report and for these, the "Other Europe" and "Europe" fields are assumed
to be related to EU countries and are included in the total collectible tax deficit. The final line presents
this total.</p>
<p>The methogology behind these computations is described in much more details in Appendix C of the report.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_intermediary_scenario_gain(self, minimum_ETR=0.25):
    &#34;&#34;&#34;
    This method encapsulates the computations used to estimate the corporate tax revenue gains of EU countries,
    should the European Union implement the tax deficit collection as a block. This corresponds therefore to the
    partial cooperation scenario described in the report.

    Taking as input the selected minimum effective tax rate, this method outputs a DataFrame that presents for each
    in-sample EU-27 country:

    - the corporate tax revenue gains that could be collected from its own multinationals (&#34;tax_deficit&#34; column);
    - the tax deficit that could be collected from foreign, non-EU multinationals (&#34;From foreign MNEs&#34; column);
    - and the resulting total corporate tax revenue gain.

    All figures are output in 2021 million EUR.

    The three lines at the end of the DataFrame are a bit specific. Some OECD-reporting contries do not provide a
    perfectly detailed country-by-country report and for these, the &#34;Other Europe&#34; and &#34;Europe&#34; fields are assumed
    to be related to EU countries and are included in the total collectible tax deficit. The final line presents
    this total.

    The methogology behind these computations is described in much more details in Appendix C of the report.
    &#34;&#34;&#34;

    # We start by computing the total tax deficits of all in-sample countries (those of the multilateral scenario)
    tax_deficits = self.get_total_tax_deficits(minimum_ETR=minimum_ETR)

    oecd = self.oecd.copy()

    # We extract the total tax deficit for the EU-27
    eu_27_tax_deficit = tax_deficits[
        tax_deficits[&#39;Parent jurisdiction (whitespaces cleaned)&#39;] == &#39;Total - EU27&#39;
    ][&#39;tax_deficit&#39;].iloc[0]

    # And we store in a separate DataFrame the tax deficits of EU-27 countries
    eu_27_tax_deficits = tax_deficits[
        tax_deficits[&#39;Parent jurisdiction (alpha-3 code)&#39;].isin(
            eu_27_country_codes
        )
    ].copy()

    # We focus only on a few non-EU countries, defined when the TaxDeficitCalculator object is instantiated
    tax_deficits = tax_deficits[
        tax_deficits[&#39;Parent jurisdiction (alpha-3 code)&#39;].isin(
            self.country_list_intermediary_scenario
        )
    ].copy()

    # We store the results in a dictionary, which we will map upon the eu_27_tax_deficits DataFrame
    additional_revenue_gains = {}

    # We iterate over EU-27 countries and compute for eacht he tax deficit collected from non-EU multinationals
    for eu_country in eu_27_country_codes:

        td_df = tax_deficits.copy()

        # This dictionary will store the attribution ratios based on extra-group sales to be mapped upon td_df
        attribution_ratios = {}

        # We iterate over non-EU countries in our list
        for country in self.country_list_intermediary_scenario:

            oecd_restricted = oecd[oecd[&#39;Parent jurisdiction (alpha-3 code)&#39;] == country].copy()

            # We fetch the extra-group sales registered by the non-EU country&#39;s multinationals in the EU-27 country
            # (defaults to 0 if the EU-27 country is not among the partners of the non-EU country)
            sales_in_eu_country = oecd_restricted[
                oecd_restricted[&#39;Partner jurisdiction (alpha-3 code)&#39;] == eu_country
            ][&#39;Unrelated Party Revenues&#39;].sum()

            # We compute the total extra-group sales registered by the non-EU country&#39;s multinationals worldwide
            total_sales = oecd_restricted[&#39;Unrelated Party Revenues&#39;].sum()

            # We deduce the share of the non-EU country&#39;s tax deficit attributable to the EU-27 country
            attribution_ratios[country] = sales_in_eu_country / total_sales

        # We map the attribution_ratios dictionary upon the td_df DataFrame
        td_df[&#39;Attribution ratios&#39;] = td_df[&#39;Parent jurisdiction (alpha-3 code)&#39;].map(attribution_ratios)

        # We deduce, for each non-EU country, the amount of its tax deficit that is collected by the EU-27 country
        td_df[&#39;Collectible tax deficit&#39;] = td_df[&#39;Attribution ratios&#39;] * td_df[&#39;tax_deficit&#39;]

        # We sum all these and multiply the total by 2 to estimate the total tax deficit that the EU-27 country
        # could collect from non-EU multinationals
        additional_revenue_gains[eu_country] = td_df[&#39;Collectible tax deficit&#39;].sum() * 2

        # NB: the multiplication by 2 corresponds to the imputation strategy defined in Appendix C of the report

    # We map the resulting dictionary upon the eu_27_tax_deficits DataFrame
    eu_27_tax_deficits[&#39;From foreign MNEs&#39;] = eu_27_tax_deficits[&#39;Parent jurisdiction (alpha-3 code)&#39;].map(
        additional_revenue_gains
    )

    # And deduce total corporate tax revenue gains from such a scenario for all EU-27 countries
    eu_27_tax_deficits[&#39;Total&#39;] = (
        eu_27_tax_deficits[&#39;tax_deficit&#39;] + eu_27_tax_deficits[&#39;From foreign MNEs&#39;]
    )

    # We operate a similar process for &#34;Europe&#34; and &#34;Other Europe&#34; field
    additional_revenue_gains = {}

    for aggregate in [&#39;Europe&#39;, &#39;Other Europe&#39;]:

        td_df = tax_deficits.copy()

        attribution_ratios = {}

        for country in self.country_list_intermediary_scenario:

            # We do not consider the &#34;Other Europe&#34; field in the US CbCR as it probably does not correspond to
            # activities operated in EU-27 countries (sufficient country-by-country breakdown to exclude this)
            if country == &#39;USA&#39;:
                attribution_ratios[country] = 0

                continue

            oecd_restricted = oecd[oecd[&#39;Parent jurisdiction (alpha-3 code)&#39;] == country].copy()

            sales_in_europe_or_other_europe = oecd_restricted[
                oecd_restricted[&#39;Partner jurisdiction (whitespaces cleaned)&#39;] == aggregate
            ][&#39;Unrelated Party Revenues&#39;].sum()

            total_sales = oecd_restricted[&#39;Unrelated Party Revenues&#39;].sum()

            attribution_ratios[country] = sales_in_europe_or_other_europe / total_sales

        td_df[&#39;Attribution ratios&#39;] = td_df[&#39;Parent jurisdiction (alpha-3 code)&#39;].map(attribution_ratios)

        td_df[&#39;Collectible tax deficit&#39;] = td_df[&#39;Attribution ratios&#39;] * td_df[&#39;tax_deficit&#39;]

        additional_revenue_gains[aggregate] = td_df[&#39;Collectible tax deficit&#39;].sum()

    # We drop unnecessary columns
    eu_27_tax_deficits.drop(
        columns=[&#39;Parent jurisdiction (alpha-3 code)&#39;],
        inplace=True
    )

    # And we operate very inelegant transformations of the DataFrame to add the &#34;Other Europe&#34;, &#34;Europe&#34; and &#34;Total&#34;
    # fields at the bottom of the DataFrame
    eu_27_tax_deficits.reset_index(drop=True, inplace=True)

    dict_df = eu_27_tax_deficits.to_dict()

    dict_df[eu_27_tax_deficits.columns[0]][len(eu_27_tax_deficits)] = &#39;Other Europe&#39;
    dict_df[eu_27_tax_deficits.columns[1]][len(eu_27_tax_deficits)] = 0
    dict_df[eu_27_tax_deficits.columns[2]][len(eu_27_tax_deficits)] = additional_revenue_gains[&#39;Other Europe&#39;]
    dict_df[eu_27_tax_deficits.columns[3]][len(eu_27_tax_deficits)] = additional_revenue_gains[&#39;Other Europe&#39;]

    dict_df[eu_27_tax_deficits.columns[0]][len(eu_27_tax_deficits) + 1] = &#39;Europe&#39;
    dict_df[eu_27_tax_deficits.columns[1]][len(eu_27_tax_deficits) + 1] = 0
    dict_df[eu_27_tax_deficits.columns[2]][len(eu_27_tax_deficits) + 1] = additional_revenue_gains[&#39;Europe&#39;]
    dict_df[eu_27_tax_deficits.columns[3]][len(eu_27_tax_deficits) + 1] = additional_revenue_gains[&#39;Europe&#39;]

    # Here we compute total corporate tax revenue gains for EU-27 countries
    # NB: We have not multiplied the &#34;Other Europe&#34; and &#34;Europe&#34; fields by 2 (no imputation for these)
    total_additional_revenue_gain = eu_27_tax_deficits[&#39;From foreign MNEs&#39;].sum() \
        + additional_revenue_gains[&#39;Europe&#39;] \
        + additional_revenue_gains[&#39;Other Europe&#39;]

    dict_df[eu_27_tax_deficits.columns[0]][len(eu_27_tax_deficits) + 2] = &#39;Total&#39;
    dict_df[eu_27_tax_deficits.columns[1]][len(eu_27_tax_deficits) + 2] = eu_27_tax_deficit
    dict_df[eu_27_tax_deficits.columns[2]][len(eu_27_tax_deficits) + 2] = total_additional_revenue_gain
    dict_df[eu_27_tax_deficits.columns[3]][len(eu_27_tax_deficits) + 2] = \
        eu_27_tax_deficit + total_additional_revenue_gain

    eu_27_tax_deficits = pd.DataFrame.from_dict(dict_df)

    # We convert 2021 EUR figures into 2021 billion EUR
    for column_name in eu_27_tax_deficits.columns[1:]:
        eu_27_tax_deficits[column_name] /= 10**6

    return eu_27_tax_deficits.copy()</code></pre>
</details>
</dd>
<dt id="tax_deficit_simulator.calculator.TaxDeficitCalculator.compute_unilateral_scenario_gain"><code class="name flex">
<span>def <span class="ident">compute_unilateral_scenario_gain</span></span>(<span>self, country, minimum_ETR=0.25)</span>
</code></dt>
<dd>
<div class="desc"><p>This method encapsulates most of the computations for the unilateral implementation scenario.</p>
<p>It takes as input:</p>
<ul>
<li>
<p>the name of the country assumed to unilaterally implement the tax deficit collection;</p>
</li>
<li>
<p>the minimum effective tax rate that it applies when collecting the full tax deficit of its multinationals and
a part of the tax deficit of foreign multinationals, based on the location of their sales.</p>
</li>
</ul>
<p>The output of this method is a DataFrame organized as follows:</p>
<ul>
<li>
<p>each row is a headquarter country whose tax deficit would be collected partly or entirely by the taxing coun-
try (including the taxing country which collects 100% of the tax deficit of its multinationals);</p>
</li>
<li>
<p>there are two columns, with the name of the headquarter country considered and the tax deficit amount that
could be collected from its multinationals by the taxing country.</p>
</li>
</ul>
<p>Figures are presented in 2021 EUR.</p>
<p>Important disclaimer: for now, this method is not robust to variations in the country name, i.e. only country
names as presented in the OECD CbCR data will generate a result. These are the country names that are proposed
in the selectbox on the online simulator.</p>
<p>The methogology behind these computations is described in much more details in Appendix B of the report.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_unilateral_scenario_gain(self, country, minimum_ETR=0.25):
    &#34;&#34;&#34;
    This method encapsulates most of the computations for the unilateral implementation scenario.

    It takes as input:

    - the name of the country assumed to unilaterally implement the tax deficit collection;

    - the minimum effective tax rate that it applies when collecting the full tax deficit of its multinationals and
    a part of the tax deficit of foreign multinationals, based on the location of their sales.

    The output of this method is a DataFrame organized as follows:

    - each row is a headquarter country whose tax deficit would be collected partly or entirely by the taxing coun-
    try (including the taxing country which collects 100% of the tax deficit of its multinationals);

    - there are two columns, with the name of the headquarter country considered and the tax deficit amount that
    could be collected from its multinationals by the taxing country.

    Figures are presented in 2021 EUR.

    Important disclaimer: for now, this method is not robust to variations in the country name, i.e. only country
    names as presented in the OECD CbCR data will generate a result. These are the country names that are proposed
    in the selectbox on the online simulator.

    The methogology behind these computations is described in much more details in Appendix B of the report.
    &#34;&#34;&#34;

    # We start from the total tax deficits of all countries which can be partly re-allocated to the taxing country
    tax_deficits = self.get_total_tax_deficits(minimum_ETR=minimum_ETR)

    # The OECD data provides the information of extra-group sales, needed to allocate foreign tax deficits
    oecd = self.oecd.copy()

    # We simply convert the name of the taxing country to the corresponding alpha-3 code
    taxing_country = country
    try:
        taxing_country_code = self.oecd[
            self.oecd[&#39;Parent jurisdiction (whitespaces cleaned)&#39;] == taxing_country
        ][&#39;Parent jurisdiction (alpha-3 code)&#39;].iloc[0]
    except:
        taxing_country_code = self.twz[
            self.twz[&#39;Country&#39;] == taxing_country
        ][&#39;Alpha-3 country code&#39;].iloc[0]

    # This list will store the allocation ratios (for each headquarter country, the share of its tax deficit that
    # can be collected by the taxing country) computed based on the location of extra-group sales
    attribution_ratios = []

    # We iterate over parent countries in the OECD data
    for country_code in tax_deficits[&#39;Parent jurisdiction (alpha-3 code)&#39;].values:

        # The taxing country collects 100% of the tax deficit of its own multinationals
        if country_code == taxing_country_code:
            attribution_ratios.append(1)

        # If the parent country is not the taxing country
        else:
            # We restrict the DataFrame to the CbCR of the considered parent country
            oecd_restricted = oecd[oecd[&#39;Parent jurisdiction (alpha-3 code)&#39;] == country_code].copy()

            # If the taxing country is not part of its partner jurisdictions, the attribution ratio is of 0
            if taxing_country_code not in oecd_restricted[&#39;Partner jurisdiction (alpha-3 code)&#39;].values:
                attribution_ratios.append(0)

            else:
                # We fetch extra-group sales registered in the taxing country
                mask = (oecd_restricted[&#39;Partner jurisdiction (alpha-3 code)&#39;] == taxing_country_code)
                sales_in_taxing_country = oecd_restricted[mask][&#39;Unrelated Party Revenues&#39;].iloc[0]

                # We compute total extra-group sales
                total_sales = oecd_restricted[&#39;Unrelated Party Revenues&#39;].sum()

                # We append the resulting ratio to the list of attribution ratios
                attribution_ratios.append(sales_in_taxing_country / total_sales)

    # We add this list to the DataFrame as a new column
    tax_deficits[&#39;Attribution ratios&#39;] = attribution_ratios

    # We deduce, for each headquarter country, the tax deficit that could be collected by the taxing country
    tax_deficits[f&#39;Collectible tax deficit for {taxing_country}&#39;] = \
        tax_deficits[&#39;tax_deficit&#39;] * tax_deficits[&#39;Attribution ratios&#39;]

    # We eliminate irrelevant columns
    tax_deficits.drop(
        columns=[
            &#39;Attribution ratios&#39;,
            &#39;tax_deficit&#39;,
            &#39;Parent jurisdiction (alpha-3 code)&#39;
        ],
        inplace=True
    )

    # We filter out rows for which the collectible tax deficit is 0
    tax_deficits = tax_deficits[tax_deficits[f&#39;Collectible tax deficit for {taxing_country}&#39;] &gt; 0].copy()

    # We sort values based on the resulting tax deficit, in descending order
    tax_deficits.sort_values(
        by=f&#39;Collectible tax deficit for {taxing_country}&#39;,
        ascending=False,
        inplace=True
    )

    # Because the OECD data only gather 26 headquarter countries, we need to make an assumption on the tax deficit
    # that could be collected from other parent countries, excluded from the 2016 version of the data

    # We therefore double the tax deficit collected from non-US foreign countries
    imputation = tax_deficits[
        ~tax_deficits[&#39;Parent jurisdiction (whitespaces cleaned)&#39;].isin([taxing_country, &#39;United States&#39;])
    ][f&#39;Collectible tax deficit for {taxing_country}&#39;].sum()

    # Except for Germany, for which we add back only half of the tax deficit collected from non-US foreign countries
    if taxing_country_code == &#39;DEU&#39;:
        imputation /= 2

    tax_deficits.reset_index(drop=True, inplace=True)

    # Again the same inelegant way of adding &#34;Total&#34; fields at the end of the DataFrame
    dict_df = tax_deficits.to_dict()

    dict_df[tax_deficits.columns[0]][len(tax_deficits)] = &#39;Others (imputation)&#39;
    dict_df[tax_deficits.columns[1]][len(tax_deficits)] = imputation

    dict_df[tax_deficits.columns[0]][len(tax_deficits) + 1] = &#39;Total&#39;
    dict_df[tax_deficits.columns[1]][len(tax_deficits) + 1] = (
        tax_deficits[tax_deficits.columns[1]].sum() + imputation
    )

    df = pd.DataFrame.from_dict(dict_df)

    return df.copy()</code></pre>
</details>
</dd>
<dt id="tax_deficit_simulator.calculator.TaxDeficitCalculator.get_alternative_non_haven_factor"><code class="name flex">
<span>def <span class="ident">get_alternative_non_haven_factor</span></span>(<span>self, minimum_ETR)</span>
</code></dt>
<dd>
<div class="desc"><p>Looking at the formula (A2) of Appendix A and at the previous method, we see that for a 15% tax rate, this impu-
tation would result in no tax deficit to be collected from non-tax haven jurisdictions. Thus, we correct for
this underestimation by computing the ratio of the tax deficit that can be collected in non-tax havens at a 15%
and a 25% rate for OECD-reporting countries.</p>
<p>This class method allows to compute this alternative imputation ratio.</p>
<p>The methodology is described in more details in the Appendix A of the report.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_alternative_non_haven_factor(self, minimum_ETR):
    &#34;&#34;&#34;
    Looking at the formula (A2) of Appendix A and at the previous method, we see that for a 15% tax rate, this impu-
    tation would result in no tax deficit to be collected from non-tax haven jurisdictions. Thus, we correct for
    this underestimation by computing the ratio of the tax deficit that can be collected in non-tax havens at a 15%
    and a 25% rate for OECD-reporting countries.

    This class method allows to compute this alternative imputation ratio.

    The methodology is described in more details in the Appendix A of the report.
    &#34;&#34;&#34;

    # We need to have previously loaded and cleaned the OECD data
    if self.oecd is None:
        raise Exception(&#39;You first need to load clean data with the dedicated method and inplace=True.&#39;)

    # This method is only useful if the previous one yields a ratio of 0, i.e. if the minimum ETR is of 20% or less
    if minimum_ETR &gt; 0.2:
        raise Exception(&#39;These computations are only used when the minimum ETR considered is 0.2 or less.&#39;)

    # We use the get_stratified_oecd_data to compute the non-haven tax deficit of OECD-reporting countries
    oecd_stratified = self.get_stratified_oecd_data(
        minimum_ETR=self.reference_rate_for_alternative_imputation
    )

    # We exclude countries whose CbCR breakdown does not allow to distinguish tax-haven and non-haven profits
    df_restricted = oecd_stratified[
        ~oecd_stratified[&#39;Parent jurisdiction (alpha-3 code)&#39;].isin(
            COUNTRIES_WITH_CONTINENTAL_REPORTING + COUNTRIES_WITH_MINIMUM_REPORTING
        )
    ].copy()

    # The denominator is the total non-haven tax deficit of relevant countries at the reference minimum ETR
    denominator = df_restricted[&#39;tax_deficit_x_non_haven&#39;].sum()

    # We follow the same process, running computations at the minimum ETR this time
    oecd_stratified = self.get_stratified_oecd_data(minimum_ETR=minimum_ETR)

    # We exclude countries whose CbCR breakdown does not allow to distinguish tax-haven and non-haven profits
    df_restricted = oecd_stratified[
        ~oecd_stratified[&#39;Parent jurisdiction (alpha-3 code)&#39;].isin(
            COUNTRIES_WITH_CONTINENTAL_REPORTING + COUNTRIES_WITH_MINIMUM_REPORTING
        )
    ].copy()

    # The numerator is the total non-haven tax deficit of relevant countries at the selected minimum ETR
    numerator = df_restricted[&#39;tax_deficit_x_non_haven&#39;].sum()

    return numerator / denominator</code></pre>
</details>
</dd>
<dt id="tax_deficit_simulator.calculator.TaxDeficitCalculator.get_carve_outs_rate_table"><code class="name flex">
<span>def <span class="ident">get_carve_outs_rate_table</span></span>(<span>self, minimum_ETR, depreciation_only, exclude_inventories)</span>
</code></dt>
<dd>
<div class="desc"><p>This function takes as inputs:</p>
<ul>
<li>
<p>the minimum effective tax rate to apply to multinationals' profits;</p>
</li>
<li>
<p>a boolean, "depreciation_only", indicating whether to restrict the tangible assets component of substance-
based carve-outs to a share of depreciation expenses;</p>
</li>
<li>
<p>a boolean, "exlude_inventories", indicating whether to exlude inventories from tangible assets or not.</p>
</li>
</ul>
<p>It returns a DataFrame that shows, for each in-sample country, the estimated revenues that could be collected
from a global minimum tax without any carve-outs and with carve-outs of 5%, 7.5% and 10% of tangible assets and
payroll combined.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_carve_outs_rate_table(
    self,
    minimum_ETR,
    depreciation_only, exclude_inventories,
):
    &#34;&#34;&#34;
    This function takes as inputs:

    - the minimum effective tax rate to apply to multinationals&#39; profits;

    - a boolean, &#34;depreciation_only&#34;, indicating whether to restrict the tangible assets component of substance-
    based carve-outs to a share of depreciation expenses;

    - a boolean, &#34;exlude_inventories&#34;, indicating whether to exlude inventories from tangible assets or not.

    It returns a DataFrame that shows, for each in-sample country, the estimated revenues that could be collected
    from a global minimum tax without any carve-outs and with carve-outs of 5%, 7.5% and 10% of tangible assets and
    payroll combined.
    &#34;&#34;&#34;

    # We instantiate a TaxDeficitCalculator object without carve-outs
    calculator = TaxDeficitCalculator()

    calculator.load_clean_data()

    # We use it to compute revenue gains without any carve-out
    td_no_carve_out = calculator.get_total_tax_deficits(minimum_ETR=minimum_ETR).iloc[:-2]

    td_no_carve_out.rename(
        columns={
            &#39;tax_deficit&#39;: &#39;tax_deficit_no_carve_out&#39;
        },
        inplace=True
    )

    # A copy of the resulting DataFrame will be used as a central table to which we add the relevant columns
    merged_df = td_no_carve_out.copy()

    # We iterate over carve-out rates
    for carve_out_rate in [5, 7.5, 10]:
        actual_rate = carve_out_rate / 100

        # We instantiate a TaxDeficitCalculator object with carve-outs at the rate considered
        calculator = TaxDeficitCalculator(
            carve_outs=True, carve_out_rate=actual_rate,
            depreciation_only=False, exclude_inventories=exclude_inventories
        )
        calculator.load_clean_data()

        # We use it to compute revenue gains with substance-based carve-outs being applied
        td_carve_out = calculator.get_total_tax_deficits(minimum_ETR=minimum_ETR).iloc[:-2]

        # We add the tax deficits thereby computed to the central table
        merged_df = merged_df.merge(
            td_carve_out[[&#39;Parent jurisdiction (alpha-3 code)&#39;, &#39;tax_deficit&#39;]],
            how=&#39;left&#39;,
            on=&#39;Parent jurisdiction (alpha-3 code)&#39;
        )

        merged_df[&#39;tax_deficit&#39;] = merged_df[&#39;tax_deficit&#39;].fillna(0)

        merged_df.rename(
            columns={
                &#39;tax_deficit&#39;: f&#39;tax_deficit_{carve_out_rate}_carve_out&#39;
            },
            inplace=True
        )

    # We only display EU or CbCR-reporting countries
    cbcr_reporting_countries = list(self.oecd[&#39;Parent jurisdiction (alpha-3 code)&#39;].unique())

    mask_eu = merged_df[&#39;Parent jurisdiction (alpha-3 code)&#39;].isin(eu_27_country_codes)
    mask_cbcr = merged_df[&#39;Parent jurisdiction (alpha-3 code)&#39;].isin(cbcr_reporting_countries)

    # This condition is encapsulated in the following boolean indexing mask
    mask = np.logical_or(mask_eu, mask_cbcr)

    # We add two useful indicator variables
    merged_df[&#39;IS_EU&#39;] = mask_eu * 1
    merged_df[&#39;REPORTS_CbCR&#39;] = mask_cbcr * 1

    # And we restrict the DataFrame to relevant countries
    restricted_df = merged_df[mask].copy()

    # We finalise the formatting of the table
    restricted_df.sort_values(
        by=[&#39;IS_EU&#39;, &#39;Parent jurisdiction (alpha-3 code)&#39;],
        ascending=[False, True],
        inplace=True
    )

    # And eventually return the DataFrame
    return restricted_df.copy()</code></pre>
</details>
</dd>
<dt id="tax_deficit_simulator.calculator.TaxDeficitCalculator.get_carve_outs_table"><code class="name flex">
<span>def <span class="ident">get_carve_outs_table</span></span>(<span>self, TWZ_countries_methodology, depreciation_only, exclude_inventories, carve_out_rate=0.05)</span>
</code></dt>
<dd>
<div class="desc"><p>This function takes as input:</p>
<ul>
<li>
<p>the methodology to use to estimate the post-carve-out revenue gains of TWZ countries;</p>
</li>
<li>
<p>a boolean, "depreciation_only", indicating whether to restrict the tangible assets component of substance-
based carve-outs to a share of depreciation expenses;</p>
</li>
<li>
<p>a boolean, "exlude_inventories", indicating whether to exlude inventories from tangible assets or not;</p>
</li>
<li>
<p>the carve-out rate to use (which defaults to 5%).</p>
</li>
</ul>
<p>It returns a DataFrame that shows, for the 15% and 25% minimum rates and for each in-sample country, the estima-
ted revenue gains from a global minimum tax without and with carve-outs being applied.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_carve_outs_table(
    self,
    TWZ_countries_methodology,
    depreciation_only, exclude_inventories,
    carve_out_rate=0.05
):
    &#34;&#34;&#34;
    This function takes as input:

    - the methodology to use to estimate the post-carve-out revenue gains of TWZ countries;

    - a boolean, &#34;depreciation_only&#34;, indicating whether to restrict the tangible assets component of substance-
    based carve-outs to a share of depreciation expenses;

    - a boolean, &#34;exlude_inventories&#34;, indicating whether to exlude inventories from tangible assets or not;

    - the carve-out rate to use (which defaults to 5%).

    It returns a DataFrame that shows, for the 15% and 25% minimum rates and for each in-sample country, the estima-
    ted revenue gains from a global minimum tax without and with carve-outs being applied.
    &#34;&#34;&#34;

    # We need to have previously loaded and cleaned the OECD data
    if self.oecd is None:
        raise Exception(&#39;You first need to load clean data with the dedicated method and inplace=True.&#39;)

    # The &#34;TWZ_countries_methodology&#34; argument can only take a few string values
    if TWZ_countries_methodology not in [&#39;initial&#39;, &#39;new&#39;]:
        raise Exception(&#39;The &#34;TWZ_countries_methodology&#34; argument only accepts two values: &#34;initial&#34; or &#34;new&#34;.&#39;)

    # Computing tax deficits without substance-based carve-outs
    calculator = TaxDeficitCalculator()

    calculator.load_clean_data()

    td_25 = calculator.get_total_tax_deficits(minimum_ETR=0.25).iloc[:-2, :]
    td_15 = calculator.get_total_tax_deficits(minimum_ETR=0.15).iloc[:-2, :]

    # We merge the resulting DataFrames for the 15% and 25% minimum rates
    merged_df = td_25.merge(
        td_15[[&#39;Parent jurisdiction (alpha-3 code)&#39;, &#39;tax_deficit&#39;]],
        how=&#39;left&#39;,
        on=&#39;Parent jurisdiction (alpha-3 code)&#39;
    )

    merged_df[&#39;tax_deficit_y&#39;] = merged_df[&#39;tax_deficit_y&#39;].fillna(0)

    merged_df.rename(
        columns={
            &#39;tax_deficit_x&#39;: &#39;tax_deficit_25_no_carve_out&#39;,
            &#39;tax_deficit_y&#39;: &#39;tax_deficit_15_no_carve_out&#39;
        },
        inplace=True
    )

    # Computing corresponding tax deficits with substance-based carve-outs
    calculator = TaxDeficitCalculator(
        carve_outs=True, carve_out_rate=carve_out_rate,
        depreciation_only=depreciation_only, exclude_inventories=exclude_inventories
    )

    calculator.load_clean_data()

    td_25 = calculator.get_total_tax_deficits(minimum_ETR=0.25).iloc[:-2]
    td_15 = calculator.get_total_tax_deficits(minimum_ETR=0.15).iloc[:-2]

    # We merge the DataFrame obtained for the 25% minimum rate
    merged_df = merged_df.merge(
        td_25[[&#39;Parent jurisdiction (alpha-3 code)&#39;, &#39;tax_deficit&#39;]],
        how=&#39;left&#39;,
        on=&#39;Parent jurisdiction (alpha-3 code)&#39;
    )

    merged_df.rename(
        columns={
            &#39;tax_deficit&#39;: &#39;tax_deficit_25_with_carve_out&#39;
        },
        inplace=True
    )

    # We merge the DataFrame obtained for the 15% minimum rate
    merged_df = merged_df.merge(
        td_15[[&#39;Parent jurisdiction (alpha-3 code)&#39;, &#39;tax_deficit&#39;]],
        how=&#39;left&#39;,
        on=&#39;Parent jurisdiction (alpha-3 code)&#39;
    )

    merged_df[&#39;tax_deficit&#39;] = merged_df[&#39;tax_deficit&#39;].fillna(0)

    merged_df.rename(
        columns={
            &#39;tax_deficit&#39;: &#39;tax_deficit_15_with_carve_out&#39;
        },
        inplace=True
    )

    # We only show EU and/or CbCR-reporting countries
    cbcr_reporting_countries = list(self.oecd[&#39;Parent jurisdiction (alpha-3 code)&#39;].unique())

    mask_eu = merged_df[&#39;Parent jurisdiction (alpha-3 code)&#39;].isin(eu_27_country_codes)
    mask_cbcr = merged_df[&#39;Parent jurisdiction (alpha-3 code)&#39;].isin(cbcr_reporting_countries)

    # This condition is encapsulated in this boolean indexing mask
    mask = np.logical_or(mask_eu, mask_cbcr)

    # We add two useful indicator variables
    merged_df[&#39;IS_EU&#39;] = mask_eu * 1
    merged_df[&#39;REPORTS_CbCR&#39;] = mask_cbcr * 1

    # And we restrict the DataFrame to relevant countries
    restricted_df = merged_df[mask].copy()

    # We finalise the reformatting of the DataFrame
    restricted_df.sort_values(
        by=[&#39;IS_EU&#39;, &#39;Parent jurisdiction (alpha-3 code)&#39;],
        ascending=[False, True],
        inplace=True
    )

    if TWZ_countries_methodology == &#39;initial&#39;:
        # If we have opted for the &#34;initial&#34; methodology for TWZ countries, we can simply return the DataFrame as is
        return restricted_df.copy()

    else:
        # If we have chosen the &#34;new&#34; methodology, we have a bit more work!

        # We create a temporary copy of the DataFrame, restricted to CbCR-reporting countries (excluding Sweden)
        temp = restricted_df[restricted_df[&#39;REPORTS_CbCR&#39;] == 1].copy()
        temp = temp[temp[&#39;Parent jurisdiction (alpha-3 code)&#39;] != &#39;SWE&#39;].copy()

        # We deduce the average reduction factors to apply to the collectible tax deficits of TWZ countries
        self.imputation_15 = temp[&#39;tax_deficit_15_with_carve_out&#39;].sum() / temp[&#39;tax_deficit_15_no_carve_out&#39;].sum()
        self.imputation_25 = temp[&#39;tax_deficit_25_with_carve_out&#39;].sum() / temp[&#39;tax_deficit_25_no_carve_out&#39;].sum()

        # We apply the two downgrade factors to tax deficits without carve-outs
        restricted_df[&#39;tax_deficit_15_with_carve_out&#39;] = restricted_df.apply(
            (
                lambda row: row[&#39;tax_deficit_15_no_carve_out&#39;] * self.imputation_15 if row[&#39;REPORTS_CbCR&#39;] == 0 or
                row[&#39;Parent jurisdiction (alpha-3 code)&#39;] == &#39;SWE&#39; else row[&#39;tax_deficit_15_with_carve_out&#39;]
            ),
            axis=1
        )

        restricted_df[&#39;tax_deficit_25_with_carve_out&#39;] = restricted_df.apply(
            (
                lambda row: row[&#39;tax_deficit_25_no_carve_out&#39;] * self.imputation_25 if row[&#39;REPORTS_CbCR&#39;] == 0 or
                row[&#39;Parent jurisdiction (alpha-3 code)&#39;] == &#39;SWE&#39; else row[&#39;tax_deficit_25_with_carve_out&#39;]
            ),
            axis=1
        )

        # And we return the adjusted DataFrame
        return restricted_df.copy()</code></pre>
</details>
</dd>
<dt id="tax_deficit_simulator.calculator.TaxDeficitCalculator.get_carve_outs_table_2"><code class="name flex">
<span>def <span class="ident">get_carve_outs_table_2</span></span>(<span>self, exclude_inventories, depreciation_only, carve_out_rate=0.05, output_Excel=False)</span>
</code></dt>
<dd>
<div class="desc"><p>This function takes as input:</p>
<ul>
<li>
<p>a boolean, "depreciation_only", indicating whether to restrict the tangible assets component of substance-
based carve-outs to a share of depreciation expenses;</p>
</li>
<li>
<p>a boolean, "exlude_inventories", indicating whether to exlude inventories from tangible assets or not;</p>
</li>
<li>
<p>the carve-out rate to use (which defaults to 5%).</p>
</li>
</ul>
<p>It returns a DataFrame that shows, for the different minimum effective tax rates and for each in-sample country,
the estimated impact of substance-based carve-outs. The change is expressed as a percentage of revenue gain es-
timates without substance-based carve-outs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_carve_outs_table_2(
    self,
    exclude_inventories, depreciation_only,
    carve_out_rate=0.05,
    output_Excel=False
):
    &#34;&#34;&#34;
    This function takes as input:

    - a boolean, &#34;depreciation_only&#34;, indicating whether to restrict the tangible assets component of substance-
    based carve-outs to a share of depreciation expenses;

    - a boolean, &#34;exlude_inventories&#34;, indicating whether to exlude inventories from tangible assets or not;

    - the carve-out rate to use (which defaults to 5%).

    It returns a DataFrame that shows, for the different minimum effective tax rates and for each in-sample country,
    the estimated impact of substance-based carve-outs. The change is expressed as a percentage of revenue gain es-
    timates without substance-based carve-outs.
    &#34;&#34;&#34;

    # The &#34;get_carve_outs_table&#34; method provides the required information for two minimum ETRs, 15% and 25%
    # This will serve as a central DataFrame to which we will add the 21% and 30% columns
    df = self.get_carve_outs_table(
        TWZ_countries_methodology=&#39;initial&#39;,
        exclude_inventories=exclude_inventories, depreciation_only=depreciation_only,
        carve_out_rate=carve_out_rate
    )

    # Computing tax deficits without substance-based carve-outs
    calculator = TaxDeficitCalculator()

    calculator.load_clean_data()

    td_21 = calculator.get_total_tax_deficits(minimum_ETR=0.21).iloc[:-2, :]
    td_30 = calculator.get_total_tax_deficits(minimum_ETR=0.3).iloc[:-2, :]

    # We add the 21% tax deficit to the central DataFrame
    merged_df = df.merge(
        td_21[[&#39;Parent jurisdiction (alpha-3 code)&#39;, &#39;tax_deficit&#39;]],
        how=&#39;left&#39;,
        on=&#39;Parent jurisdiction (alpha-3 code)&#39;
    )

    merged_df[&#39;tax_deficit&#39;] = merged_df[&#39;tax_deficit&#39;].fillna(0)

    # We add the 30% tax deficit to the central DataFrame
    merged_df = merged_df.merge(
        td_30[[&#39;Parent jurisdiction (alpha-3 code)&#39;, &#39;tax_deficit&#39;]],
        how=&#39;left&#39;,
        on=&#39;Parent jurisdiction (alpha-3 code)&#39;
    )

    merged_df[&#39;tax_deficit_y&#39;] = merged_df[&#39;tax_deficit_y&#39;].fillna(0)

    merged_df.rename(
        columns={
            &#39;tax_deficit_x&#39;: &#39;tax_deficit_21_no_carve_out&#39;,
            &#39;tax_deficit_y&#39;: &#39;tax_deficit_30_no_carve_out&#39;
        },
        inplace=True
    )

    # Computing corresponding tax deficits with substance-based carve-outs
    calculator = TaxDeficitCalculator(
        carve_outs=True,
        carve_out_rate=carve_out_rate,
        depreciation_only=depreciation_only,
        exclude_inventories=exclude_inventories
    )

    calculator.load_clean_data()

    td_21 = calculator.get_total_tax_deficits(minimum_ETR=0.21).iloc[:-2]
    td_30 = calculator.get_total_tax_deficits(minimum_ETR=0.3).iloc[:-2]

    # We add the 21% tax deficit with carve-outs to the central DataFrame
    merged_df = merged_df.merge(
        td_21[[&#39;Parent jurisdiction (alpha-3 code)&#39;, &#39;tax_deficit&#39;]],
        how=&#39;left&#39;,
        on=&#39;Parent jurisdiction (alpha-3 code)&#39;
    )

    merged_df[&#39;tax_deficit&#39;] = merged_df[&#39;tax_deficit&#39;].fillna(0)

    merged_df.rename(
        columns={
            &#39;tax_deficit&#39;: &#39;tax_deficit_21_with_carve_out&#39;
        },
        inplace=True
    )

    # We add the 30% tax deficit with carve-outs to the central DataFrame
    merged_df = merged_df.merge(
        td_30[[&#39;Parent jurisdiction (alpha-3 code)&#39;, &#39;tax_deficit&#39;]],
        how=&#39;left&#39;,
        on=&#39;Parent jurisdiction (alpha-3 code)&#39;
    )

    merged_df[&#39;tax_deficit&#39;] = merged_df[&#39;tax_deficit&#39;].fillna(0)

    merged_df.rename(
        columns={
            &#39;tax_deficit&#39;: &#39;tax_deficit_30_with_carve_out&#39;
        },
        inplace=True
    )

    # We have the tax deficit absolute amounts with and without carve-outs at 15%, 21%, 25% and 30% minimum rates
    # But we want to display the changes due to carve-outs, as a % of the no-carve-out tax deficit

    # We store the names of the 4 columns that we are going to add to the central DataFrame
    new_columns = []

    # We iterate over the 4 minimum rates
    for minimum_rate in [15, 21, 25, 30]:
        column_name_no_carve_out = f&#39;tax_deficit_{minimum_rate}_no_carve_out&#39;
        column_name_with_carve_out = f&#39;tax_deficit_{minimum_rate}_with_carve_out&#39;

        # We are going to add a new column that provides the % reduction due to carve-outs at the rate considered
        new_column_name = f&#39;reduction_at_{minimum_rate}_minimum_rate&#39;

        # We make the corresponding computation
        merged_df[new_column_name] = (
            (merged_df[column_name_with_carve_out] - merged_df[column_name_no_carve_out]) /
            merged_df[column_name_no_carve_out]
        ) * 100

        new_columns.append(new_column_name)

    if output_Excel:
        with pd.ExcelWriter(&#39;/Users/Paul-Emmanuel/Desktop/carve_outs_table_2.xlsx&#39;, engine=&#39;xlsxwriter&#39;) as writer:
            merged_df.to_excel(writer, sheet_name=&#39;table_2&#39;, index=False)

    # We output the resulting DataFrame with country codes and names, as well as the 4 columns of interest
    merged_df = merged_df[
        [&#39;Parent jurisdiction (alpha-3 code)&#39;, &#39;Parent jurisdiction (whitespaces cleaned)&#39;] + new_columns
    ].copy()

    return merged_df.copy()</code></pre>
</details>
</dd>
<dt id="tax_deficit_simulator.calculator.TaxDeficitCalculator.get_non_haven_imputation_ratio"><code class="name flex">
<span>def <span class="ident">get_non_haven_imputation_ratio</span></span>(<span>self, minimum_ETR)</span>
</code></dt>
<dd>
<div class="desc"><p>For non-OECD reporting countries, we base our estimates on data compiled by Tørsløv, Wier and Zucman (2019).
These allow to compute domestic and tax-haven-based tax deficit of these countries. We extrapolate the non-haven
tax deficit of these countries from the tax-haven one.</p>
<p>We impute the tax deficit in non-haven jurisdictions by estimating the ratio of tax deficits in non-tax havens
to tax-havens for the EU non-tax haven parent countries in the CbCR data. We assume a 20% ETR in non-tax havens
and a 10% ETR in tax havens (these rates are defined in two dedicated attributes in the instantiation function).</p>
<p>This function allows to compute this ratio following the (A2) formula of Appendix A.</p>
<p>The methodology is described in more details in the Appendix A of the report.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_non_haven_imputation_ratio(self, minimum_ETR):
    &#34;&#34;&#34;
    For non-OECD reporting countries, we base our estimates on data compiled by Tørsløv, Wier and Zucman (2019).
    These allow to compute domestic and tax-haven-based tax deficit of these countries. We extrapolate the non-haven
    tax deficit of these countries from the tax-haven one.

    We impute the tax deficit in non-haven jurisdictions by estimating the ratio of tax deficits in non-tax havens
    to tax-havens for the EU non-tax haven parent countries in the CbCR data. We assume a 20% ETR in non-tax havens
    and a 10% ETR in tax havens (these rates are defined in two dedicated attributes in the instantiation function).

    This function allows to compute this ratio following the (A2) formula of Appendix A.

    The methodology is described in more details in the Appendix A of the report.
    &#34;&#34;&#34;

    # We need to have previously loaded and cleaned the OECD data
    if self.oecd is None:
        raise Exception(&#39;You first need to load clean data with the dedicated method and inplace=True.&#39;)

    # With a minimum ETR of 10%, the formula cannot be applied (division by 0), hence this case disjunction
    if minimum_ETR &gt; 0.1:
        oecd = self.oecd.copy()

        # In the computation of the imputation ratio, we only focus on:
        # - EU-27 parent countries
        mask_eu = oecd[&#39;Parent jurisdiction (alpha-3 code)&#39;].isin(eu_27_country_codes)
        # - That are not tax havens
        mask_non_haven = ~oecd[&#39;Parent jurisdiction (alpha-3 code)&#39;].isin(tax_haven_country_codes)
        # - And report a detailed country by country breakdown in their CbCR
        mask_minimum_reporting_countries = ~oecd[&#39;Parent jurisdiction (alpha-3 code)&#39;].isin(
            COUNTRIES_WITH_MINIMUM_REPORTING + COUNTRIES_WITH_CONTINENTAL_REPORTING
        )

        # We combine the boolean indexing masks
        mask = np.logical_and(mask_eu, mask_non_haven)
        mask = np.logical_and(mask, mask_minimum_reporting_countries)

        # And convert booleans into 0 / 1 integers
        mask = mask * 1

        # We compute the profits registered by retained countries in non-haven countries
        # (excluding domestic profits, cf. the earlier use of the manage_overlap_with_domestic function)
        foreign_non_haven_profits = (
            (
                mask * oecd[&#39;Is partner jurisdiction a non-haven?&#39;]
            ) * oecd[&#39;Profit (Loss) before Income Tax&#39;]
        ).sum()

        # We compute the profits registered by retained countries in tax havens
        # (excluding domestic profits, cf. the earlier use of the manage_overlap_with_domestic function)
        foreign_haven_profits = (
            (
                mask * oecd[&#39;Is partner jurisdiction a tax haven?&#39;]
            ) * oecd[&#39;Profit (Loss) before Income Tax&#39;]
        ).sum()

        # We apply the formula and compute the imputation ratio
        imputation_ratio_non_haven = (
            (
                # If the minimum ETR is below the rate assumed to be applied on non-haven profits, there is no tax
                # deficit to collect from these profits, which is why we have this max(..., 0)
                max(minimum_ETR - self.assumed_non_haven_ETR_TWZ, 0) * foreign_non_haven_profits
            ) /
            ((minimum_ETR - self.assumed_haven_ETR_TWZ) * foreign_haven_profits)
        )

    # We manage the case where the minimum ETR is of 10% and the formula cannot be applied
    elif minimum_ETR == 0.1:

        # As long as tax haven profits are assumed to be taxed at a rate of 10%, the value that we set here has no
        # effect (it will be multiplied to 0 tax-haven-based tax deficits) but to remain consistent with higher
        # values of the minimum ETR, we impute 0

        imputation_ratio_non_haven = 0

    else:
        # We do not yet manage effective tax rates below 10%
        raise Exception(&#39;Unexpected minimum ETR entered (strictly below 0.1).&#39;)

    return imputation_ratio_non_haven</code></pre>
</details>
</dd>
<dt id="tax_deficit_simulator.calculator.TaxDeficitCalculator.get_stratified_oecd_data"><code class="name flex">
<span>def <span class="ident">get_stratified_oecd_data</span></span>(<span>self, minimum_ETR=0.25)</span>
</code></dt>
<dd>
<div class="desc"><p>This method constitutes a first step in the computation of each country's collectible tax deficit in the multi-
lateral agreement scenario.</p>
<p>Taking the minimum effective tax rate as input and based on OECD data, this function outputs a DataFrame that
displays, for each OECD-reporting parent country, the tax deficit that could be collected from the domestic,
tax haven and non-haven profits of multinationals headquartered in this country.</p>
<p>The output is in 2016 USD, like the raw OECD data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_stratified_oecd_data(self, minimum_ETR=0.25):
    &#34;&#34;&#34;
    This method constitutes a first step in the computation of each country&#39;s collectible tax deficit in the multi-
    lateral agreement scenario.

    Taking the minimum effective tax rate as input and based on OECD data, this function outputs a DataFrame that
    displays, for each OECD-reporting parent country, the tax deficit that could be collected from the domestic,
    tax haven and non-haven profits of multinationals headquartered in this country.

    The output is in 2016 USD, like the raw OECD data.
    &#34;&#34;&#34;

    # We need to have previously loaded and cleaned the OECD data
    if self.oecd is None:
        raise Exception(&#39;You first need to load clean data with the dedicated method and inplace=True.&#39;)

    oecd = self.oecd.copy()

    # We only profits taxed at an effective tax rate above the minimum ETR
    oecd = oecd[oecd[&#39;ETR&#39;] &lt; minimum_ETR].copy()

    # We compute the ETR differential for all low-taxed profits
    oecd[&#39;ETR_differential&#39;] = oecd[&#39;ETR&#39;].map(lambda x: minimum_ETR - x)

    # And deduce the tax deficit generated by each Parent / Partner jurisidiction pair
    oecd[&#39;tax_deficit&#39;] = oecd[&#39;ETR_differential&#39;] * oecd[&#39;Profit (Loss) before Income Tax&#39;]

    # Using the aforementioned indicator variables allows to breakdown this tax deficit
    oecd[&#39;tax_deficit_x_domestic&#39;] = oecd[&#39;tax_deficit&#39;] * oecd[&#39;Is domestic?&#39;]
    oecd[&#39;tax_deficit_x_tax_haven&#39;] = oecd[&#39;tax_deficit&#39;] * oecd[&#39;Is partner jurisdiction a tax haven?&#39;]
    oecd[&#39;tax_deficit_x_non_haven&#39;] = oecd[&#39;tax_deficit&#39;] * oecd[&#39;Is partner jurisdiction a non-haven?&#39;]

    # We group the table by Parent jurisdiction such that for, say, France, the table displays the total domestic,
    # tax-haven and non-haven tax deficit generated by French multinationals
    oecd_stratified = oecd[
        [
            &#39;Parent jurisdiction (whitespaces cleaned)&#39;,
            &#39;Parent jurisdiction (alpha-3 code)&#39;,
            &#39;tax_deficit&#39;,
            &#39;tax_deficit_x_domestic&#39;,
            &#39;tax_deficit_x_tax_haven&#39;,
            &#39;tax_deficit_x_non_haven&#39;
        ]
    ].groupby(
        &#39;Parent jurisdiction (whitespaces cleaned)&#39;
    ).agg(
        {
            &#39;Parent jurisdiction (alpha-3 code)&#39;: &#39;first&#39;,
            &#39;tax_deficit&#39;: &#39;sum&#39;,
            &#39;tax_deficit_x_domestic&#39;: &#39;sum&#39;,
            &#39;tax_deficit_x_tax_haven&#39;: &#39;sum&#39;,
            &#39;tax_deficit_x_non_haven&#39;: &#39;sum&#39;
        }
    ).copy()

    oecd_stratified.reset_index(inplace=True)

    return oecd_stratified.copy()</code></pre>
</details>
</dd>
<dt id="tax_deficit_simulator.calculator.TaxDeficitCalculator.get_total_tax_deficits"><code class="name flex">
<span>def <span class="ident">get_total_tax_deficits</span></span>(<span>self, minimum_ETR=0.25)</span>
</code></dt>
<dd>
<div class="desc"><p>This method takes the selected minimum ETR as input and relies on the compute_all_tax_deficits, to output a Da-
taFrame with (i) the total tax defict of each in-sample country in 2021 EUR and (ii) the sum of these tax defi-
cits at the EU-27 and at the whole sample level. It can be considered as an intermediary step towards the fully
formatted table displayed on the online simulator (section "Multilateral implementation scenario").</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_total_tax_deficits(self, minimum_ETR=0.25):
    &#34;&#34;&#34;
    This method takes the selected minimum ETR as input and relies on the compute_all_tax_deficits, to output a Da-
    taFrame with (i) the total tax defict of each in-sample country in 2021 EUR and (ii) the sum of these tax defi-
    cits at the EU-27 and at the whole sample level. It can be considered as an intermediary step towards the fully
    formatted table displayed on the online simulator (section &#34;Multilateral implementation scenario&#34;).
    &#34;&#34;&#34;

    df = self.compute_all_tax_deficits(minimum_ETR=minimum_ETR)

    df = df[
        [&#39;Parent jurisdiction (whitespaces cleaned)&#39;, &#39;Parent jurisdiction (alpha-3 code)&#39;, &#39;tax_deficit&#39;]
    ]

    df.sort_values(
        by=&#39;Parent jurisdiction (whitespaces cleaned)&#39;,
        inplace=True
    )

    # We compute the sum of total tax deficits at the EU-27 level and for the whole sample
    total_eu = (df[&#39;Parent jurisdiction (alpha-3 code)&#39;].isin(eu_27_country_codes) * 1 * df[&#39;tax_deficit&#39;]).sum()
    total_whole_sample = df[&#39;tax_deficit&#39;].sum()

    # Possibly suboptimal process to add &#34;Total&#34; lines at the end of the DataFrame
    dict_df = df.to_dict()

    dict_df[df.columns[0]][len(df)] = &#39;Total - EU27&#39;
    dict_df[df.columns[1]][len(df)] = &#39;..&#39;
    dict_df[df.columns[2]][len(df)] = total_eu

    dict_df[df.columns[0]][len(df) + 1] = &#39;Total - Whole sample&#39;
    dict_df[df.columns[1]][len(df) + 1] = &#39;..&#39;
    dict_df[df.columns[2]][len(df) + 1] = total_whole_sample

    df = pd.DataFrame.from_dict(dict_df)

    return df.reset_index(drop=True)</code></pre>
</details>
</dd>
<dt id="tax_deficit_simulator.calculator.TaxDeficitCalculator.load_clean_data"><code class="name flex">
<span>def <span class="ident">load_clean_data</span></span>(<span>self, path_to_oecd='/Users/Paul-Emmanuel/Desktop/EU Tax Observatory/4. Own Work/0. Tax Deficit/Platform/tax_deficit_simulator/tax_deficit_simulator/data/oecd.csv', path_to_twz='/Users/Paul-Emmanuel/Desktop/EU Tax Observatory/4. Own Work/0. Tax Deficit/Platform/tax_deficit_simulator/tax_deficit_simulator/data/twz.csv', path_to_twz_domestic='/Users/Paul-Emmanuel/Desktop/EU Tax Observatory/4. Own Work/0. Tax Deficit/Platform/tax_deficit_simulator/tax_deficit_simulator/data/twz_domestic.csv', path_to_twz_CIT='/Users/Paul-Emmanuel/Desktop/EU Tax Observatory/4. Own Work/0. Tax Deficit/Platform/tax_deficit_simulator/tax_deficit_simulator/data/twz_CIT.csv', path_to_preprocessed_mean_wages='/Users/Paul-Emmanuel/Desktop/EU Tax Observatory/4. Own Work/0. Tax Deficit/Platform/tax_deficit_simulator/tax_deficit_simulator/data/preprocessed_mean_wages.csv', path_to_statutory_rates='/Users/Paul-Emmanuel/Desktop/EU Tax Observatory/4. Own Work/0. Tax Deficit/Platform/tax_deficit_simulator/tax_deficit_simulator/data/statutory_rates.csv', inplace=True)</span>
</code></dt>
<dd>
<div class="desc"><p>This method allows to load and clean data from 6 different sources:</p>
<ul>
<li>
<p>the "oecd.csv" file which was extracted from the OECD's aggregated and anonymized country-by-country repor-
ting, considering only the positive profit sample. Figures are in 2016 USD;</p>
</li>
<li>
<p>the "twz.csv" file which was extracted from the Table C4 of the TWZ 2019 online appendix. It presents, for
a number of countries, the amounts of profits shifted to tax havens that are re-allocated to them on an ultima-
te ownership basis. Figures are in 2016 USD million;</p>
</li>
<li>
<p>the "twz_domestic.csv" file, taken from the outputs of benchmark computations run on Stata. It presents for
each country the amount of corporate profits registered locally by domestic MNEs and the effective tax rate to
which they are subject. Figures are in 2016 USD billion;</p>
</li>
<li>
<p>the "twz_CIT.csv" file, extracted from Table U1 of the TWZ 2019 online appendix. It presents the corporate in-
come tax revenue of each country in 2016 USD billion;</p>
</li>
<li>
<p>the "preprocessed_mean_wages.csv" file, taken from the outputs of substance-based carve-outs run on Stata. For
each partner jurisdiction in the OECD's country-by-country data, it provides either a measure or an approxima-
tion of the local mean annual earnings in 2016 in current USD. It is built upon ILO data, more details being
provided in the methodological section of the Note n°1 of the Observatory on substance-based carve-outs;</p>
</li>
<li>
<p>the "statutory_rates.csv" file that provides, for a number of partner jurisdictions, their 2016 statutory cor-
porate income tax rates.</p>
</li>
</ul>
<p>Default paths are used to let the simulator run via the app.py file. If you wish to use the tax_deficit_calcula-
tor package in another context, you can save the data locally and give the method paths to the data files. The
possibility to load the files from an online host instead will soon be implemented.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_clean_data(
    self,
    path_to_oecd=path_to_oecd,
    path_to_twz=path_to_twz,
    path_to_twz_domestic=path_to_twz_domestic,
    path_to_twz_CIT=path_to_twz_CIT,
    path_to_preprocessed_mean_wages=path_to_preprocessed_mean_wages,
    path_to_statutory_rates=path_to_statutory_rates,
    inplace=True
):
    &#34;&#34;&#34;
    This method allows to load and clean data from 6 different sources:

    - the &#34;oecd.csv&#34; file which was extracted from the OECD&#39;s aggregated and anonymized country-by-country repor-
    ting, considering only the positive profit sample. Figures are in 2016 USD;

    - the &#34;twz.csv&#34; file which was extracted from the Table C4 of the TWZ 2019 online appendix. It presents, for
    a number of countries, the amounts of profits shifted to tax havens that are re-allocated to them on an ultima-
    te ownership basis. Figures are in 2016 USD million;

    - the &#34;twz_domestic.csv&#34; file, taken from the outputs of benchmark computations run on Stata. It presents for
    each country the amount of corporate profits registered locally by domestic MNEs and the effective tax rate to
    which they are subject. Figures are in 2016 USD billion;

    - the &#34;twz_CIT.csv&#34; file, extracted from Table U1 of the TWZ 2019 online appendix. It presents the corporate in-
    come tax revenue of each country in 2016 USD billion;

    - the &#34;preprocessed_mean_wages.csv&#34; file, taken from the outputs of substance-based carve-outs run on Stata. For
    each partner jurisdiction in the OECD&#39;s country-by-country data, it provides either a measure or an approxima-
    tion of the local mean annual earnings in 2016 in current USD. It is built upon ILO data, more details being
    provided in the methodological section of the Note n°1 of the Observatory on substance-based carve-outs;

    - the &#34;statutory_rates.csv&#34; file that provides, for a number of partner jurisdictions, their 2016 statutory cor-
    porate income tax rates.

    Default paths are used to let the simulator run via the app.py file. If you wish to use the tax_deficit_calcula-
    tor package in another context, you can save the data locally and give the method paths to the data files. The
    possibility to load the files from an online host instead will soon be implemented.
    &#34;&#34;&#34;
    try:

        # We try to read the files from the provided paths
        oecd = pd.read_csv(path_to_oecd)
        twz = pd.read_csv(path_to_twz, delimiter=&#39;;&#39;)
        twz_domestic = pd.read_csv(path_to_twz_domestic, delimiter=&#39;;&#39;)
        twz_CIT = pd.read_csv(path_to_twz_CIT, delimiter=&#39;;&#39;)
        preprocessed_mean_wages = pd.read_csv(path_to_preprocessed_mean_wages, delimiter=&#39;;&#39;)
        statutory_rates = pd.read_csv(path_to_statutory_rates, delimiter=&#39;;&#39;)

    except FileNotFoundError:

        # If at least one of the files is not found
        raise Exception(&#39;Are you sure these are the right paths for the source files?&#39;)

    # --- Cleaning the OECD data

    # We drop a few irrelevant columns from country-by-country data
    oecd.drop(
        columns=[&#39;PAN&#39;, &#39;Grouping&#39;, &#39;Flag Codes&#39;, &#39;Flags&#39;, &#39;YEA&#39;, &#39;Year&#39;],
        inplace=True
    )

    # We reshape the DataFrame from a long to a wide dataset
    oecd = oecd.pivot(
        index=[&#39;COU&#39;, &#39;Ultimate Parent Jurisdiction&#39;, &#39;JUR&#39;, &#39;Partner Jurisdiction&#39;],
        columns=&#39;Variable&#39;,
        values=&#39;Value&#39;
    ).reset_index()

    # We rename some columns to match the code that has been written before modifying how OECD data are loaded
    oecd.rename(
        columns={
            &#39;COU&#39;: &#39;Parent jurisdiction (alpha-3 code)&#39;,
            &#39;Ultimate Parent Jurisdiction&#39;: &#39;Parent jurisdiction (whitespaces cleaned)&#39;,
            &#39;JUR&#39;: &#39;Partner jurisdiction (alpha-3 code)&#39;,
            &#39;Partner Jurisdiction&#39;: &#39;Partner jurisdiction (whitespaces cleaned)&#39;
        },
        inplace=True
    )

    # Thanks to a function defined in utils.py, we rename the &#34;Foreign Jurisdictions Total&#34; field for all countries
    # that only report a domestic / foreign breakdown in their CbCR
    oecd[&#39;Partner jurisdiction (whitespaces cleaned)&#39;] = oecd.apply(rename_partner_jurisdictions, axis=1)

    # We eliminate stateless entities and the &#34;Foreign Jurisdictions Total&#34; filds
    oecd = oecd[
        ~oecd[&#39;Partner jurisdiction (whitespaces cleaned)&#39;].isin([&#39;Foreign Jurisdictions Total&#39;, &#39;Stateless&#39;])
    ].copy()

    # We replace missing &#34;Income Tax Paid&#34; values by the corresponding &#34;Income Tax Accrued&#34; values
    # (Some missing values remain even after this edit)
    oecd[&#39;Income Tax Paid (on Cash Basis)&#39;] = oecd.apply(
        (
            lambda row: row[&#39;Income Tax Paid (on Cash Basis)&#39;]
            if not np.isnan(row[&#39;Income Tax Paid (on Cash Basis)&#39;])
            else row[&#39;Income Tax Accrued - Current Year&#39;]
        ),
        axis=1
    )

    # We clean the statutory corporate income tax rate dataset
    statutory_rates[&#39;statrate&#39;] = statutory_rates[&#39;statrate&#39;].map(
        lambda x: x.replace(&#39;,&#39;, &#39;.&#39;) if isinstance(x, str) else x
    ).astype(float)

    # And we merge it with country-by-country data, on partner jurisdiction alpha-3 codes
    oecd = oecd.merge(
        statutory_rates,
        how=&#39;left&#39;,
        left_on=&#39;Partner jurisdiction (alpha-3 code)&#39;, right_on=&#39;partner&#39;
    )

    oecd.drop(columns=[&#39;partner&#39;], inplace=True)

    # We impute missing &#34;Income Tax Paid&#34; values assuming that pre-tax profits are taxed at the local statutory rate
    oecd[&#39;Income Tax Paid (on Cash Basis)&#39;] = oecd.apply(
        (
            lambda row: row[&#39;Income Tax Paid (on Cash Basis)&#39;]
            if not np.isnan(row[&#39;Income Tax Paid (on Cash Basis)&#39;])
            else row[&#39;Profit (Loss) before Income Tax&#39;] * row[&#39;statrate&#39;]
        ),
        axis=1
    )

    oecd.drop(columns=[&#39;statrate&#39;], inplace=True)

    # ETR computation (using tax paid as the numerator)
    oecd[&#39;ETR&#39;] = oecd[&#39;Income Tax Paid (on Cash Basis)&#39;] / oecd[&#39;Profit (Loss) before Income Tax&#39;]
    oecd[&#39;ETR&#39;] = oecd[&#39;ETR&#39;].map(lambda x: 0 if x &lt; 0 else x)

    # Adding an indicator variable for domestic profits (rows with the same parent and partner jurisdiction)
    oecd[&#39;Is domestic?&#39;] = oecd.apply(
        lambda row: row[&#39;Parent jurisdiction (alpha-3 code)&#39;] == row[&#39;Partner jurisdiction (alpha-3 code)&#39;],
        axis=1
    ) * 1

    # We add an indicator variable that takes value 1 if and only if the partner is a tax haven
    oecd[&#39;Is partner jurisdiction a tax haven?&#39;] = oecd[&#39;Partner jurisdiction (alpha-3 code)&#39;].isin(
        tax_haven_country_codes
    ) * 1

    # Adding another indicator variable that takes value 1 if and only if the partner is not a tax haven
    oecd[&#39;Is partner jurisdiction a non-haven?&#39;] = 1 - oecd[&#39;Is partner jurisdiction a tax haven?&#39;]

    # This indicator variable is used specifically for the simulation of carve-outs; it takes value 1 if and only if
    # the partner jurisdiction is not the parent jurisdiction, not a tax haven and not a regional aggregate
    oecd[&#39;Is partner jurisdiction a non-haven? - CO&#39;] = oecd.apply(
        (
            lambda row: 0
            if (
                row[&#39;Parent jurisdiction (alpha-3 code)&#39;] in COUNTRIES_WITH_MINIMUM_REPORTING
                and row[&#39;Partner jurisdiction (alpha-3 code)&#39;] == &#39;FJT&#39;
            ) or (
                row[&#39;Parent jurisdiction (alpha-3 code)&#39;] in COUNTRIES_WITH_CONTINENTAL_REPORTING
                and row[&#39;Partner jurisdiction (alpha-3 code)&#39;] in [&#39;GRPS&#39;, &#39;AFRIC&#39;, &#39;AMER&#39;, &#39;ASIAT&#39;, &#39;EUROP&#39;]
            ) or (
                row[&#39;Is domestic?&#39;] == 1
            )
            else row[&#39;Is partner jurisdiction a non-haven?&#39;]
        ),
        axis=1
    )

    # This indicator variable, used specifically for the simulation of carve-outs, takes value 1 if and only if the
    # partner is a regional aggregate
    oecd[&#39;Is partner jurisdiction an aggregate partner? - CO&#39;] = np.logical_and(
        oecd[&#39;Is domestic?&#39;] == 0,
        np.logical_and(
            oecd[&#39;Is partner jurisdiction a non-haven? - CO&#39;] == 0,
            oecd[&#39;Is partner jurisdiction a tax haven?&#39;] == 0
        )
    ) * 1

    # Thanks to a small function imported from utils.py, we manage the slightly problematic overlap between the
    # various indicator variables (&#34;Is domestic?&#34; sort of gets the priority over the others)
    oecd[&#39;Is partner jurisdiction a tax haven?&#39;] = oecd.apply(
        lambda row: manage_overlap_with_domestic(row, &#39;haven&#39;),
        axis=1
    )

    oecd[&#39;Is partner jurisdiction a non-haven?&#39;] = oecd.apply(
        lambda row: manage_overlap_with_domestic(row, &#39;non-haven&#39;),
        axis=1
    )

    # We need some more work on the data if we want to simulate substance-based carve-outs
    if self.carve_outs:

        # We merge earnings data with country-by-country data on partner jurisdiction codes
        oecd = oecd.merge(
            preprocessed_mean_wages[[&#39;partner2&#39;, &#39;earn&#39;]],
            how=&#39;left&#39;,
            left_on=&#39;Partner jurisdiction (alpha-3 code)&#39;, right_on=&#39;partner2&#39;
        )

        oecd.drop(columns=[&#39;partner2&#39;], inplace=True)

        oecd.rename(
            columns={
                &#39;earn&#39;: &#39;ANNUAL_VALUE&#39;
            },
            inplace=True
        )

        # We clean the mean annual earnings column
        oecd[&#39;ANNUAL_VALUE&#39;] = oecd[&#39;ANNUAL_VALUE&#39;].map(
            lambda x: x.replace(&#39;,&#39;, &#39;.&#39;) if isinstance(x, str) else x
        ).astype(float)

        # We deduce the payroll proxy from the number of employees and from mean annual earnings
        oecd[&#39;PAYROLL&#39;] = oecd[&#39;Number of Employees&#39;] * oecd[&#39;ANNUAL_VALUE&#39;] * (1 + self.payroll_premium / 100)

        # We compute substance-based carve-outs from both payroll and tangible assets
        oecd[&#39;CARVE_OUT&#39;] = self.carve_out_rate * (
            oecd[&#39;PAYROLL&#39;] + oecd[&#39;Tangible Assets other than Cash and Cash Equivalents&#39;] * self.assets_multiplier
        )

        # This column will contain slightly modified carve-outs, carve-outs being replaced by pre-tax profits
        # wherever the former exceeds the latter
        oecd[&#39;CARVE_OUT_TEMP&#39;] = oecd.apply(
            (
                lambda row: row[&#39;CARVE_OUT&#39;] if row[&#39;Profit (Loss) before Income Tax&#39;] &gt; row[&#39;CARVE_OUT&#39;]
                or np.isnan(row[&#39;CARVE_OUT&#39;])
                else row[&#39;Profit (Loss) before Income Tax&#39;]
            ),
            axis=1
        )

        # We exclude rows with missing carve-out values in a temporary DataFrame
        oecd_temp = oecd[
            ~np.logical_or(
                oecd[&#39;PAYROLL&#39;].isnull(),
                oecd[&#39;Tangible Assets other than Cash and Cash Equivalents&#39;].isnull()
            )
        ].copy()

        # We compute the average reduction in non-haven pre-tax profits due to carve-outs
        self.avg_carve_out_impact_non_haven = (
            oecd_temp[
                oecd_temp[&#39;Is partner jurisdiction a non-haven? - CO&#39;] == 1
            ][&#39;CARVE_OUT_TEMP&#39;].sum() /
            oecd_temp[
                oecd_temp[&#39;Is partner jurisdiction a non-haven? - CO&#39;] == 1
            ][&#39;Profit (Loss) before Income Tax&#39;].sum()
        )

        # We do the same for pre-tax profits booked in tax havens, domestically and in aggregate partners
        self.avg_carve_out_impact_tax_haven = (
            oecd_temp[oecd_temp[&#39;Is partner jurisdiction a tax haven?&#39;] == 1][&#39;CARVE_OUT_TEMP&#39;].sum() /
            oecd_temp[
                oecd_temp[&#39;Is partner jurisdiction a tax haven?&#39;] == 1
            ][&#39;Profit (Loss) before Income Tax&#39;].sum()
        )
        self.avg_carve_out_impact_domestic = (
            oecd_temp[oecd_temp[&#39;Is domestic?&#39;] == 1][&#39;CARVE_OUT_TEMP&#39;].sum() /
            oecd_temp[oecd_temp[&#39;Is domestic?&#39;] == 1][&#39;Profit (Loss) before Income Tax&#39;].sum()
        )
        self.avg_carve_out_impact_aggregate = (
            oecd_temp[
                oecd_temp[&#39;Is partner jurisdiction an aggregate partner? - CO&#39;] == 1
            ][&#39;CARVE_OUT_TEMP&#39;].sum() /
            oecd_temp[
                oecd_temp[&#39;Is partner jurisdiction an aggregate partner? - CO&#39;] == 1
            ][&#39;Profit (Loss) before Income Tax&#39;].sum()
        )

        # We impute missing carve-out values based on these average reductions in pre-tax profits
        oecd[&#39;CARVE_OUT&#39;] = oecd.apply(
            lambda row: impute_missing_carve_out_values(
                row,
                avg_carve_out_impact_domestic=self.avg_carve_out_impact_domestic,
                avg_carve_out_impact_tax_haven=self.avg_carve_out_impact_tax_haven,
                avg_carve_out_impact_non_haven=self.avg_carve_out_impact_non_haven,
                avg_carve_out_impact_aggregate=self.avg_carve_out_impact_aggregate
            ),
            axis=1
        )

        # Some missing values remain whenever profits before tax are missing
        oecd = oecd[~oecd[&#39;CARVE_OUT&#39;].isnull()].copy()

        # We remove substance-based carve-outs from pre-tax profits
        oecd[&#39;Profit (Loss) before Income Tax&#39;] = oecd.apply(
            (
                lambda row: row[&#39;Profit (Loss) before Income Tax&#39;] - row[&#39;CARVE_OUT&#39;]
                if row[&#39;Profit (Loss) before Income Tax&#39;] - row[&#39;CARVE_OUT&#39;] &gt;= 0
                else 0
            ),
            axis=1
        )

    # --- Cleaning the TWZ tax haven profits data

    # Adding an indicator variable for OECD reporting - We do not consider the Swedish CbCR
    twz[&#39;Is parent in OECD data?&#39;] = twz[&#39;Alpha-3 country code&#39;].map(
        lambda x: x in oecd[&#39;Parent jurisdiction (alpha-3 code)&#39;].unique() if x != &#39;SWE&#39; else False
    ) * 1

    # We reformat numeric columns - Resulting figures are expressed in 2016 USD
    for column_name in [&#39;Profits in all tax havens&#39;, &#39;Profits in all tax havens (positive only)&#39;]:
        twz[column_name] = twz[column_name].map(lambda x: x.replace(&#39;,&#39;, &#39;.&#39;))
        twz[column_name] = twz[column_name].astype(float) * 1000000

        if self.carve_outs:
            # If we want to simulate carve-outs, we need to downgrade TWZ tax haven profits by the average reduction
            # due to carve-outs that is observed for tax haven profits in the OECD data
            twz[column_name] *= (1 - self.avg_carve_out_impact_tax_haven)
        else:
            continue

    # We filter out countries with 0 profits in tax havens
    twz = twz[twz[&#39;Profits in all tax havens (positive only)&#39;] &gt; 0].copy()

    # --- Cleaning the TWZ domestic profits data

    # Reformatting the profits column - Resulting figures are expressed in 2016 USD
    twz_domestic[&#39;Domestic profits&#39;] = twz_domestic[&#39;Domestic profits&#39;]\
        .map(lambda x: x.replace(&#39;,&#39;, &#39;.&#39;))\
        .astype(float) * 1000000000

    # Reformatting the ETR column
    twz_domestic[&#39;Domestic ETR&#39;] = twz_domestic[&#39;Domestic ETR&#39;].map(lambda x: x.replace(&#39;,&#39;, &#39;.&#39;)).astype(float)

    if self.carve_outs:
        # If we want to simulate carve-outs, we need to downgrade TWZ domestic profits by the average reduction due
        # to carve-outs that is observed for domestic profits in the OECD data
        twz_domestic[&#39;Domestic profits&#39;] *= (1 - self.avg_carve_out_impact_domestic)

    # --- Cleaning the TWZ CIT revenue data

    # Reformatting the CIT revenue column - Resulting figures are expressed in 2016 USD
    twz_CIT[&#39;CIT revenue&#39;] = twz_CIT[&#39;CIT revenue&#39;]\
        .map(lambda x: x.replace(&#39;,&#39;, &#39;.&#39;))\
        .astype(float) * 1000000000

    if inplace:
        self.oecd = oecd.copy()
        self.twz = twz.copy()
        self.twz_domestic = twz_domestic.copy()
        self.twz_CIT = twz_CIT.copy()
        self.mean_wages = preprocessed_mean_wages.copy()

    else:

        if self.carve_outs:
            return oecd.copy(), twz.copy(), twz_domestic.copy(), twz_CIT.copy(), preprocessed_mean_wages.copy()

        else:
            return oecd.copy(), twz.copy(), twz_domestic.copy(), twz_CIT.copy()</code></pre>
</details>
</dd>
<dt id="tax_deficit_simulator.calculator.TaxDeficitCalculator.output_intermediary_scenario_gain_formatted"><code class="name flex">
<span>def <span class="ident">output_intermediary_scenario_gain_formatted</span></span>(<span>self, minimum_ETR=0.25)</span>
</code></dt>
<dd>
<div class="desc"><p>This method is used in the "app.py" file, which lies behind the Streamlit simulator. It allows to produce the
table presented on the "Partial cooperation scenario" page. It takes as input the selected minimum ETR and then,
widely relies on the compute_intermediary_scenario_gain method defined above. It mostly consists in a series of
formatting steps to make the table more readable and understandable.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_intermediary_scenario_gain_formatted(self, minimum_ETR=0.25):
    &#34;&#34;&#34;
    This method is used in the &#34;app.py&#34; file, which lies behind the Streamlit simulator. It allows to produce the
    table presented on the &#34;Partial cooperation scenario&#34; page. It takes as input the selected minimum ETR and then,
    widely relies on the compute_intermediary_scenario_gain method defined above. It mostly consists in a series of
    formatting steps to make the table more readable and understandable.
    &#34;&#34;&#34;

    # We compute corporate tax revenue gains from the partial cooperation scenario
    df = self.compute_intermediary_scenario_gain(minimum_ETR=minimum_ETR)

    # We eliminate irrelevant columns
    df.drop(columns=[&#39;tax_deficit&#39;, &#39;From foreign MNEs&#39;], inplace=True)

    # We reformat figures with a thousand separator and a 0-decimal rounding
    df[&#39;Total&#39;] = df[&#39;Total&#39;].map(&#39;{:,.0f}&#39;.format)

    # We rename columns to make them more explicit
    df.rename(
        columns={
            &#39;Parent jurisdiction (whitespaces cleaned)&#39;: &#39;Taxing country&#39;,
            &#39;Total&#39;: &#39;Collectible tax deficit (€m)&#39;
        },
        inplace=True
    )

    # We add quotation marks to the &#34;Europe&#34; and &#34;Other Europe&#34; fields
    df[&#39;Taxing country&#39;] = df[&#39;Taxing country&#39;].map(
        lambda x: x if x not in [&#39;Europe&#39;, &#39;Other Europe&#39;] else f&#39;&#34;{x}&#34;&#39;
    )

    return df.copy()</code></pre>
</details>
</dd>
<dt id="tax_deficit_simulator.calculator.TaxDeficitCalculator.output_tax_deficits_formatted"><code class="name flex">
<span>def <span class="ident">output_tax_deficits_formatted</span></span>(<span>self, minimum_ETR=0.25)</span>
</code></dt>
<dd>
<div class="desc"><p>This method is used in the "app.py" file, which underlies the Streamlit simulator. It is used to produce the
table on the "Multilateral implementation scenario" page. It takes as input the selected minimum ETR and widely
relies on the get_total_tax_deficits method defined above. It mostly consists in a series of formatting steps.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_tax_deficits_formatted(self, minimum_ETR=0.25):
    &#34;&#34;&#34;
    This method is used in the &#34;app.py&#34; file, which underlies the Streamlit simulator. It is used to produce the
    table on the &#34;Multilateral implementation scenario&#34; page. It takes as input the selected minimum ETR and widely
    relies on the get_total_tax_deficits method defined above. It mostly consists in a series of formatting steps.
    &#34;&#34;&#34;

    # We build the unformatted results table thanks to the get_total_tax_deficits method
    df = self.get_total_tax_deficits(minimum_ETR=minimum_ETR)

    # We only want to include certain countries in the output table:
    # - all the EU-27 countries that are included in our sample (4 unfortunately missing for now)
    # - most of the OECD-reporting countries, excluding only Singapore and Bermuda

    # We first build the list of OECD-reporting countries, excluding Singapore and Bermuda
    oecd_reporting_countries = self.oecd[&#39;Parent jurisdiction (alpha-3 code)&#39;].unique()
    oecd_reporting_countries = [
        country_code for country_code in oecd_reporting_countries if country_code not in [&#39;SGP&#39;, &#39;BMU&#39;]
    ]

    # From this list, we build the relevant boolean indexing mask that corresponds to our filtering choice
    mask = np.logical_or(
        df[&#39;Parent jurisdiction (alpha-3 code)&#39;].isin(eu_27_country_codes),
        df[&#39;Parent jurisdiction (alpha-3 code)&#39;].isin(oecd_reporting_countries)
    )

    df = df[mask].copy()

    # We sort values by the name of the parent jurisdiction, in the alphabetical order
    df.sort_values(
        by=&#39;Parent jurisdiction (whitespaces cleaned)&#39;,
        inplace=True
    )

    df.reset_index(drop=True, inplace=True)

    # We convert 2021 EUR figures into 2021 million EUR ones
    df[&#39;tax_deficit&#39;] = df[&#39;tax_deficit&#39;] / 10**6

    # Again, the same possibly sub-optimal process to add the &#34;Total&#34; lines
    dict_df = df.to_dict()

    dict_df[df.columns[0]][len(df)] = &#39;Total - EU27&#39;
    dict_df[df.columns[1]][len(df)] = &#39;..&#39;
    dict_df[df.columns[2]][len(df)] = df[
        df[&#39;Parent jurisdiction (alpha-3 code)&#39;].isin(eu_27_country_codes)
    ][&#39;tax_deficit&#39;].sum()

    dict_df[df.columns[0]][len(df) + 1] = &#39;Total - Whole sample&#39;
    dict_df[df.columns[1]][len(df) + 1] = &#39;..&#39;
    dict_df[df.columns[2]][len(df) + 1] = df[&#39;tax_deficit&#39;].sum()

    df = pd.DataFrame.from_dict(dict_df)

    # We drop country codes
    df.drop(columns=[&#39;Parent jurisdiction (alpha-3 code)&#39;], inplace=True)

    # And we eventually reformat figures with a thousand separator and a 0-decimal rounding
    df[&#39;tax_deficit&#39;] = df[&#39;tax_deficit&#39;].map(&#39;{:,.0f}&#39;.format)

    # We rename columns
    df.rename(
        columns={
            &#39;Parent jurisdiction (whitespaces cleaned)&#39;: &#39;Headquarter country&#39;,
            &#39;tax_deficit&#39;: &#39;Collectible tax deficit (€m)&#39;
        },
        inplace=True
    )

    return df.copy()</code></pre>
</details>
</dd>
<dt id="tax_deficit_simulator.calculator.TaxDeficitCalculator.output_unilateral_scenario_gain_formatted"><code class="name flex">
<span>def <span class="ident">output_unilateral_scenario_gain_formatted</span></span>(<span>self, country, minimum_ETR=0.25)</span>
</code></dt>
<dd>
<div class="desc"><p>This method is used in the "app.py" file, which lies behind the Streamlit simulator. It allows to produce the
table presented on the "Unilateral implementation scenario" page. It takes as input the selected minimum ETR and
the name of the country assumed to unilaterally implement the tax deficit collection. Then, it widely relies on
the compute_unilateral_scenario_gain method defined above and mostly consists in a series of formatting steps to
make the table more readable and understandable.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_unilateral_scenario_gain_formatted(self, country, minimum_ETR=0.25):
    &#34;&#34;&#34;
    This method is used in the &#34;app.py&#34; file, which lies behind the Streamlit simulator. It allows to produce the
    table presented on the &#34;Unilateral implementation scenario&#34; page. It takes as input the selected minimum ETR and
    the name of the country assumed to unilaterally implement the tax deficit collection. Then, it widely relies on
    the compute_unilateral_scenario_gain method defined above and mostly consists in a series of formatting steps to
    make the table more readable and understandable.
    &#34;&#34;&#34;

    # We compute the gains from the unilateral implementation of the tax deficit collection for the taxing country
    df = self.compute_unilateral_scenario_gain(
        country=country,
        minimum_ETR=minimum_ETR
    )

    # We convert the numeric outputs into 2021 million EUR
    df[f&#39;Collectible tax deficit for {country}&#39;] = df[f&#39;Collectible tax deficit for {country}&#39;] / 10**6

    # We reformat figures with two decimals and a thousand separator
    df[f&#39;Collectible tax deficit for {country}&#39;] = \
        df[f&#39;Collectible tax deficit for {country}&#39;].map(&#39;{:,.2f}&#39;.format)

    # We rename columns in accordance
    df.rename(
        columns={
            f&#39;Collectible tax deficit for {country}&#39;: f&#39;Collectible tax deficit for {country} (€m)&#39;,
            &#39;Parent jurisdiction (whitespaces cleaned)&#39;: &#39;Headquarter country&#39;
        },
        inplace=True
    )

    return df.copy()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tax_deficit_simulator" href="index.html">tax_deficit_simulator</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tax_deficit_simulator.calculator.TaxDeficitCalculator" href="#tax_deficit_simulator.calculator.TaxDeficitCalculator">TaxDeficitCalculator</a></code></h4>
<ul class="">
<li><code><a title="tax_deficit_simulator.calculator.TaxDeficitCalculator.assess_carve_out_impact" href="#tax_deficit_simulator.calculator.TaxDeficitCalculator.assess_carve_out_impact">assess_carve_out_impact</a></code></li>
<li><code><a title="tax_deficit_simulator.calculator.TaxDeficitCalculator.check_appendix_A2" href="#tax_deficit_simulator.calculator.TaxDeficitCalculator.check_appendix_A2">check_appendix_A2</a></code></li>
<li><code><a title="tax_deficit_simulator.calculator.TaxDeficitCalculator.check_tax_deficit_computations" href="#tax_deficit_simulator.calculator.TaxDeficitCalculator.check_tax_deficit_computations">check_tax_deficit_computations</a></code></li>
<li><code><a title="tax_deficit_simulator.calculator.TaxDeficitCalculator.check_unilateral_scenario_gain_computations" href="#tax_deficit_simulator.calculator.TaxDeficitCalculator.check_unilateral_scenario_gain_computations">check_unilateral_scenario_gain_computations</a></code></li>
<li><code><a title="tax_deficit_simulator.calculator.TaxDeficitCalculator.combine_haven_tax_deficits" href="#tax_deficit_simulator.calculator.TaxDeficitCalculator.combine_haven_tax_deficits">combine_haven_tax_deficits</a></code></li>
<li><code><a title="tax_deficit_simulator.calculator.TaxDeficitCalculator.compute_all_tax_deficits" href="#tax_deficit_simulator.calculator.TaxDeficitCalculator.compute_all_tax_deficits">compute_all_tax_deficits</a></code></li>
<li><code><a title="tax_deficit_simulator.calculator.TaxDeficitCalculator.compute_intermediary_scenario_gain" href="#tax_deficit_simulator.calculator.TaxDeficitCalculator.compute_intermediary_scenario_gain">compute_intermediary_scenario_gain</a></code></li>
<li><code><a title="tax_deficit_simulator.calculator.TaxDeficitCalculator.compute_unilateral_scenario_gain" href="#tax_deficit_simulator.calculator.TaxDeficitCalculator.compute_unilateral_scenario_gain">compute_unilateral_scenario_gain</a></code></li>
<li><code><a title="tax_deficit_simulator.calculator.TaxDeficitCalculator.get_alternative_non_haven_factor" href="#tax_deficit_simulator.calculator.TaxDeficitCalculator.get_alternative_non_haven_factor">get_alternative_non_haven_factor</a></code></li>
<li><code><a title="tax_deficit_simulator.calculator.TaxDeficitCalculator.get_carve_outs_rate_table" href="#tax_deficit_simulator.calculator.TaxDeficitCalculator.get_carve_outs_rate_table">get_carve_outs_rate_table</a></code></li>
<li><code><a title="tax_deficit_simulator.calculator.TaxDeficitCalculator.get_carve_outs_table" href="#tax_deficit_simulator.calculator.TaxDeficitCalculator.get_carve_outs_table">get_carve_outs_table</a></code></li>
<li><code><a title="tax_deficit_simulator.calculator.TaxDeficitCalculator.get_carve_outs_table_2" href="#tax_deficit_simulator.calculator.TaxDeficitCalculator.get_carve_outs_table_2">get_carve_outs_table_2</a></code></li>
<li><code><a title="tax_deficit_simulator.calculator.TaxDeficitCalculator.get_non_haven_imputation_ratio" href="#tax_deficit_simulator.calculator.TaxDeficitCalculator.get_non_haven_imputation_ratio">get_non_haven_imputation_ratio</a></code></li>
<li><code><a title="tax_deficit_simulator.calculator.TaxDeficitCalculator.get_stratified_oecd_data" href="#tax_deficit_simulator.calculator.TaxDeficitCalculator.get_stratified_oecd_data">get_stratified_oecd_data</a></code></li>
<li><code><a title="tax_deficit_simulator.calculator.TaxDeficitCalculator.get_total_tax_deficits" href="#tax_deficit_simulator.calculator.TaxDeficitCalculator.get_total_tax_deficits">get_total_tax_deficits</a></code></li>
<li><code><a title="tax_deficit_simulator.calculator.TaxDeficitCalculator.load_clean_data" href="#tax_deficit_simulator.calculator.TaxDeficitCalculator.load_clean_data">load_clean_data</a></code></li>
<li><code><a title="tax_deficit_simulator.calculator.TaxDeficitCalculator.output_intermediary_scenario_gain_formatted" href="#tax_deficit_simulator.calculator.TaxDeficitCalculator.output_intermediary_scenario_gain_formatted">output_intermediary_scenario_gain_formatted</a></code></li>
<li><code><a title="tax_deficit_simulator.calculator.TaxDeficitCalculator.output_tax_deficits_formatted" href="#tax_deficit_simulator.calculator.TaxDeficitCalculator.output_tax_deficits_formatted">output_tax_deficits_formatted</a></code></li>
<li><code><a title="tax_deficit_simulator.calculator.TaxDeficitCalculator.output_unilateral_scenario_gain_formatted" href="#tax_deficit_simulator.calculator.TaxDeficitCalculator.output_unilateral_scenario_gain_formatted">output_unilateral_scenario_gain_formatted</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>